{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/wixo/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/wixo/source/css/bootstrap-responsive.css","path":"css/bootstrap-responsive.css","modified":0,"renderable":1},{"_id":"themes/wixo/source/css/font-awesome.css","path":"css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/wixo/source/css/google-fonts.css","path":"css/google-fonts.css","modified":0,"renderable":1},{"_id":"themes/wixo/source/css/highlight.css","path":"css/highlight.css","modified":0,"renderable":1},{"_id":"themes/wixo/source/css/responsive.css","path":"css/responsive.css","modified":0,"renderable":1},{"_id":"themes/wixo/source/css/sidenav.css","path":"css/sidenav.css","modified":0,"renderable":1},{"_id":"themes/wixo/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/wixo/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/wixo/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/wixo/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/wixo/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/wixo/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/wixo/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/wixo/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/wixo/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/wixo/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/wixo/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/wixo/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/wixo/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/wixo/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/wixo/source/img/github-sprite.png","path":"img/github-sprite.png","modified":0,"renderable":1},{"_id":"themes/wixo/source/img/glyphicons-halflings-white.png","path":"img/glyphicons-halflings-white.png","modified":0,"renderable":1},{"_id":"themes/wixo/source/img/glyphicons-halflings.png","path":"img/glyphicons-halflings.png","modified":0,"renderable":1},{"_id":"themes/wixo/source/js/gallery.js","path":"js/gallery.js","modified":0,"renderable":1},{"_id":"themes/wixo/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":0,"renderable":1},{"_id":"themes/wixo/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/wixo/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":0,"renderable":1},{"_id":"themes/wixo/source/js/jquery.tableofcontents.min.js","path":"js/jquery.tableofcontents.min.js","modified":0,"renderable":1},{"_id":"themes/wixo/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/wixo/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/wixo/source/js/tocgenerator.min.js","path":"js/tocgenerator.min.js","modified":0,"renderable":1},{"_id":"themes/wixo/source/fonts/google-fonts/0AKsP294HTD-nvJgucYTaIbN6UDyHWBl620a-IRfuBk.woff","path":"fonts/google-fonts/0AKsP294HTD-nvJgucYTaIbN6UDyHWBl620a-IRfuBk.woff","modified":0,"renderable":1},{"_id":"themes/wixo/source/fonts/google-fonts/0XxGQsSc1g4rdRdjJKZrNBsxEYwM7FgeyaSgU71cLG0.woff","path":"fonts/google-fonts/0XxGQsSc1g4rdRdjJKZrNBsxEYwM7FgeyaSgU71cLG0.woff","modified":0,"renderable":1},{"_id":"themes/wixo/source/fonts/google-fonts/2UX7WLTfW3W8TclTUvlFyQ.woff","path":"fonts/google-fonts/2UX7WLTfW3W8TclTUvlFyQ.woff","modified":0,"renderable":1},{"_id":"themes/wixo/source/fonts/google-fonts/LKf8nhXsWg5ybwEGXk8UBQ.woff","path":"fonts/google-fonts/LKf8nhXsWg5ybwEGXk8UBQ.woff","modified":0,"renderable":1},{"_id":"themes/wixo/source/fonts/google-fonts/PIPMHY90P7jtyjpXuZ2cLD8E0i7KZn-EPnyo3HZu7kw.woff","path":"fonts/google-fonts/PIPMHY90P7jtyjpXuZ2cLD8E0i7KZn-EPnyo3HZu7kw.woff","modified":0,"renderable":1},{"_id":"themes/wixo/source/fonts/google-fonts/UyYrYy3ltEffJV9QueSi4RdbPw3QSf9R-kE0EsQUn2A.woff","path":"fonts/google-fonts/UyYrYy3ltEffJV9QueSi4RdbPw3QSf9R-kE0EsQUn2A.woff","modified":0,"renderable":1},{"_id":"themes/wixo/source/fonts/google-fonts/cj2hUnSRBhwmSPr9kS5899kZXW4sYc4BjuAIFc1SXII.woff","path":"fonts/google-fonts/cj2hUnSRBhwmSPr9kS5899kZXW4sYc4BjuAIFc1SXII.woff","modified":0,"renderable":1},{"_id":"themes/wixo/source/fonts/google-fonts/lILlYDvubYemzYzN7GbLkHhCUOGz7vYGh680lGh-uXM.woff","path":"fonts/google-fonts/lILlYDvubYemzYzN7GbLkHhCUOGz7vYGh680lGh-uXM.woff","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/ios-mdm.md","hash":"52a3d5d376bb374708b51e22cfa4a565ed44a0e7","modified":1712841935649},{"_id":"source/_posts/java-go.md","hash":"496339bb92edf8de4a27183164a53a0adfcc47f0","modified":1712841935633},{"_id":"source/_posts/mongodb-api.md","hash":"92cacd6bbc8c5bdfb9f3dba49de43de8220fb6f9","modified":1712841935646},{"_id":"source/_posts/nosql-mongodb.md","hash":"561eeb7535b99ae93ab0fce115bc8ba033539e74","modified":1504577014000},{"_id":"source/_posts/redis-list.md","hash":"124c5c78d6c030d130e735d42e85cfb2b2afc098","modified":1712841935636},{"_id":"source/_posts/redis-command.md","hash":"384b037994704b6126a028ffbb85354725a61945","modified":1712841935639},{"_id":"source/_posts/redis-set.md","hash":"a0737d7cd173fcc00b101a4a055faba42ede24ca","modified":1712841935655},{"_id":"source/_posts/ssl-ca.md","hash":"3e36897597fb46011d14a8e9c21d68a9fcc1a59f","modified":1712841935627},{"_id":"source/_posts/scrum.md","hash":"c27d32498ec419d59078b6712ba99fecf8c02e64","modified":1712841935642},{"_id":"source/_posts/team-building.md","hash":"505518b920fac480e61b27a14c3e006c88d84d28","modified":1712841935644},{"_id":"themes/wixo/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1712841364414},{"_id":"themes/wixo/LICENSE","hash":"a708d11fd1944ab4b94b39a8c83c75f362a170d7","modified":1712840662667},{"_id":"themes/wixo/README.md","hash":"70927f91b9f05ba006829e6ba8ee70d45ac463b3","modified":1712840662668},{"_id":"themes/wixo/_config.yml","hash":"7da7eb771042ebb02f6240fb7b2511b2074c6bd7","modified":1712842697658},{"_id":"themes/wixo/languages/default.yml","hash":"017ca7565d54da1f09434139b6c9e45421da4819","modified":1712840662668},{"_id":"themes/wixo/languages/zh-CN.yml","hash":"4123239b8cf9315cea79d38ec0f95da27a942bf3","modified":1712840662668},{"_id":"themes/wixo/languages/zh-TW.yml","hash":"f4238539fa1d496ccda46d987ba5057ee4bee6ce","modified":1712840662668},{"_id":"themes/wixo/layout/page.ejs","hash":"21612a42b29cb20f106bc2716c598e69db142750","modified":1712840662669},{"_id":"themes/wixo/layout/layout.ejs","hash":"5ebf1976a5224dc37967ffe3dd5f24a7a258cc92","modified":1712840662669},{"_id":"themes/wixo/layout/index.ejs","hash":"59b90f16c446483e54beb442dff5d1c0873694ae","modified":1712840662669},{"_id":"themes/wixo/layout/_partial/after_footer.ejs","hash":"c4b246bbe355be3606ae9e33a76337cadbb65766","modified":1712840662668},{"_id":"themes/wixo/layout/_partial/footer.ejs","hash":"2b6f117c8874ba9e6ba21a0221df5fc3ce16eae7","modified":1712842697654},{"_id":"themes/wixo/layout/_partial/index.ejs","hash":"b7498362661e599c74b644005c5847258a578684","modified":1712840662668},{"_id":"themes/wixo/layout/_partial/article.ejs","hash":"85b7f72d493ec33923a9c0fef8c6ee0c1dd0f81d","modified":1712840662668},{"_id":"themes/wixo/layout/_partial/head.ejs","hash":"05aa768c74afe23b1b45d390074ac8cce6e9f1dc","modified":1712840662668},{"_id":"themes/wixo/source/css/bootstrap-responsive.css","hash":"a5f7de688cddfcec69ec3c573868a4870c1cea0a","modified":1712840662669},{"_id":"themes/wixo/source/css/font-awesome.css","hash":"6df51eee1e75e450cb9cd71e925e6aa9ac2d6a9d","modified":1712840662670},{"_id":"themes/wixo/source/css/google-fonts.css","hash":"91e629d0a0a531e920252788ed8863c26608c2b2","modified":1712840662670},{"_id":"themes/wixo/source/css/responsive.css","hash":"ad1681cc7b3df942711d417af824e3581dc12c07","modified":1712840662670},{"_id":"themes/wixo/source/css/sidenav.css","hash":"04b458c0ba1990d1ee51152f86c4fbefc8f60241","modified":1712840662670},{"_id":"themes/wixo/source/css/highlight.css","hash":"d08d05bbb29246eb5e4a29d6586f89a055b97243","modified":1712840662670},{"_id":"themes/wixo/source/css/style.css","hash":"af929ab46b01c12df72baf8536eb92692cd3a9d6","modified":1712840662670},{"_id":"themes/wixo/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1712840662670},{"_id":"themes/wixo/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1712840662671},{"_id":"themes/wixo/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1712840662671},{"_id":"themes/wixo/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1712840662671},{"_id":"themes/wixo/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1712840662671},{"_id":"themes/wixo/source/fancybox/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1712840662671},{"_id":"themes/wixo/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1712840662671},{"_id":"themes/wixo/source/fancybox/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1712840662671},{"_id":"themes/wixo/source/fonts/fontawesome-webfont.eot","hash":"0183979056f0b87616cd99d5c54a48f3b771eee6","modified":1712840662672},{"_id":"themes/wixo/source/fonts/fontawesome-webfont.woff","hash":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c","modified":1712840662673},{"_id":"themes/wixo/source/img/github-sprite.png","hash":"4d7ee33beaaebf002ba57a172d159e46194ae481","modified":1712840662675},{"_id":"themes/wixo/source/img/glyphicons-halflings-white.png","hash":"a25c4705320fd63c33790e666872910e702b9bf6","modified":1712840662675},{"_id":"themes/wixo/source/img/glyphicons-halflings.png","hash":"84f613631b07d4fe22acbab50e551c0fe04bd78b","modified":1712840662676},{"_id":"themes/wixo/source/js/gallery.js","hash":"d19f1b1cc5b75e21ca1d643b6dae9490ead28b55","modified":1712840662676},{"_id":"themes/wixo/source/js/jquery.imagesloaded.min.js","hash":"3eb6381d2ed4b706020e4be5aff024aab4bcabc5","modified":1712840662676},{"_id":"themes/wixo/source/js/tocgenerator.min.js","hash":"64f09930154a2c9e0f8fde0c472c222eed86a54d","modified":1712840662677},{"_id":"themes/wixo/source/js/jquery.tableofcontents.min.js","hash":"38a3cbc147d4d639596cdda07d88f4e052ef31b0","modified":1712840662676},{"_id":"themes/wixo/source/js/bootstrap.min.js","hash":"5814e91bb6276f4de8b7951c965f2f190a03978d","modified":1712840662676},{"_id":"themes/wixo/source/js/search.js","hash":"901b18b539a0cc6c2b90f93e79faf43e590fe3fd","modified":1712840662676},{"_id":"themes/wixo/layout/_partial/post/google_analytics.ejs","hash":"b4673ae5ec66daf91617badfe34739be0ac5c498","modified":1712840662669},{"_id":"themes/wixo/source/js/main.js","hash":"51bc51e107dbd835022a36bbd60e5428e21f6894","modified":1712840662676},{"_id":"themes/wixo/layout/_partial/post/pagination.ejs","hash":"0c8deea4ba24ee74d2ed95578eac18e29ff4f065","modified":1712840662669},{"_id":"themes/wixo/layout/_partial/post/toc.ejs","hash":"814d1ecb7fa89107fb7173fe215f2a5269e069ff","modified":1712840662669},{"_id":"themes/wixo/source/fonts/google-fonts/0AKsP294HTD-nvJgucYTaIbN6UDyHWBl620a-IRfuBk.woff","hash":"1d9bb14c006d39d7eb0812a85567c7431f899b8d","modified":1712840662674},{"_id":"themes/wixo/source/fonts/google-fonts/cj2hUnSRBhwmSPr9kS5899kZXW4sYc4BjuAIFc1SXII.woff","hash":"17a484b92c0dacc8e8b4f0d38ccc1db400819d1d","modified":1712840662675},{"_id":"themes/wixo/source/fonts/google-fonts/2UX7WLTfW3W8TclTUvlFyQ.woff","hash":"87deb174af2e2beebb9f09d618a5159ca299a3d0","modified":1712840662674},{"_id":"themes/wixo/source/fonts/google-fonts/0XxGQsSc1g4rdRdjJKZrNBsxEYwM7FgeyaSgU71cLG0.woff","hash":"33225e85c33279e7b4f0c5c65ff93bec740dd59c","modified":1712840662674},{"_id":"themes/wixo/source/fonts/google-fonts/PIPMHY90P7jtyjpXuZ2cLD8E0i7KZn-EPnyo3HZu7kw.woff","hash":"18dc51e642b4df958098d3bbc6d3ba0237ef6150","modified":1712840662675},{"_id":"themes/wixo/source/fonts/google-fonts/lILlYDvubYemzYzN7GbLkHhCUOGz7vYGh680lGh-uXM.woff","hash":"e6c9f1e5a6a966a8f7250201356f351890a48921","modified":1712840662675},{"_id":"themes/wixo/source/fonts/google-fonts/LKf8nhXsWg5ybwEGXk8UBQ.woff","hash":"f401d51152681048c06187c5d3919b1407b899c5","modified":1712840662674},{"_id":"themes/wixo/source/fonts/google-fonts/UyYrYy3ltEffJV9QueSi4RdbPw3QSf9R-kE0EsQUn2A.woff","hash":"d9f913d09bb3c25749daf8e7ab829c850a842929","modified":1712840662675},{"_id":"themes/wixo/source/css/bootstrap.min.css","hash":"b982b68f818bba6fc9fead73d25d96a48972311e","modified":1712840662670},{"_id":"themes/wixo/source/fonts/FontAwesome.otf","hash":"6270a4a561a69fef5f5cc18cdf9efc256ec2ccbe","modified":1712840662672},{"_id":"themes/wixo/source/fonts/fontawesome-webfont.ttf","hash":"6225ccc4ec94d060f19efab97ca42d842845b949","modified":1712840662673},{"_id":"themes/wixo/source/js/jquery-2.0.3.min.js","hash":"28daf1b2a995cc4de81154a9a9ebdbb98f7c9997","modified":1712840662676},{"_id":"themes/wixo/source/fonts/fontawesome-webfont.svg","hash":"cd980eab6db5fa57db670cb2e4278e67e1a4d6c9","modified":1712840662673},{"_id":"public/search.xml","hash":"2cf65ad690da8c9dde6bfe0ab03ccea722e207cb","modified":1712842705167},{"_id":"public/2015/08/23/mongodb-api/index.html","hash":"7f11dc3d5d2a78634554ebbd0922fd26054c3906","modified":1712842705167},{"_id":"public/2015/08/22/nosql-mongodb/index.html","hash":"6999f3810b9cae7d7a486d18ff503850fe7c96e2","modified":1712842705167},{"_id":"public/2015/07/26/redis-command/index.html","hash":"36153adc1eb28eb3cb28c5e3a0e4b94785254b75","modified":1712842705167},{"_id":"public/2015/07/25/redis-set/index.html","hash":"2788b9a87d3fc049f1f842c2505fb7fce1e46681","modified":1712842705167},{"_id":"public/2015/07/24/redis-list/index.html","hash":"0edf9be32ba4284c25e0c29b686a4d2c03b2ef26","modified":1712842705167},{"_id":"public/2014/06/12/ios-mdm/index.html","hash":"a93bd7e6a004a943e7c110e9e2a5dedacd0cd1b1","modified":1712842705167},{"_id":"public/2014/05/28/ssl-ca/index.html","hash":"0484eceff52f31a25fefbc82f5bc4efaa03a7912","modified":1712842705167},{"_id":"public/categories/技术/index.html","hash":"f85b6a4bcd86d9ba74a22bd008875bda0735ee95","modified":1712842705167},{"_id":"public/archives/index.html","hash":"8c95d4f33f7633e70544255a553dc2e9b791f53b","modified":1712842705167},{"_id":"public/archives/2014/index.html","hash":"4bdb22f4a8bff3d672703cd5714e24fa87a52e7d","modified":1712842705167},{"_id":"public/archives/2014/05/index.html","hash":"4bdb22f4a8bff3d672703cd5714e24fa87a52e7d","modified":1712842705167},{"_id":"public/archives/2014/06/index.html","hash":"4bdb22f4a8bff3d672703cd5714e24fa87a52e7d","modified":1712842705167},{"_id":"public/archives/2015/index.html","hash":"4bdb22f4a8bff3d672703cd5714e24fa87a52e7d","modified":1712842705167},{"_id":"public/archives/2015/07/index.html","hash":"4bdb22f4a8bff3d672703cd5714e24fa87a52e7d","modified":1712842705167},{"_id":"public/archives/2015/08/index.html","hash":"4bdb22f4a8bff3d672703cd5714e24fa87a52e7d","modified":1712842705167},{"_id":"public/archives/2015/09/index.html","hash":"4bdb22f4a8bff3d672703cd5714e24fa87a52e7d","modified":1712842705167},{"_id":"public/archives/2016/index.html","hash":"4bdb22f4a8bff3d672703cd5714e24fa87a52e7d","modified":1712842705167},{"_id":"public/archives/2016/01/index.html","hash":"4bdb22f4a8bff3d672703cd5714e24fa87a52e7d","modified":1712842705167},{"_id":"public/index.html","hash":"cb2b2b4ab082a9e26f946a606c850434409e929e","modified":1712842705167},{"_id":"public/tags/nosql/index.html","hash":"ac95a748a1a36db80b6e43cf3c1ad1dec70e4794","modified":1712842705167},{"_id":"public/tags/mongodb/index.html","hash":"9a91fbf4e74384b4a08c486bbd2844aec0a697b9","modified":1712842705167},{"_id":"public/2016/01/09/team-building/index.html","hash":"e46cddc17a2ebe5ef556984d90c1ea8969945224","modified":1712842705167},{"_id":"public/2015/09/27/java-go/index.html","hash":"1dc6c602b45075830b5df71989477c5e5230d21a","modified":1712842705167},{"_id":"public/2015/09/26/scrum/index.html","hash":"1c25ab0e05df4316178267ae6ff346b0bf1cf676","modified":1712842705167},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1712842705167},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1712842705167},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1712842705167},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1712842705167},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1712842705167},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c","modified":1712842705167},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"0183979056f0b87616cd99d5c54a48f3b771eee6","modified":1712842705167},{"_id":"public/img/github-sprite.png","hash":"4d7ee33beaaebf002ba57a172d159e46194ae481","modified":1712842705167},{"_id":"public/img/glyphicons-halflings-white.png","hash":"a25c4705320fd63c33790e666872910e702b9bf6","modified":1712842705167},{"_id":"public/img/glyphicons-halflings.png","hash":"84f613631b07d4fe22acbab50e551c0fe04bd78b","modified":1712842705167},{"_id":"public/fonts/google-fonts/2UX7WLTfW3W8TclTUvlFyQ.woff","hash":"87deb174af2e2beebb9f09d618a5159ca299a3d0","modified":1712842705167},{"_id":"public/fonts/google-fonts/0XxGQsSc1g4rdRdjJKZrNBsxEYwM7FgeyaSgU71cLG0.woff","hash":"33225e85c33279e7b4f0c5c65ff93bec740dd59c","modified":1712842705167},{"_id":"public/fonts/google-fonts/LKf8nhXsWg5ybwEGXk8UBQ.woff","hash":"f401d51152681048c06187c5d3919b1407b899c5","modified":1712842705167},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1712842705167},{"_id":"public/fonts/google-fonts/PIPMHY90P7jtyjpXuZ2cLD8E0i7KZn-EPnyo3HZu7kw.woff","hash":"18dc51e642b4df958098d3bbc6d3ba0237ef6150","modified":1712842705167},{"_id":"public/fonts/google-fonts/0AKsP294HTD-nvJgucYTaIbN6UDyHWBl620a-IRfuBk.woff","hash":"1d9bb14c006d39d7eb0812a85567c7431f899b8d","modified":1712842705167},{"_id":"public/fonts/google-fonts/UyYrYy3ltEffJV9QueSi4RdbPw3QSf9R-kE0EsQUn2A.woff","hash":"d9f913d09bb3c25749daf8e7ab829c850a842929","modified":1712842705167},{"_id":"public/fonts/google-fonts/cj2hUnSRBhwmSPr9kS5899kZXW4sYc4BjuAIFc1SXII.woff","hash":"17a484b92c0dacc8e8b4f0d38ccc1db400819d1d","modified":1712842705167},{"_id":"public/fonts/google-fonts/lILlYDvubYemzYzN7GbLkHhCUOGz7vYGh680lGh-uXM.woff","hash":"e6c9f1e5a6a966a8f7250201356f351890a48921","modified":1712842705167},{"_id":"public/fonts/FontAwesome.otf","hash":"6270a4a561a69fef5f5cc18cdf9efc256ec2ccbe","modified":1712842705167},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"6225ccc4ec94d060f19efab97ca42d842845b949","modified":1712842705167},{"_id":"public/css/google-fonts.css","hash":"91e629d0a0a531e920252788ed8863c26608c2b2","modified":1712842705167},{"_id":"public/css/responsive.css","hash":"ad1681cc7b3df942711d417af824e3581dc12c07","modified":1712842705167},{"_id":"public/css/sidenav.css","hash":"04b458c0ba1990d1ee51152f86c4fbefc8f60241","modified":1712842705167},{"_id":"public/css/style.css","hash":"7c555ca04d11351802c7b7ad249f31159b25f417","modified":1712842705167},{"_id":"public/css/highlight.css","hash":"d08d05bbb29246eb5e4a29d6586f89a055b97243","modified":1712842705167},{"_id":"public/js/gallery.js","hash":"d19f1b1cc5b75e21ca1d643b6dae9490ead28b55","modified":1712842705167},{"_id":"public/fancybox/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1712842705167},{"_id":"public/js/jquery.imagesloaded.min.js","hash":"3eb6381d2ed4b706020e4be5aff024aab4bcabc5","modified":1712842705167},{"_id":"public/js/main.js","hash":"51bc51e107dbd835022a36bbd60e5428e21f6894","modified":1712842705167},{"_id":"public/js/jquery.tableofcontents.min.js","hash":"38a3cbc147d4d639596cdda07d88f4e052ef31b0","modified":1712842705167},{"_id":"public/js/search.js","hash":"901b18b539a0cc6c2b90f93e79faf43e590fe3fd","modified":1712842705167},{"_id":"public/js/tocgenerator.min.js","hash":"64f09930154a2c9e0f8fde0c472c222eed86a54d","modified":1712842705167},{"_id":"public/css/bootstrap.min.css","hash":"b982b68f818bba6fc9fead73d25d96a48972311e","modified":1712842705167},{"_id":"public/css/bootstrap-responsive.css","hash":"a5f7de688cddfcec69ec3c573868a4870c1cea0a","modified":1712842705167},{"_id":"public/css/font-awesome.css","hash":"6df51eee1e75e450cb9cd71e925e6aa9ac2d6a9d","modified":1712842705167},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1712842705167},{"_id":"public/js/bootstrap.min.js","hash":"5814e91bb6276f4de8b7951c965f2f190a03978d","modified":1712842705167},{"_id":"public/js/jquery-2.0.3.min.js","hash":"28daf1b2a995cc4de81154a9a9ebdbb98f7c9997","modified":1712842705167},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"cd980eab6db5fa57db670cb2e4278e67e1a4d6c9","modified":1712842705167},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1712843175475}],"Category":[{"name":"技术","_id":"cluvablv00002cbih0w700ivl"}],"Data":[],"Page":[],"Post":[{"title":"ios-mdm介绍与实现","date":"2014-06-12T14:52:03.000Z","_content":"\n---\n>最近一直在研究mdm系统，首先从ios下手，自己也写了一个demo，目前把学习和实践过程中总结的东西记录下。\n\nMDM介绍\n---\nMDM的全称是Mobile Device Management，顾名思义是移动设备管理，帮助企业将IT管理能力从传统的PC延伸到移动设备甚至移动应用APP。\n\n<!--more-->\n\nMDM能够做些什么？\n---\n* 配置\n\n    账户配置（wifi、vpn、email等）\n    \n    密码策略（密码复杂度等配置）\n    \n    安全与隐私（是否允许发送诊断数据到Apple等）\n    \n    设备功能限制（是否允许摄像头，是否允许siri）\n    \n    应用限制（是否允许用iTunesstore，Safari等）\n    \n    云（是否允许云备份、照片流等）\n    \n    内容分级\n\n* 信息查询\n\n    基本信息（UDID、设备名、imei等）\n    \n    网络信息（iccid、蓝牙和wifi的mac、手机号等）\n    \n    合规性和安全性(安装的profile、是否有密码保护等）\n    \n    应用（已安装应用id、已安装应用名称等）\n    \n* 管理\n\n    管理配置（安装和删除一个profile）\n    \n    管理Apps（安装和删除一个in-houseApp）\n    \n    擦除设备、清除密码、锁屏\n\n如何实现MDM服务？\n---\n![mdm](http://i11.tietuku.com/b2b78b6218ecfa76.png)\n\n根据iOS mdm 架构图，我们知道我们要做些工作:\n\n1. 搭建一个MDM Server与设备之间通过HTTPS连接下发mdm指令到设备。\n2. 配置MDM Push证书来向设备发送mdm 推送消息通知。\n\n搭建一个MDM Server\n---\n1. 配置tomcat https支持（配置证书）\n2. 处理checkin及server请求\n3. 根据mdm协议实现所有mdm命令\n4. 配置消息推送Java-apns[(https://github.com/notnoop/java-apns)](https://github.com/notnoop/java-apns)\n\n我自己写了一个Server。[github链接](https://github.com/zuoyy/IOS-MDM-Server)\n\n配置MDM Push证书\n---\n![mdm](http://i11.tietuku.com/3c8183ed7fa0ddae.png)\n\n","source":"_posts/ios-mdm.md","raw":"title: ios-mdm介绍与实现\ndate: 2014-06-12 22:52:03\ncategories: 技术\n---\n\n---\n>最近一直在研究mdm系统，首先从ios下手，自己也写了一个demo，目前把学习和实践过程中总结的东西记录下。\n\nMDM介绍\n---\nMDM的全称是Mobile Device Management，顾名思义是移动设备管理，帮助企业将IT管理能力从传统的PC延伸到移动设备甚至移动应用APP。\n\n<!--more-->\n\nMDM能够做些什么？\n---\n* 配置\n\n    账户配置（wifi、vpn、email等）\n    \n    密码策略（密码复杂度等配置）\n    \n    安全与隐私（是否允许发送诊断数据到Apple等）\n    \n    设备功能限制（是否允许摄像头，是否允许siri）\n    \n    应用限制（是否允许用iTunesstore，Safari等）\n    \n    云（是否允许云备份、照片流等）\n    \n    内容分级\n\n* 信息查询\n\n    基本信息（UDID、设备名、imei等）\n    \n    网络信息（iccid、蓝牙和wifi的mac、手机号等）\n    \n    合规性和安全性(安装的profile、是否有密码保护等）\n    \n    应用（已安装应用id、已安装应用名称等）\n    \n* 管理\n\n    管理配置（安装和删除一个profile）\n    \n    管理Apps（安装和删除一个in-houseApp）\n    \n    擦除设备、清除密码、锁屏\n\n如何实现MDM服务？\n---\n![mdm](http://i11.tietuku.com/b2b78b6218ecfa76.png)\n\n根据iOS mdm 架构图，我们知道我们要做些工作:\n\n1. 搭建一个MDM Server与设备之间通过HTTPS连接下发mdm指令到设备。\n2. 配置MDM Push证书来向设备发送mdm 推送消息通知。\n\n搭建一个MDM Server\n---\n1. 配置tomcat https支持（配置证书）\n2. 处理checkin及server请求\n3. 根据mdm协议实现所有mdm命令\n4. 配置消息推送Java-apns[(https://github.com/notnoop/java-apns)](https://github.com/notnoop/java-apns)\n\n我自己写了一个Server。[github链接](https://github.com/zuoyy/IOS-MDM-Server)\n\n配置MDM Push证书\n---\n![mdm](http://i11.tietuku.com/3c8183ed7fa0ddae.png)\n\n","slug":"ios-mdm","published":1,"updated":"2024-04-11T13:25:35.649Z","comments":1,"layout":"post","photos":[],"_id":"cluvabluw0000cbih5t6o8sfb","content":"<hr>\n<blockquote>\n<p>最近一直在研究mdm系统，首先从ios下手，自己也写了一个demo，目前把学习和实践过程中总结的东西记录下。</p>\n</blockquote>\n<h2 id=\"MDM介绍\"><a href=\"#MDM介绍\" class=\"headerlink\" title=\"MDM介绍\"></a>MDM介绍</h2><p>MDM的全称是Mobile Device Management，顾名思义是移动设备管理，帮助企业将IT管理能力从传统的PC延伸到移动设备甚至移动应用APP。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"MDM能够做些什么？\"><a href=\"#MDM能够做些什么？\" class=\"headerlink\" title=\"MDM能够做些什么？\"></a>MDM能够做些什么？</h2><ul>\n<li><p>配置</p>\n<p>  账户配置（wifi、vpn、email等）</p>\n<p>  密码策略（密码复杂度等配置）</p>\n<p>  安全与隐私（是否允许发送诊断数据到Apple等）</p>\n<p>  设备功能限制（是否允许摄像头，是否允许siri）</p>\n<p>  应用限制（是否允许用iTunesstore，Safari等）</p>\n<p>  云（是否允许云备份、照片流等）</p>\n<p>  内容分级</p>\n</li>\n<li><p>信息查询</p>\n<p>  基本信息（UDID、设备名、imei等）</p>\n<p>  网络信息（iccid、蓝牙和wifi的mac、手机号等）</p>\n<p>  合规性和安全性(安装的profile、是否有密码保护等）</p>\n<p>  应用（已安装应用id、已安装应用名称等）</p>\n</li>\n<li><p>管理</p>\n<p>  管理配置（安装和删除一个profile）</p>\n<p>  管理Apps（安装和删除一个in-houseApp）</p>\n<p>  擦除设备、清除密码、锁屏</p>\n</li>\n</ul>\n<h2 id=\"如何实现MDM服务？\"><a href=\"#如何实现MDM服务？\" class=\"headerlink\" title=\"如何实现MDM服务？\"></a>如何实现MDM服务？</h2><p><img src=\"http://i11.tietuku.com/b2b78b6218ecfa76.png\" alt=\"mdm\"></p>\n<p>根据iOS mdm 架构图，我们知道我们要做些工作:</p>\n<ol>\n<li>搭建一个MDM Server与设备之间通过HTTPS连接下发mdm指令到设备。</li>\n<li>配置MDM Push证书来向设备发送mdm 推送消息通知。</li>\n</ol>\n<h2 id=\"搭建一个MDM-Server\"><a href=\"#搭建一个MDM-Server\" class=\"headerlink\" title=\"搭建一个MDM Server\"></a>搭建一个MDM Server</h2><ol>\n<li>配置tomcat https支持（配置证书）</li>\n<li>处理checkin及server请求</li>\n<li>根据mdm协议实现所有mdm命令</li>\n<li>配置消息推送Java-apns<a href=\"https://github.com/notnoop/java-apns\">(https://github.com/notnoop/java-apns)</a></li>\n</ol>\n<p>我自己写了一个Server。<a href=\"https://github.com/zuoyy/IOS-MDM-Server\">github链接</a></p>\n<h2 id=\"配置MDM-Push证书\"><a href=\"#配置MDM-Push证书\" class=\"headerlink\" title=\"配置MDM Push证书\"></a>配置MDM Push证书</h2><p><img src=\"http://i11.tietuku.com/3c8183ed7fa0ddae.png\" alt=\"mdm\"></p>\n","excerpt":"<hr>\n<blockquote>\n<p>最近一直在研究mdm系统，首先从ios下手，自己也写了一个demo，目前把学习和实践过程中总结的东西记录下。</p>\n</blockquote>\n<h2 id=\"MDM介绍\"><a href=\"#MDM介绍\" class=\"headerlink\" title=\"MDM介绍\"></a>MDM介绍</h2><p>MDM的全称是Mobile Device Management，顾名思义是移动设备管理，帮助企业将IT管理能力从传统的PC延伸到移动设备甚至移动应用APP。</p>","more":"<h2 id=\"MDM能够做些什么？\"><a href=\"#MDM能够做些什么？\" class=\"headerlink\" title=\"MDM能够做些什么？\"></a>MDM能够做些什么？</h2><ul>\n<li><p>配置</p>\n<p>  账户配置（wifi、vpn、email等）</p>\n<p>  密码策略（密码复杂度等配置）</p>\n<p>  安全与隐私（是否允许发送诊断数据到Apple等）</p>\n<p>  设备功能限制（是否允许摄像头，是否允许siri）</p>\n<p>  应用限制（是否允许用iTunesstore，Safari等）</p>\n<p>  云（是否允许云备份、照片流等）</p>\n<p>  内容分级</p>\n</li>\n<li><p>信息查询</p>\n<p>  基本信息（UDID、设备名、imei等）</p>\n<p>  网络信息（iccid、蓝牙和wifi的mac、手机号等）</p>\n<p>  合规性和安全性(安装的profile、是否有密码保护等）</p>\n<p>  应用（已安装应用id、已安装应用名称等）</p>\n</li>\n<li><p>管理</p>\n<p>  管理配置（安装和删除一个profile）</p>\n<p>  管理Apps（安装和删除一个in-houseApp）</p>\n<p>  擦除设备、清除密码、锁屏</p>\n</li>\n</ul>\n<h2 id=\"如何实现MDM服务？\"><a href=\"#如何实现MDM服务？\" class=\"headerlink\" title=\"如何实现MDM服务？\"></a>如何实现MDM服务？</h2><p><img src=\"http://i11.tietuku.com/b2b78b6218ecfa76.png\" alt=\"mdm\"></p>\n<p>根据iOS mdm 架构图，我们知道我们要做些工作:</p>\n<ol>\n<li>搭建一个MDM Server与设备之间通过HTTPS连接下发mdm指令到设备。</li>\n<li>配置MDM Push证书来向设备发送mdm 推送消息通知。</li>\n</ol>\n<h2 id=\"搭建一个MDM-Server\"><a href=\"#搭建一个MDM-Server\" class=\"headerlink\" title=\"搭建一个MDM Server\"></a>搭建一个MDM Server</h2><ol>\n<li>配置tomcat https支持（配置证书）</li>\n<li>处理checkin及server请求</li>\n<li>根据mdm协议实现所有mdm命令</li>\n<li>配置消息推送Java-apns<a href=\"https://github.com/notnoop/java-apns\">(https://github.com/notnoop/java-apns)</a></li>\n</ol>\n<p>我自己写了一个Server。<a href=\"https://github.com/zuoyy/IOS-MDM-Server\">github链接</a></p>\n<h2 id=\"配置MDM-Push证书\"><a href=\"#配置MDM-Push证书\" class=\"headerlink\" title=\"配置MDM Push证书\"></a>配置MDM Push证书</h2><p><img src=\"http://i11.tietuku.com/3c8183ed7fa0ddae.png\" alt=\"mdm\"></p>"},{"title":"NoSQL数据库-MongoDB","date":"2015-08-22T09:16:30.000Z","_content":"\n>NoSQL简述\n\n&#160; &#160; &#160; &#160;CAP（Consistency，Availabiity，Partitiontolerance)理论告诉我们，一个分布式系统不可能满足一致性，可用性和分区容错性这三个需求，最多只能同时满足两个。关系型数据库通过把更新操作写到事务型日志里实现了部分耐用性，但带来的是写性能的下降。MongoDB等NoSQL数据库背后蕴涵的哲学是不同的平台应该使用不同类型的数据库，MongoDB通过降低一些特性来达到性能的提高，这在很多大型站点中是可行的。因为MongoDB是非原子性的，所以如果如果应用需要事务，还是需要选择MySQL等关系数据库。\n\n<!--more-->\n\n&#160; &#160; &#160; &#160;NoSQL数据库，顾名思义就是打破了传统关系型数据库的范式约束。很多NoSQL数据库从数据存储的角度看也不是关系型数据库，而是key-value数据格式的hash数据库。由于放弃了关系数据库强大的SQL查询语言和事务一致性以及范式约束，NoSQL数据库在很大程度上解决了传统关系型数据库面临的诸多挑战。\n\n&#160; &#160; &#160; &#160;在社区中，NoSQL是指“notonly sql”，其特点是非关系型，分布式，开源，可水平扩展，模式自由，支持replication，简单的API，最终一致性（相对于即时一致性，最终一致性允许有一个“不一致性窗口”，但能保证最终的客户都能看到最新的值）。\n\n\n>MongoDB简介\n\n\n&#160; &#160; &#160; &#160;mongo取自“humongous”（海量的），是开源的文档数据库──nosql数据库的一种。\n\n&#160; &#160; &#160; &#160;MongoDB是一种面向集合（collection）的，模式自由的文档（document）数据库。\n\n&#160; &#160; &#160; &#160;面向集合是说数据被分成集合的形式，每个集合在数据库中有惟一的名称，集合可以包含不限数目的文档。除了模式不是预先定义好的，集合与RDBMS中的表概念类似，虽然二者并不是完全对等。数据库和集合的创建是“lazy”的，即只有在第一个document被插入时集合和数据库才真正创建——这时在磁盘的文件系统里才能看见。\n\n&#160; &#160; &#160; &#160;模式自由是说数据库不需要知道存放在集合中的文档的结构，完全可以在同一个集合中存放不同结构的文档，支持嵌入子文档。\n\n&#160; &#160; &#160; &#160;文档类似于RDBMS中的记录，以BSON的格式保存。BSON是BinaryJSON的简称，是对JSON-like文档的二进制编码序列化。像JSON（JavaScriptObject Notation）一样，BSON支持在对象和数组内嵌入其它的对象和数组。有些数据类型在JSON里不能表示，但可以在BSON里表示，如Date类型和BinData（二进制数据），Python原生的类型都可以表示。与ProtocalBuffers（Google开发的用以处理对索引服务器请求/应答的协议）相比，BSON模式更自由，所以更灵活，但这样也使得每个文档都要保存字段名，所以空间压缩上不如ProtocolBuffers。\n\n&#160; &#160; &#160; &#160;BSON第一眼看上去像BLOB，但MongoDB理解BSON的内部机制，所以MongoDB可以深入BSON对象的内部，即使是嵌套的对象，这样MongoDB就可以在顶层和嵌套的BSON对象上建立索引来应对各种查询了。\n\n&#160; &#160; &#160; &#160;MongoDB可运行在Linux、Windows和OSX平台，支持32位和64位应用，默认端口为27017。推荐运行在64位平台，因为MongoDB为了提高性能使用了内存映射文件进行数据管理，而在32位模式运行时支持的最大文件为2GB。\n\n&#160; &#160; &#160; &#160;MongoDB查询速度比MySQL要快，因为它cache了尽可能多的数据到RAM中，即使是non-cached数据也非常快。当前MongoDB官方支持的客户端API语言就多达8种（C|C++|Java|Javascript|Perl|PHP|Python|Ruby），社区开发的客户端API还有Erlang、Go、Haskell......\n","source":"_posts/nosql-mongodb.md","raw":"title: NoSQL数据库-MongoDB\ndate: 2015-08-22 17:16:30\ncategories: 技术\ntags: [nosql,mongodb]\n---\n\n>NoSQL简述\n\n&#160; &#160; &#160; &#160;CAP（Consistency，Availabiity，Partitiontolerance)理论告诉我们，一个分布式系统不可能满足一致性，可用性和分区容错性这三个需求，最多只能同时满足两个。关系型数据库通过把更新操作写到事务型日志里实现了部分耐用性，但带来的是写性能的下降。MongoDB等NoSQL数据库背后蕴涵的哲学是不同的平台应该使用不同类型的数据库，MongoDB通过降低一些特性来达到性能的提高，这在很多大型站点中是可行的。因为MongoDB是非原子性的，所以如果如果应用需要事务，还是需要选择MySQL等关系数据库。\n\n<!--more-->\n\n&#160; &#160; &#160; &#160;NoSQL数据库，顾名思义就是打破了传统关系型数据库的范式约束。很多NoSQL数据库从数据存储的角度看也不是关系型数据库，而是key-value数据格式的hash数据库。由于放弃了关系数据库强大的SQL查询语言和事务一致性以及范式约束，NoSQL数据库在很大程度上解决了传统关系型数据库面临的诸多挑战。\n\n&#160; &#160; &#160; &#160;在社区中，NoSQL是指“notonly sql”，其特点是非关系型，分布式，开源，可水平扩展，模式自由，支持replication，简单的API，最终一致性（相对于即时一致性，最终一致性允许有一个“不一致性窗口”，但能保证最终的客户都能看到最新的值）。\n\n\n>MongoDB简介\n\n\n&#160; &#160; &#160; &#160;mongo取自“humongous”（海量的），是开源的文档数据库──nosql数据库的一种。\n\n&#160; &#160; &#160; &#160;MongoDB是一种面向集合（collection）的，模式自由的文档（document）数据库。\n\n&#160; &#160; &#160; &#160;面向集合是说数据被分成集合的形式，每个集合在数据库中有惟一的名称，集合可以包含不限数目的文档。除了模式不是预先定义好的，集合与RDBMS中的表概念类似，虽然二者并不是完全对等。数据库和集合的创建是“lazy”的，即只有在第一个document被插入时集合和数据库才真正创建——这时在磁盘的文件系统里才能看见。\n\n&#160; &#160; &#160; &#160;模式自由是说数据库不需要知道存放在集合中的文档的结构，完全可以在同一个集合中存放不同结构的文档，支持嵌入子文档。\n\n&#160; &#160; &#160; &#160;文档类似于RDBMS中的记录，以BSON的格式保存。BSON是BinaryJSON的简称，是对JSON-like文档的二进制编码序列化。像JSON（JavaScriptObject Notation）一样，BSON支持在对象和数组内嵌入其它的对象和数组。有些数据类型在JSON里不能表示，但可以在BSON里表示，如Date类型和BinData（二进制数据），Python原生的类型都可以表示。与ProtocalBuffers（Google开发的用以处理对索引服务器请求/应答的协议）相比，BSON模式更自由，所以更灵活，但这样也使得每个文档都要保存字段名，所以空间压缩上不如ProtocolBuffers。\n\n&#160; &#160; &#160; &#160;BSON第一眼看上去像BLOB，但MongoDB理解BSON的内部机制，所以MongoDB可以深入BSON对象的内部，即使是嵌套的对象，这样MongoDB就可以在顶层和嵌套的BSON对象上建立索引来应对各种查询了。\n\n&#160; &#160; &#160; &#160;MongoDB可运行在Linux、Windows和OSX平台，支持32位和64位应用，默认端口为27017。推荐运行在64位平台，因为MongoDB为了提高性能使用了内存映射文件进行数据管理，而在32位模式运行时支持的最大文件为2GB。\n\n&#160; &#160; &#160; &#160;MongoDB查询速度比MySQL要快，因为它cache了尽可能多的数据到RAM中，即使是non-cached数据也非常快。当前MongoDB官方支持的客户端API语言就多达8种（C|C++|Java|Javascript|Perl|PHP|Python|Ruby），社区开发的客户端API还有Erlang、Go、Haskell......\n","slug":"nosql-mongodb","published":1,"updated":"2017-09-05T02:03:34.000Z","comments":1,"layout":"post","photos":[],"_id":"cluvabluz0001cbih654u9fxq","content":"<blockquote>\n<p>NoSQL简述</p>\n</blockquote>\n<p>&#160; &#160; &#160; &#160;CAP（Consistency，Availabiity，Partitiontolerance)理论告诉我们，一个分布式系统不可能满足一致性，可用性和分区容错性这三个需求，最多只能同时满足两个。关系型数据库通过把更新操作写到事务型日志里实现了部分耐用性，但带来的是写性能的下降。MongoDB等NoSQL数据库背后蕴涵的哲学是不同的平台应该使用不同类型的数据库，MongoDB通过降低一些特性来达到性能的提高，这在很多大型站点中是可行的。因为MongoDB是非原子性的，所以如果如果应用需要事务，还是需要选择MySQL等关系数据库。</p>\n<span id=\"more\"></span>\n\n<p>&#160; &#160; &#160; &#160;NoSQL数据库，顾名思义就是打破了传统关系型数据库的范式约束。很多NoSQL数据库从数据存储的角度看也不是关系型数据库，而是key-value数据格式的hash数据库。由于放弃了关系数据库强大的SQL查询语言和事务一致性以及范式约束，NoSQL数据库在很大程度上解决了传统关系型数据库面临的诸多挑战。</p>\n<p>&#160; &#160; &#160; &#160;在社区中，NoSQL是指“notonly sql”，其特点是非关系型，分布式，开源，可水平扩展，模式自由，支持replication，简单的API，最终一致性（相对于即时一致性，最终一致性允许有一个“不一致性窗口”，但能保证最终的客户都能看到最新的值）。</p>\n<blockquote>\n<p>MongoDB简介</p>\n</blockquote>\n<p>&#160; &#160; &#160; &#160;mongo取自“humongous”（海量的），是开源的文档数据库──nosql数据库的一种。</p>\n<p>&#160; &#160; &#160; &#160;MongoDB是一种面向集合（collection）的，模式自由的文档（document）数据库。</p>\n<p>&#160; &#160; &#160; &#160;面向集合是说数据被分成集合的形式，每个集合在数据库中有惟一的名称，集合可以包含不限数目的文档。除了模式不是预先定义好的，集合与RDBMS中的表概念类似，虽然二者并不是完全对等。数据库和集合的创建是“lazy”的，即只有在第一个document被插入时集合和数据库才真正创建——这时在磁盘的文件系统里才能看见。</p>\n<p>&#160; &#160; &#160; &#160;模式自由是说数据库不需要知道存放在集合中的文档的结构，完全可以在同一个集合中存放不同结构的文档，支持嵌入子文档。</p>\n<p>&#160; &#160; &#160; &#160;文档类似于RDBMS中的记录，以BSON的格式保存。BSON是BinaryJSON的简称，是对JSON-like文档的二进制编码序列化。像JSON（JavaScriptObject Notation）一样，BSON支持在对象和数组内嵌入其它的对象和数组。有些数据类型在JSON里不能表示，但可以在BSON里表示，如Date类型和BinData（二进制数据），Python原生的类型都可以表示。与ProtocalBuffers（Google开发的用以处理对索引服务器请求&#x2F;应答的协议）相比，BSON模式更自由，所以更灵活，但这样也使得每个文档都要保存字段名，所以空间压缩上不如ProtocolBuffers。</p>\n<p>&#160; &#160; &#160; &#160;BSON第一眼看上去像BLOB，但MongoDB理解BSON的内部机制，所以MongoDB可以深入BSON对象的内部，即使是嵌套的对象，这样MongoDB就可以在顶层和嵌套的BSON对象上建立索引来应对各种查询了。</p>\n<p>&#160; &#160; &#160; &#160;MongoDB可运行在Linux、Windows和OSX平台，支持32位和64位应用，默认端口为27017。推荐运行在64位平台，因为MongoDB为了提高性能使用了内存映射文件进行数据管理，而在32位模式运行时支持的最大文件为2GB。</p>\n<p>&#160; &#160; &#160; &#160;MongoDB查询速度比MySQL要快，因为它cache了尽可能多的数据到RAM中，即使是non-cached数据也非常快。当前MongoDB官方支持的客户端API语言就多达8种（C|C++|Java|Javascript|Perl|PHP|Python|Ruby），社区开发的客户端API还有Erlang、Go、Haskell……</p>\n","excerpt":"<blockquote>\n<p>NoSQL简述</p>\n</blockquote>\n<p>&#160; &#160; &#160; &#160;CAP（Consistency，Availabiity，Partitiontolerance)理论告诉我们，一个分布式系统不可能满足一致性，可用性和分区容错性这三个需求，最多只能同时满足两个。关系型数据库通过把更新操作写到事务型日志里实现了部分耐用性，但带来的是写性能的下降。MongoDB等NoSQL数据库背后蕴涵的哲学是不同的平台应该使用不同类型的数据库，MongoDB通过降低一些特性来达到性能的提高，这在很多大型站点中是可行的。因为MongoDB是非原子性的，所以如果如果应用需要事务，还是需要选择MySQL等关系数据库。</p>","more":"<p>&#160; &#160; &#160; &#160;NoSQL数据库，顾名思义就是打破了传统关系型数据库的范式约束。很多NoSQL数据库从数据存储的角度看也不是关系型数据库，而是key-value数据格式的hash数据库。由于放弃了关系数据库强大的SQL查询语言和事务一致性以及范式约束，NoSQL数据库在很大程度上解决了传统关系型数据库面临的诸多挑战。</p>\n<p>&#160; &#160; &#160; &#160;在社区中，NoSQL是指“notonly sql”，其特点是非关系型，分布式，开源，可水平扩展，模式自由，支持replication，简单的API，最终一致性（相对于即时一致性，最终一致性允许有一个“不一致性窗口”，但能保证最终的客户都能看到最新的值）。</p>\n<blockquote>\n<p>MongoDB简介</p>\n</blockquote>\n<p>&#160; &#160; &#160; &#160;mongo取自“humongous”（海量的），是开源的文档数据库──nosql数据库的一种。</p>\n<p>&#160; &#160; &#160; &#160;MongoDB是一种面向集合（collection）的，模式自由的文档（document）数据库。</p>\n<p>&#160; &#160; &#160; &#160;面向集合是说数据被分成集合的形式，每个集合在数据库中有惟一的名称，集合可以包含不限数目的文档。除了模式不是预先定义好的，集合与RDBMS中的表概念类似，虽然二者并不是完全对等。数据库和集合的创建是“lazy”的，即只有在第一个document被插入时集合和数据库才真正创建——这时在磁盘的文件系统里才能看见。</p>\n<p>&#160; &#160; &#160; &#160;模式自由是说数据库不需要知道存放在集合中的文档的结构，完全可以在同一个集合中存放不同结构的文档，支持嵌入子文档。</p>\n<p>&#160; &#160; &#160; &#160;文档类似于RDBMS中的记录，以BSON的格式保存。BSON是BinaryJSON的简称，是对JSON-like文档的二进制编码序列化。像JSON（JavaScriptObject Notation）一样，BSON支持在对象和数组内嵌入其它的对象和数组。有些数据类型在JSON里不能表示，但可以在BSON里表示，如Date类型和BinData（二进制数据），Python原生的类型都可以表示。与ProtocalBuffers（Google开发的用以处理对索引服务器请求&#x2F;应答的协议）相比，BSON模式更自由，所以更灵活，但这样也使得每个文档都要保存字段名，所以空间压缩上不如ProtocolBuffers。</p>\n<p>&#160; &#160; &#160; &#160;BSON第一眼看上去像BLOB，但MongoDB理解BSON的内部机制，所以MongoDB可以深入BSON对象的内部，即使是嵌套的对象，这样MongoDB就可以在顶层和嵌套的BSON对象上建立索引来应对各种查询了。</p>\n<p>&#160; &#160; &#160; &#160;MongoDB可运行在Linux、Windows和OSX平台，支持32位和64位应用，默认端口为27017。推荐运行在64位平台，因为MongoDB为了提高性能使用了内存映射文件进行数据管理，而在32位模式运行时支持的最大文件为2GB。</p>\n<p>&#160; &#160; &#160; &#160;MongoDB查询速度比MySQL要快，因为它cache了尽可能多的数据到RAM中，即使是non-cached数据也非常快。当前MongoDB官方支持的客户端API语言就多达8种（C|C++|Java|Javascript|Perl|PHP|Python|Ruby），社区开发的客户端API还有Erlang、Go、Haskell……</p>"},{"title":"作为一名Java程序员，我为什么不在生产项目中转向Go","date":"2015-09-27T14:38:21.000Z","_content":"\n>原文地址：[http://www.infoq.com/cn/articles/why-not-go](http://www.infoq.com/cn/articles/why-not-go)\n\n自Google在2009年发布Go语言的第一个正式版之后，这门语言就以出色的语言特性受到大家的追捧，尤其是在需要高并发的场景下，大家都会想到是不是该用Go。随后，在国内涌现出了一批以七牛为代表的使用Go作为主要语言的团队，而许式伟大神本人也在各种场合下极力推动Go在国内的发展，于是在这种大环境下，中国的Go开发者群体逐渐超越了其他地区。\n\n那么问题来了，业余时间好学是一回事，真正要将一个新东西运用到生产中则是另一回事。JavaScript的开发者可以义无反顾地选择Node.js，但是对于Java开发者来说，在下一个大项目里究竟是该选择Go，还是Java呢？\n\n<!--more-->\n\n>郑重声明：本文并不是来探讨Go或者Java谁是更好的语言，每种语言都有自己的设计哲学和适用场景，今天主要是在探讨实际工程中的选择和权衡的问题，所以请不要上纲上线。\n\n**语言本身**\n\n首先，需要说明一下，作为一个技术决策者，在进行技术选型时并不能单方面地根据语言本身的特点直接下结论。实际情况下，大多数人会使用一系列的框架、库及工具，简而言之就是会考虑很多周边生态环境的因素，同时还要结合公司的特点、各种历史问题和实际客观因素等等一系列的考虑点综合下来才能完成决策。所以，接下来我们先从语言开始，一步一步来分析下在你的项目中选择Go是否合适。\n\nGo在高并发编程方面无疑是出众的，通过goroutine从语言层面支持了协程，这是Java等语言所无法比拟的，这也是大多数人在面对高并发场景选择Go的重要原因之一。虽然Java有Kilim之类的框架，但没有语言层的支持始终稍逊一筹。\n\n除此之外，Go的其他语法也很有趣，比如多返回值，在一定程度上为开发者带来了一定的便利性。试想，为了返回两到三个值，不得不封装一个对象，或者抹去业务名称使用Map、List等集合类，高级一点用Apache的Pair和Triple，虽然可行，但始终不如Go的实现来得优雅。在此之上，Go也统一了异常的返回方式，不用再去纠结是通过抛异常还是错误码来判断是否成功，多返回值的最后一个是Error就行了。\n\nGo在语言的原生类型中支持了常用的一些结构，比如map和slice，而其他语言中它们更多是存在于库中，这也体现了这门语言是从实践角度出发的特点，既然人人都需要，为什么不在语言层面支持它呢。函数作为一等公民出现在了Go语言里，不过Java在最近的Java 8中也有了Lambda表达式，也算是有进步了。\n\n其他的一些特性，则属于锦上添花型的，比如不定参数，早在2004年的Java 1.5中就对varargs有支持了；多重赋值在Ruby中也有出现，但除了多返回值赋值，以及让你在变量交换值时少写一个中间变量，让代码更美观一些之外，其他的作用着实不是怎么明显。\n\n说了这么多Go的优点，当然它也有一些问题，比如GC，说到它，Java不得不露出洁白的牙齿，虽然在大堆GC上G1还有些不尽如人意，但Java的GC已经发展了很多年，各种策略也比较成熟，CMS或G1足以应付大多数场景，实在有要求还能用Azul Zing JVM。不过从最新的Go 1.5的消息来看，Go的GC实现有了很大地提升，顺便一提的是GOMAXPROCS默认也从1变成了CPU核数，看来官方对Go在多核的利用方面更有信心了。\n\n许世伟在《Go 语言编程》的前言中预言未来10年，Go会取代Java，位居编程榜之首，当时是2012年，为了看看2009年TIOBE年度编程语言如今的排名，笔者在撰写本文时特意去TIOBE看了下，最近的2015年8月排行榜，Java以19.274%位居榜首，Go已经跌出了前50，这不禁让人有些意外。\n\n但总体上来说，笔者认为**Go在语言层面的表现还是相当出色的**，解决了一些编程中的痛点，学习曲线也能够接受，特别是对于那些有C/C++背景的人，会感觉十分亲切。\n\n**工程问题**\n\n一个人写代码时可以很随性，想怎么写就怎么写，但当一个人变成一个团队后，这种随性或者说随便就会带来很多问题，于是就诞生了编码规范这玩意儿，大厂基本都有自己的编码规范，比如Google就有[针对不下十种编程语言的规范](https://github.com/google/styleguide)。团队内约定一套编码规范能够很大程度上地确保代码的风格，降低阅读沟通的成本。Go内置了一套编码规范，违反了该规范代码就无法编译通过，可以说只要你是写Go的，那你的代码就不会太难看，当然Go也没有把所有东西就强制死，还有一些推荐的规范可以通过gofmt进行格式化，但这步不是必须的。\n\n虽然Go自己解决了这个问题，但并不能说Java在这方面是空白，Java发展至今周边工具无数，并不缺成熟的代码静态分析工具，比如CheckStyle、PMD和FindBugs，它们不仅能扫描编码规范的问题，甚至还能扫描代码中潜在的问题并给出解决方案，并且使用方便，在Java开发者社区中有很高地接受度，应该说大多数靠谱地开发者都会使用这些工具。除此之外，一些大厂也有自己的强制手段，比如百度内部也有很多语言的编码规范，而且大部分情况下如果没有通过编码规范的扫描，你是无法提交代码的；还有一些公司会在持续集成过程中加入代码扫描，有FindBugs高优先级的问题时必须修复才能进入下一个阶段。所以说Go在这个问题上的优势并不明显，或者说在一个成熟的环境下，这只是合格而已。\n\n**这里需要强调笔者的一个观点：**\n\n>Go在语言本身和发行包中融入了很多最佳实践，正是这些前人的经验才让它看起来如此优秀。拿这么个海陆空混编特种部队去和Java、C、Ruby这些语言本身做对比，显得不太公平，所以本文在考虑问题时都会结合语言及其生态圈中的成员，毕竟这才更接近真实的情况。\n\nGo本身对项目结构有一套约定，代码放哪里，测试文件如何命名，编译打包后的结果输出到哪个目录，甚至还有go cover这种统计测试覆盖率的命令行，开发者不用在这些问题上太过纠结，再一次体现了Go注重工程实践的特点。回过头来，Java方面，Maven、Gradle都是注重于工程生命周期管理的工具，而且Maven更是历史悠久，被广泛用于各种项目之中。以Maven为例，不仅能够实现上述所有功能，还有很强的插件扩展能力，这里需要的只是一次性维护好pom.xml文件就行了，由于Maven的使用群很大，网上有大量的范例，甚至还有很多生成工程的工具和模板，所以使用成本并不高。\n\n这里还要衍生出一个话题，就是依赖管理，在开发代码时，势必需要依赖很多外部的东西，Go可以直接import远程的内容，这个特性很有创意，但并不能很好地解决版本的问题，在Maven或Gradle里，我们可以直接指定各个依赖项甚至是插件的版本，工具会自动从仓库中下载它们。如果需要同时在同一个系统的不同模块里依赖同一个库的不同版本，我们还能够通过OSGi这种略显复杂的手段来实现，在模块化方面，Jagsaw虽然被一延再延，但估计有望纳入Java 9，这个特性也会解决不少问题。而根据Golang实践群中大家的讨论，似乎godep、gb和gvt都不尽如人意，在这点上看来Go还有一段路要走。\n\n综上所述，Go在工程方面的确有不少亮点，吸纳了很多最佳实践，甚至可以说用Go之后更容易写出规范的代码，有好的项目结构，但**与生态圈完备的Java相比，Go并不占优势**，因为最终代码的质量还是由人决定的，双方都不缺好的工具，所以这方面的特点并不能影响技术选型的决策。\n\n**开发实践**\n\n>Talk is cheap. Show me the code.\n\n下面进入编码环节，先从Go引以为傲的并发开始，《Go语言编程》的前言中有这样一段代码：\n\n    func run(arg string) {\n        // ...\n    }\n    func main() {\n        go run(\"test\")\n        ...\n    }\n\n书中与之对比的Java代码有12行，而且还是线程，不是协程，对比很明显，但那是在2012年的时候，时至今日，Java已经发展到了Java 8，3年了，看看如今的Java代码会是什么样的：\n\n    public class ThreadDemo {\n        public static void main(String[] args) {\n            String str = \"test\"; // 为了和原先的Java版本对照，说明能传参进入线程内，在外声明了一个字符串，其实可以直接写在Lambda里\n            new Thread(() -> { /* do sth. with str */ }).start();\n        }\n    }\n\n不是协程仍是硬伤，但有了Lambda表达式，代码短了不少。不过话又说回来，这样的比较并没有太多意义，所以各位Go粉也不用站出来说Go也支持闭包，Go的版本也能精简。我们比的不是谁写的短，在Java实践中，大多数时候大家会选择线程池，而不是自己new一个Thread对象，Doug Lea大神的Java并发包非常的好用，而且很靠谱。另外，并发中处理的内容才是关键，新启一个线程或者协程才是万里长城的第一步，如果其中的业务逻辑有10个分支，还要多次访问数据库并调用远程服务，那无论用什么语言都白搭。所以**在业务逻辑复杂的情况下，语言的差异并不会太明显**，至少在Java和Go的对比下不明显，至于其他更高阶、表达力更强的语言（比如Common Lisp），大家就要拼智商了。\n\n还有一些情况中，由于客观因素制约，完全就无法使用Go，比如现在如火如荼的互联网金融系统里，与银行对接的系统几乎没有选择，都是Java实现的，因为有的银行只会给Jar包啊……给Jar包啊……Jar包啊……如果是个so文件，也许还能用cgo应付一下，面对一个Jar你让Go该何去何从？\n\n抛开这些让人心烦的问题，让我们再来看看现在比较常见的如何实现REST服务。说到这里，就一定要祭出国人出品的Beego框架。一个最简单的REST服务可以是这样的：\n\n    package main\n    import (\n        \"github.com/astaxie/beego\"\n    )\n    type MainController struct {\n        beego.Controller\n    }\n    func (this *MainController) Get() {\n        this.Ctx.WriteString(\"hello world!\")\n    }\n    func main() {\n        beego.Router(\"/\", &MainController{})\n        beego.Run()\n    }\n    \n既然Go方面，我们使用了一套框架，那么Java方面，我们一样也选择一个成熟的框架，Spring在Java EE方面基本可以算是事实标准，而Spring Boot更是大大提升了Spring项目的开发效率，看看同样实现一个REST服务，在SpringBoot里是怎么做的。\n\n首先，到start.spring.io根据需要生成项目骨架（其实完全可以方便地自己通过Maven手工配置依赖或者是用CLI工具来创建），为了后续的演示，这里我会选上“Web”、“Actuator”和“Remote Shell”，其实就是多了两个Maven的依赖，下文运维部分会提到，然后随便找个顺手的IDE打开工程，敲入如下代码就行了（import、包和类定义的部分基本都是IDE生成的）。\n\n    package demo;\n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    import org.springframework.web.bind.annotation.RequestMapping;\n    import org.springframework.web.bind.annotation.RestController;\n    @SpringBootApplication\n    @RestController\n    public class DemoApplication {\n        @RequestMapping(\"/\")\n        public String sayHello() {\n            return \"hello world!\";\n        }\n        public static void main(String[] args) {\n            SpringApplication.run(DemoApplication.class, args);\n        }\n    }\n\n运行这段代码会自动启动内置Tomcat容器，访问http://localhost:8080/ 就能看到输出了。因为其实就是Spring，所以可以毫无压力地与其他各种框架设施组合，也没有太多学习成本。\n\n可见两者在实现REST服务方面，并没有太大的差别，加之上文提到的业务逻辑问题，只要运用恰当的工具，**两种语言之间并不会产生质的差异。**\n\nBeego中的ORM支持MySQL、PostgreSQL和Sqlite3，而在Java里Hibernate和myBatis这样的ORM工具几乎能通吃大多数常见的关系型数据库，且相当成熟，社区配备了各种自动生成工具来简化使用，行业里还有JPA这样的公认标准。纵观Go的ORM工具，大家还是在探讨，究竟哪个才好用呢？切到NoSQL方面，双方都有大量的驱动可以使用，比如MongoDB和Redis都有详尽的驱动列表，MongoDB还没有官方驱动，但有社区维护的mgo，算是打成平手吧。再大一点，像用到Hadoop、Spark和Storm的场景下，似乎Java的出镜率更高，或者是直接通过Streaming方式就解决了，此处也就不再展开了。\n\n虽然说了这么多问题，但如果真的遇到了大流量、高并发的场景，需要从头开始开发用来处理这些问题的基础设施时，Go还是不错的选择。比如，七牛这样的云服务提供商，又或者是BFE（Baidu Front End，号称可能是全世界流量最大的Go语言集群 ，在2015年的Velocity大会上留下了它的身影——图1和图2）这样的硬货，请不要纠结。\n\n**运维**\n\n写完代码只是万里长征的一小步，后面还有一大堆的事情等着你去解决，比如怎么把写完的代码编译、打包、发布上线。编译打包就不说了，Go的命令行工具go build就能直接把你的代码连同它的所有依赖一起打成一个可执行文件。至于部署，大家都称赞Go的部署没有依赖（除了对glibc的版本有要求，不考虑需要cgo的情况），直接把可执行文件往那里一扔就好了，非常方便。Go内置了强大的HTTP支持，不需要其他Web服务器来做支撑就能获得不错的性能。\n\n再来看看Java，按照常理，一般都会使用Maven或者Gradle来处理编译、打包，甚至是发布，仍旧以Maven为例，mvn package就能完成编译和打包。可以选择Jar包，如果是Web项目部署到容器里的话可以是War包，也可以将各种资源打包到一起放到压缩包（zip、tar等等）里，这个步骤并不复杂。\n\n接下来的部署环节，大家就有话要说了，“Write Once, Run Anywhere”这曾是Java的宣传语，但正是这句话一直被大家诟病，其实如果代码中不使用平台特定的内容（比如避免绑定在WebLogic上），不使用某个特定版本JDK的内部类（比如com.sun里的东西，这种做法本来就不推荐），Java的代码还是能够做到编译后在任何地方都能运行的，事实上现在绝大部分情况下，大家也都是这么做的，看看广大的Java库都是发布Jar到Maven仓库的，也没谁让你直接拉源码来编译。在不同的环境下，只需要部署了对应的JDK就好了（一般放到装机模板里，或者直接拿安装包部署一下就好了），至于是什么操作系统其实并不重要。\n\n延续上文REST服务的例子，Java的Web项目一般都会部署到容器里，比如Tomcat或者Jetty，当然也有用商业容器的（很多银行就是用的WebLogic），所以大家就都认为部署Java程序需要先有容器，这其实是几年前的事情了，后来刮起了一股内嵌容器的风潮，Tomcat和Jetty都可以嵌入到你的程序里，再也不用为有没有容器而烦恼了。Spring Boot索性把这件事变得更简单了，mvn package后，一句话就能搞定内置Tomcat的启动、完成各种部署，然后一切就变成下面这样（假设最后生成的Jar包名为demo.jar）：\n\n    java -jar demo.jar\n\n在Spring Boot 1.3里，还能通过调整Maven Plugin的配置，让Jar可以直接执行（不要小看这么一个变化，它可以大大提升可运维性）：\n\n    ./demo.jar\n\n所以说Java程序难部署其实也是历史，现在的Java程序部署早已是另一番光景。两者的编译、打包、部署环节完全可以打成平手。笔者认为有些方面Java反而更胜一筹，比如Java基本就不用操心交叉编译的问题；Go的库在发布时推荐直接发布源码而非二进制包，遇到天朝特有的网络无法访问的情况，编译个东西还要自备梯子……至于和Nginx等等的配合，更是大家都很方便，就不再赘述了。\n\n完成了部署，接下来的日志和监控，都是很常规的问题，日志各自有对应的库，而监控都是依赖专业的监控平台，自己做好信息输出就好了，请容我再秀一下Spring Boot的RemoteShell终端监控，除了常规的HTTP方式输出JSON信息（自带了健康检查、仪表数据、Dump、请求跟踪等一系列REST输出），还自带了这么个类似top的高大上的玩意儿，ssh -p 2000 user@localhost后执行dashboard可以看到这个实时更新的界面。\n\n![](http://7xjb4o.com1.z0.glb.clouddn.com/spring-remote-shell.png)\n\n**总结**\n\n说了这么多，来总结下全文的观点——虽然Go在语言上表现的很出色，也融入了很多最佳实践，但是结合多方考虑，在很多情况下它并不会比Java带来更多价值，甚至还不一定能做的比Java好，因此作为一个Java程序员，我不会在自己的生产项目中转向Go。\n\n此外，除了本文重点讨论的那些问题，还有更现实的问题摆在那里，比如团队转型成本和招聘的成本，千万不要小看招聘，对于管理者而言，招聘也是工作中的重要内容，试想一下，是招个有经验的Go程序员容易，还是招一个有经验的Java程序员容易，就算能招到一个会Go的正式员工，你能招到一个会Go的外包么，特别是在团队急需补充新鲜血液时，结果是显而易见的。\n\n但这一切都不妨碍大家来学习Go，本文开头就已经表达过这一观点，业余时间学习Go和在生产项目中不用Go并不冲突，Go还是有很多值得学习和借鉴的地方，而且谁也说不准哪天你就真遇上了适合用Go的项目呢。\n","source":"_posts/java-go.md","raw":"title: 作为一名Java程序员，我为什么不在生产项目中转向Go\ndate: 2015-09-27 22:38:21\ncategories: 技术\n---\n\n>原文地址：[http://www.infoq.com/cn/articles/why-not-go](http://www.infoq.com/cn/articles/why-not-go)\n\n自Google在2009年发布Go语言的第一个正式版之后，这门语言就以出色的语言特性受到大家的追捧，尤其是在需要高并发的场景下，大家都会想到是不是该用Go。随后，在国内涌现出了一批以七牛为代表的使用Go作为主要语言的团队，而许式伟大神本人也在各种场合下极力推动Go在国内的发展，于是在这种大环境下，中国的Go开发者群体逐渐超越了其他地区。\n\n那么问题来了，业余时间好学是一回事，真正要将一个新东西运用到生产中则是另一回事。JavaScript的开发者可以义无反顾地选择Node.js，但是对于Java开发者来说，在下一个大项目里究竟是该选择Go，还是Java呢？\n\n<!--more-->\n\n>郑重声明：本文并不是来探讨Go或者Java谁是更好的语言，每种语言都有自己的设计哲学和适用场景，今天主要是在探讨实际工程中的选择和权衡的问题，所以请不要上纲上线。\n\n**语言本身**\n\n首先，需要说明一下，作为一个技术决策者，在进行技术选型时并不能单方面地根据语言本身的特点直接下结论。实际情况下，大多数人会使用一系列的框架、库及工具，简而言之就是会考虑很多周边生态环境的因素，同时还要结合公司的特点、各种历史问题和实际客观因素等等一系列的考虑点综合下来才能完成决策。所以，接下来我们先从语言开始，一步一步来分析下在你的项目中选择Go是否合适。\n\nGo在高并发编程方面无疑是出众的，通过goroutine从语言层面支持了协程，这是Java等语言所无法比拟的，这也是大多数人在面对高并发场景选择Go的重要原因之一。虽然Java有Kilim之类的框架，但没有语言层的支持始终稍逊一筹。\n\n除此之外，Go的其他语法也很有趣，比如多返回值，在一定程度上为开发者带来了一定的便利性。试想，为了返回两到三个值，不得不封装一个对象，或者抹去业务名称使用Map、List等集合类，高级一点用Apache的Pair和Triple，虽然可行，但始终不如Go的实现来得优雅。在此之上，Go也统一了异常的返回方式，不用再去纠结是通过抛异常还是错误码来判断是否成功，多返回值的最后一个是Error就行了。\n\nGo在语言的原生类型中支持了常用的一些结构，比如map和slice，而其他语言中它们更多是存在于库中，这也体现了这门语言是从实践角度出发的特点，既然人人都需要，为什么不在语言层面支持它呢。函数作为一等公民出现在了Go语言里，不过Java在最近的Java 8中也有了Lambda表达式，也算是有进步了。\n\n其他的一些特性，则属于锦上添花型的，比如不定参数，早在2004年的Java 1.5中就对varargs有支持了；多重赋值在Ruby中也有出现，但除了多返回值赋值，以及让你在变量交换值时少写一个中间变量，让代码更美观一些之外，其他的作用着实不是怎么明显。\n\n说了这么多Go的优点，当然它也有一些问题，比如GC，说到它，Java不得不露出洁白的牙齿，虽然在大堆GC上G1还有些不尽如人意，但Java的GC已经发展了很多年，各种策略也比较成熟，CMS或G1足以应付大多数场景，实在有要求还能用Azul Zing JVM。不过从最新的Go 1.5的消息来看，Go的GC实现有了很大地提升，顺便一提的是GOMAXPROCS默认也从1变成了CPU核数，看来官方对Go在多核的利用方面更有信心了。\n\n许世伟在《Go 语言编程》的前言中预言未来10年，Go会取代Java，位居编程榜之首，当时是2012年，为了看看2009年TIOBE年度编程语言如今的排名，笔者在撰写本文时特意去TIOBE看了下，最近的2015年8月排行榜，Java以19.274%位居榜首，Go已经跌出了前50，这不禁让人有些意外。\n\n但总体上来说，笔者认为**Go在语言层面的表现还是相当出色的**，解决了一些编程中的痛点，学习曲线也能够接受，特别是对于那些有C/C++背景的人，会感觉十分亲切。\n\n**工程问题**\n\n一个人写代码时可以很随性，想怎么写就怎么写，但当一个人变成一个团队后，这种随性或者说随便就会带来很多问题，于是就诞生了编码规范这玩意儿，大厂基本都有自己的编码规范，比如Google就有[针对不下十种编程语言的规范](https://github.com/google/styleguide)。团队内约定一套编码规范能够很大程度上地确保代码的风格，降低阅读沟通的成本。Go内置了一套编码规范，违反了该规范代码就无法编译通过，可以说只要你是写Go的，那你的代码就不会太难看，当然Go也没有把所有东西就强制死，还有一些推荐的规范可以通过gofmt进行格式化，但这步不是必须的。\n\n虽然Go自己解决了这个问题，但并不能说Java在这方面是空白，Java发展至今周边工具无数，并不缺成熟的代码静态分析工具，比如CheckStyle、PMD和FindBugs，它们不仅能扫描编码规范的问题，甚至还能扫描代码中潜在的问题并给出解决方案，并且使用方便，在Java开发者社区中有很高地接受度，应该说大多数靠谱地开发者都会使用这些工具。除此之外，一些大厂也有自己的强制手段，比如百度内部也有很多语言的编码规范，而且大部分情况下如果没有通过编码规范的扫描，你是无法提交代码的；还有一些公司会在持续集成过程中加入代码扫描，有FindBugs高优先级的问题时必须修复才能进入下一个阶段。所以说Go在这个问题上的优势并不明显，或者说在一个成熟的环境下，这只是合格而已。\n\n**这里需要强调笔者的一个观点：**\n\n>Go在语言本身和发行包中融入了很多最佳实践，正是这些前人的经验才让它看起来如此优秀。拿这么个海陆空混编特种部队去和Java、C、Ruby这些语言本身做对比，显得不太公平，所以本文在考虑问题时都会结合语言及其生态圈中的成员，毕竟这才更接近真实的情况。\n\nGo本身对项目结构有一套约定，代码放哪里，测试文件如何命名，编译打包后的结果输出到哪个目录，甚至还有go cover这种统计测试覆盖率的命令行，开发者不用在这些问题上太过纠结，再一次体现了Go注重工程实践的特点。回过头来，Java方面，Maven、Gradle都是注重于工程生命周期管理的工具，而且Maven更是历史悠久，被广泛用于各种项目之中。以Maven为例，不仅能够实现上述所有功能，还有很强的插件扩展能力，这里需要的只是一次性维护好pom.xml文件就行了，由于Maven的使用群很大，网上有大量的范例，甚至还有很多生成工程的工具和模板，所以使用成本并不高。\n\n这里还要衍生出一个话题，就是依赖管理，在开发代码时，势必需要依赖很多外部的东西，Go可以直接import远程的内容，这个特性很有创意，但并不能很好地解决版本的问题，在Maven或Gradle里，我们可以直接指定各个依赖项甚至是插件的版本，工具会自动从仓库中下载它们。如果需要同时在同一个系统的不同模块里依赖同一个库的不同版本，我们还能够通过OSGi这种略显复杂的手段来实现，在模块化方面，Jagsaw虽然被一延再延，但估计有望纳入Java 9，这个特性也会解决不少问题。而根据Golang实践群中大家的讨论，似乎godep、gb和gvt都不尽如人意，在这点上看来Go还有一段路要走。\n\n综上所述，Go在工程方面的确有不少亮点，吸纳了很多最佳实践，甚至可以说用Go之后更容易写出规范的代码，有好的项目结构，但**与生态圈完备的Java相比，Go并不占优势**，因为最终代码的质量还是由人决定的，双方都不缺好的工具，所以这方面的特点并不能影响技术选型的决策。\n\n**开发实践**\n\n>Talk is cheap. Show me the code.\n\n下面进入编码环节，先从Go引以为傲的并发开始，《Go语言编程》的前言中有这样一段代码：\n\n    func run(arg string) {\n        // ...\n    }\n    func main() {\n        go run(\"test\")\n        ...\n    }\n\n书中与之对比的Java代码有12行，而且还是线程，不是协程，对比很明显，但那是在2012年的时候，时至今日，Java已经发展到了Java 8，3年了，看看如今的Java代码会是什么样的：\n\n    public class ThreadDemo {\n        public static void main(String[] args) {\n            String str = \"test\"; // 为了和原先的Java版本对照，说明能传参进入线程内，在外声明了一个字符串，其实可以直接写在Lambda里\n            new Thread(() -> { /* do sth. with str */ }).start();\n        }\n    }\n\n不是协程仍是硬伤，但有了Lambda表达式，代码短了不少。不过话又说回来，这样的比较并没有太多意义，所以各位Go粉也不用站出来说Go也支持闭包，Go的版本也能精简。我们比的不是谁写的短，在Java实践中，大多数时候大家会选择线程池，而不是自己new一个Thread对象，Doug Lea大神的Java并发包非常的好用，而且很靠谱。另外，并发中处理的内容才是关键，新启一个线程或者协程才是万里长城的第一步，如果其中的业务逻辑有10个分支，还要多次访问数据库并调用远程服务，那无论用什么语言都白搭。所以**在业务逻辑复杂的情况下，语言的差异并不会太明显**，至少在Java和Go的对比下不明显，至于其他更高阶、表达力更强的语言（比如Common Lisp），大家就要拼智商了。\n\n还有一些情况中，由于客观因素制约，完全就无法使用Go，比如现在如火如荼的互联网金融系统里，与银行对接的系统几乎没有选择，都是Java实现的，因为有的银行只会给Jar包啊……给Jar包啊……Jar包啊……如果是个so文件，也许还能用cgo应付一下，面对一个Jar你让Go该何去何从？\n\n抛开这些让人心烦的问题，让我们再来看看现在比较常见的如何实现REST服务。说到这里，就一定要祭出国人出品的Beego框架。一个最简单的REST服务可以是这样的：\n\n    package main\n    import (\n        \"github.com/astaxie/beego\"\n    )\n    type MainController struct {\n        beego.Controller\n    }\n    func (this *MainController) Get() {\n        this.Ctx.WriteString(\"hello world!\")\n    }\n    func main() {\n        beego.Router(\"/\", &MainController{})\n        beego.Run()\n    }\n    \n既然Go方面，我们使用了一套框架，那么Java方面，我们一样也选择一个成熟的框架，Spring在Java EE方面基本可以算是事实标准，而Spring Boot更是大大提升了Spring项目的开发效率，看看同样实现一个REST服务，在SpringBoot里是怎么做的。\n\n首先，到start.spring.io根据需要生成项目骨架（其实完全可以方便地自己通过Maven手工配置依赖或者是用CLI工具来创建），为了后续的演示，这里我会选上“Web”、“Actuator”和“Remote Shell”，其实就是多了两个Maven的依赖，下文运维部分会提到，然后随便找个顺手的IDE打开工程，敲入如下代码就行了（import、包和类定义的部分基本都是IDE生成的）。\n\n    package demo;\n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    import org.springframework.web.bind.annotation.RequestMapping;\n    import org.springframework.web.bind.annotation.RestController;\n    @SpringBootApplication\n    @RestController\n    public class DemoApplication {\n        @RequestMapping(\"/\")\n        public String sayHello() {\n            return \"hello world!\";\n        }\n        public static void main(String[] args) {\n            SpringApplication.run(DemoApplication.class, args);\n        }\n    }\n\n运行这段代码会自动启动内置Tomcat容器，访问http://localhost:8080/ 就能看到输出了。因为其实就是Spring，所以可以毫无压力地与其他各种框架设施组合，也没有太多学习成本。\n\n可见两者在实现REST服务方面，并没有太大的差别，加之上文提到的业务逻辑问题，只要运用恰当的工具，**两种语言之间并不会产生质的差异。**\n\nBeego中的ORM支持MySQL、PostgreSQL和Sqlite3，而在Java里Hibernate和myBatis这样的ORM工具几乎能通吃大多数常见的关系型数据库，且相当成熟，社区配备了各种自动生成工具来简化使用，行业里还有JPA这样的公认标准。纵观Go的ORM工具，大家还是在探讨，究竟哪个才好用呢？切到NoSQL方面，双方都有大量的驱动可以使用，比如MongoDB和Redis都有详尽的驱动列表，MongoDB还没有官方驱动，但有社区维护的mgo，算是打成平手吧。再大一点，像用到Hadoop、Spark和Storm的场景下，似乎Java的出镜率更高，或者是直接通过Streaming方式就解决了，此处也就不再展开了。\n\n虽然说了这么多问题，但如果真的遇到了大流量、高并发的场景，需要从头开始开发用来处理这些问题的基础设施时，Go还是不错的选择。比如，七牛这样的云服务提供商，又或者是BFE（Baidu Front End，号称可能是全世界流量最大的Go语言集群 ，在2015年的Velocity大会上留下了它的身影——图1和图2）这样的硬货，请不要纠结。\n\n**运维**\n\n写完代码只是万里长征的一小步，后面还有一大堆的事情等着你去解决，比如怎么把写完的代码编译、打包、发布上线。编译打包就不说了，Go的命令行工具go build就能直接把你的代码连同它的所有依赖一起打成一个可执行文件。至于部署，大家都称赞Go的部署没有依赖（除了对glibc的版本有要求，不考虑需要cgo的情况），直接把可执行文件往那里一扔就好了，非常方便。Go内置了强大的HTTP支持，不需要其他Web服务器来做支撑就能获得不错的性能。\n\n再来看看Java，按照常理，一般都会使用Maven或者Gradle来处理编译、打包，甚至是发布，仍旧以Maven为例，mvn package就能完成编译和打包。可以选择Jar包，如果是Web项目部署到容器里的话可以是War包，也可以将各种资源打包到一起放到压缩包（zip、tar等等）里，这个步骤并不复杂。\n\n接下来的部署环节，大家就有话要说了，“Write Once, Run Anywhere”这曾是Java的宣传语，但正是这句话一直被大家诟病，其实如果代码中不使用平台特定的内容（比如避免绑定在WebLogic上），不使用某个特定版本JDK的内部类（比如com.sun里的东西，这种做法本来就不推荐），Java的代码还是能够做到编译后在任何地方都能运行的，事实上现在绝大部分情况下，大家也都是这么做的，看看广大的Java库都是发布Jar到Maven仓库的，也没谁让你直接拉源码来编译。在不同的环境下，只需要部署了对应的JDK就好了（一般放到装机模板里，或者直接拿安装包部署一下就好了），至于是什么操作系统其实并不重要。\n\n延续上文REST服务的例子，Java的Web项目一般都会部署到容器里，比如Tomcat或者Jetty，当然也有用商业容器的（很多银行就是用的WebLogic），所以大家就都认为部署Java程序需要先有容器，这其实是几年前的事情了，后来刮起了一股内嵌容器的风潮，Tomcat和Jetty都可以嵌入到你的程序里，再也不用为有没有容器而烦恼了。Spring Boot索性把这件事变得更简单了，mvn package后，一句话就能搞定内置Tomcat的启动、完成各种部署，然后一切就变成下面这样（假设最后生成的Jar包名为demo.jar）：\n\n    java -jar demo.jar\n\n在Spring Boot 1.3里，还能通过调整Maven Plugin的配置，让Jar可以直接执行（不要小看这么一个变化，它可以大大提升可运维性）：\n\n    ./demo.jar\n\n所以说Java程序难部署其实也是历史，现在的Java程序部署早已是另一番光景。两者的编译、打包、部署环节完全可以打成平手。笔者认为有些方面Java反而更胜一筹，比如Java基本就不用操心交叉编译的问题；Go的库在发布时推荐直接发布源码而非二进制包，遇到天朝特有的网络无法访问的情况，编译个东西还要自备梯子……至于和Nginx等等的配合，更是大家都很方便，就不再赘述了。\n\n完成了部署，接下来的日志和监控，都是很常规的问题，日志各自有对应的库，而监控都是依赖专业的监控平台，自己做好信息输出就好了，请容我再秀一下Spring Boot的RemoteShell终端监控，除了常规的HTTP方式输出JSON信息（自带了健康检查、仪表数据、Dump、请求跟踪等一系列REST输出），还自带了这么个类似top的高大上的玩意儿，ssh -p 2000 user@localhost后执行dashboard可以看到这个实时更新的界面。\n\n![](http://7xjb4o.com1.z0.glb.clouddn.com/spring-remote-shell.png)\n\n**总结**\n\n说了这么多，来总结下全文的观点——虽然Go在语言上表现的很出色，也融入了很多最佳实践，但是结合多方考虑，在很多情况下它并不会比Java带来更多价值，甚至还不一定能做的比Java好，因此作为一个Java程序员，我不会在自己的生产项目中转向Go。\n\n此外，除了本文重点讨论的那些问题，还有更现实的问题摆在那里，比如团队转型成本和招聘的成本，千万不要小看招聘，对于管理者而言，招聘也是工作中的重要内容，试想一下，是招个有经验的Go程序员容易，还是招一个有经验的Java程序员容易，就算能招到一个会Go的正式员工，你能招到一个会Go的外包么，特别是在团队急需补充新鲜血液时，结果是显而易见的。\n\n但这一切都不妨碍大家来学习Go，本文开头就已经表达过这一观点，业余时间学习Go和在生产项目中不用Go并不冲突，Go还是有很多值得学习和借鉴的地方，而且谁也说不准哪天你就真遇上了适合用Go的项目呢。\n","slug":"java-go","published":1,"updated":"2024-04-11T13:25:35.633Z","comments":1,"layout":"post","photos":[],"_id":"cluvablv00003cbihfigxajvy","content":"<blockquote>\n<p>原文地址：<a href=\"http://www.infoq.com/cn/articles/why-not-go\">http://www.infoq.com/cn/articles/why-not-go</a></p>\n</blockquote>\n<p>自Google在2009年发布Go语言的第一个正式版之后，这门语言就以出色的语言特性受到大家的追捧，尤其是在需要高并发的场景下，大家都会想到是不是该用Go。随后，在国内涌现出了一批以七牛为代表的使用Go作为主要语言的团队，而许式伟大神本人也在各种场合下极力推动Go在国内的发展，于是在这种大环境下，中国的Go开发者群体逐渐超越了其他地区。</p>\n<p>那么问题来了，业余时间好学是一回事，真正要将一个新东西运用到生产中则是另一回事。JavaScript的开发者可以义无反顾地选择Node.js，但是对于Java开发者来说，在下一个大项目里究竟是该选择Go，还是Java呢？</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>郑重声明：本文并不是来探讨Go或者Java谁是更好的语言，每种语言都有自己的设计哲学和适用场景，今天主要是在探讨实际工程中的选择和权衡的问题，所以请不要上纲上线。</p>\n</blockquote>\n<p><strong>语言本身</strong></p>\n<p>首先，需要说明一下，作为一个技术决策者，在进行技术选型时并不能单方面地根据语言本身的特点直接下结论。实际情况下，大多数人会使用一系列的框架、库及工具，简而言之就是会考虑很多周边生态环境的因素，同时还要结合公司的特点、各种历史问题和实际客观因素等等一系列的考虑点综合下来才能完成决策。所以，接下来我们先从语言开始，一步一步来分析下在你的项目中选择Go是否合适。</p>\n<p>Go在高并发编程方面无疑是出众的，通过goroutine从语言层面支持了协程，这是Java等语言所无法比拟的，这也是大多数人在面对高并发场景选择Go的重要原因之一。虽然Java有Kilim之类的框架，但没有语言层的支持始终稍逊一筹。</p>\n<p>除此之外，Go的其他语法也很有趣，比如多返回值，在一定程度上为开发者带来了一定的便利性。试想，为了返回两到三个值，不得不封装一个对象，或者抹去业务名称使用Map、List等集合类，高级一点用Apache的Pair和Triple，虽然可行，但始终不如Go的实现来得优雅。在此之上，Go也统一了异常的返回方式，不用再去纠结是通过抛异常还是错误码来判断是否成功，多返回值的最后一个是Error就行了。</p>\n<p>Go在语言的原生类型中支持了常用的一些结构，比如map和slice，而其他语言中它们更多是存在于库中，这也体现了这门语言是从实践角度出发的特点，既然人人都需要，为什么不在语言层面支持它呢。函数作为一等公民出现在了Go语言里，不过Java在最近的Java 8中也有了Lambda表达式，也算是有进步了。</p>\n<p>其他的一些特性，则属于锦上添花型的，比如不定参数，早在2004年的Java 1.5中就对varargs有支持了；多重赋值在Ruby中也有出现，但除了多返回值赋值，以及让你在变量交换值时少写一个中间变量，让代码更美观一些之外，其他的作用着实不是怎么明显。</p>\n<p>说了这么多Go的优点，当然它也有一些问题，比如GC，说到它，Java不得不露出洁白的牙齿，虽然在大堆GC上G1还有些不尽如人意，但Java的GC已经发展了很多年，各种策略也比较成熟，CMS或G1足以应付大多数场景，实在有要求还能用Azul Zing JVM。不过从最新的Go 1.5的消息来看，Go的GC实现有了很大地提升，顺便一提的是GOMAXPROCS默认也从1变成了CPU核数，看来官方对Go在多核的利用方面更有信心了。</p>\n<p>许世伟在《Go 语言编程》的前言中预言未来10年，Go会取代Java，位居编程榜之首，当时是2012年，为了看看2009年TIOBE年度编程语言如今的排名，笔者在撰写本文时特意去TIOBE看了下，最近的2015年8月排行榜，Java以19.274%位居榜首，Go已经跌出了前50，这不禁让人有些意外。</p>\n<p>但总体上来说，笔者认为<strong>Go在语言层面的表现还是相当出色的</strong>，解决了一些编程中的痛点，学习曲线也能够接受，特别是对于那些有C&#x2F;C++背景的人，会感觉十分亲切。</p>\n<p><strong>工程问题</strong></p>\n<p>一个人写代码时可以很随性，想怎么写就怎么写，但当一个人变成一个团队后，这种随性或者说随便就会带来很多问题，于是就诞生了编码规范这玩意儿，大厂基本都有自己的编码规范，比如Google就有<a href=\"https://github.com/google/styleguide\">针对不下十种编程语言的规范</a>。团队内约定一套编码规范能够很大程度上地确保代码的风格，降低阅读沟通的成本。Go内置了一套编码规范，违反了该规范代码就无法编译通过，可以说只要你是写Go的，那你的代码就不会太难看，当然Go也没有把所有东西就强制死，还有一些推荐的规范可以通过gofmt进行格式化，但这步不是必须的。</p>\n<p>虽然Go自己解决了这个问题，但并不能说Java在这方面是空白，Java发展至今周边工具无数，并不缺成熟的代码静态分析工具，比如CheckStyle、PMD和FindBugs，它们不仅能扫描编码规范的问题，甚至还能扫描代码中潜在的问题并给出解决方案，并且使用方便，在Java开发者社区中有很高地接受度，应该说大多数靠谱地开发者都会使用这些工具。除此之外，一些大厂也有自己的强制手段，比如百度内部也有很多语言的编码规范，而且大部分情况下如果没有通过编码规范的扫描，你是无法提交代码的；还有一些公司会在持续集成过程中加入代码扫描，有FindBugs高优先级的问题时必须修复才能进入下一个阶段。所以说Go在这个问题上的优势并不明显，或者说在一个成熟的环境下，这只是合格而已。</p>\n<p><strong>这里需要强调笔者的一个观点：</strong></p>\n<blockquote>\n<p>Go在语言本身和发行包中融入了很多最佳实践，正是这些前人的经验才让它看起来如此优秀。拿这么个海陆空混编特种部队去和Java、C、Ruby这些语言本身做对比，显得不太公平，所以本文在考虑问题时都会结合语言及其生态圈中的成员，毕竟这才更接近真实的情况。</p>\n</blockquote>\n<p>Go本身对项目结构有一套约定，代码放哪里，测试文件如何命名，编译打包后的结果输出到哪个目录，甚至还有go cover这种统计测试覆盖率的命令行，开发者不用在这些问题上太过纠结，再一次体现了Go注重工程实践的特点。回过头来，Java方面，Maven、Gradle都是注重于工程生命周期管理的工具，而且Maven更是历史悠久，被广泛用于各种项目之中。以Maven为例，不仅能够实现上述所有功能，还有很强的插件扩展能力，这里需要的只是一次性维护好pom.xml文件就行了，由于Maven的使用群很大，网上有大量的范例，甚至还有很多生成工程的工具和模板，所以使用成本并不高。</p>\n<p>这里还要衍生出一个话题，就是依赖管理，在开发代码时，势必需要依赖很多外部的东西，Go可以直接import远程的内容，这个特性很有创意，但并不能很好地解决版本的问题，在Maven或Gradle里，我们可以直接指定各个依赖项甚至是插件的版本，工具会自动从仓库中下载它们。如果需要同时在同一个系统的不同模块里依赖同一个库的不同版本，我们还能够通过OSGi这种略显复杂的手段来实现，在模块化方面，Jagsaw虽然被一延再延，但估计有望纳入Java 9，这个特性也会解决不少问题。而根据Golang实践群中大家的讨论，似乎godep、gb和gvt都不尽如人意，在这点上看来Go还有一段路要走。</p>\n<p>综上所述，Go在工程方面的确有不少亮点，吸纳了很多最佳实践，甚至可以说用Go之后更容易写出规范的代码，有好的项目结构，但<strong>与生态圈完备的Java相比，Go并不占优势</strong>，因为最终代码的质量还是由人决定的，双方都不缺好的工具，所以这方面的特点并不能影响技术选型的决策。</p>\n<p><strong>开发实践</strong></p>\n<blockquote>\n<p>Talk is cheap. Show me the code.</p>\n</blockquote>\n<p>下面进入编码环节，先从Go引以为傲的并发开始，《Go语言编程》的前言中有这样一段代码：</p>\n<pre><code>func run(arg string) &#123;\n    // ...\n&#125;\nfunc main() &#123;\n    go run(&quot;test&quot;)\n    ...\n&#125;\n</code></pre>\n<p>书中与之对比的Java代码有12行，而且还是线程，不是协程，对比很明显，但那是在2012年的时候，时至今日，Java已经发展到了Java 8，3年了，看看如今的Java代码会是什么样的：</p>\n<pre><code>public class ThreadDemo &#123;\n    public static void main(String[] args) &#123;\n        String str = &quot;test&quot;; // 为了和原先的Java版本对照，说明能传参进入线程内，在外声明了一个字符串，其实可以直接写在Lambda里\n        new Thread(() -&gt; &#123; /* do sth. with str */ &#125;).start();\n    &#125;\n&#125;\n</code></pre>\n<p>不是协程仍是硬伤，但有了Lambda表达式，代码短了不少。不过话又说回来，这样的比较并没有太多意义，所以各位Go粉也不用站出来说Go也支持闭包，Go的版本也能精简。我们比的不是谁写的短，在Java实践中，大多数时候大家会选择线程池，而不是自己new一个Thread对象，Doug Lea大神的Java并发包非常的好用，而且很靠谱。另外，并发中处理的内容才是关键，新启一个线程或者协程才是万里长城的第一步，如果其中的业务逻辑有10个分支，还要多次访问数据库并调用远程服务，那无论用什么语言都白搭。所以<strong>在业务逻辑复杂的情况下，语言的差异并不会太明显</strong>，至少在Java和Go的对比下不明显，至于其他更高阶、表达力更强的语言（比如Common Lisp），大家就要拼智商了。</p>\n<p>还有一些情况中，由于客观因素制约，完全就无法使用Go，比如现在如火如荼的互联网金融系统里，与银行对接的系统几乎没有选择，都是Java实现的，因为有的银行只会给Jar包啊……给Jar包啊……Jar包啊……如果是个so文件，也许还能用cgo应付一下，面对一个Jar你让Go该何去何从？</p>\n<p>抛开这些让人心烦的问题，让我们再来看看现在比较常见的如何实现REST服务。说到这里，就一定要祭出国人出品的Beego框架。一个最简单的REST服务可以是这样的：</p>\n<pre><code>package main\nimport (\n    &quot;github.com/astaxie/beego&quot;\n)\ntype MainController struct &#123;\n    beego.Controller\n&#125;\nfunc (this *MainController) Get() &#123;\n    this.Ctx.WriteString(&quot;hello world!&quot;)\n&#125;\nfunc main() &#123;\n    beego.Router(&quot;/&quot;, &amp;MainController&#123;&#125;)\n    beego.Run()\n&#125;\n</code></pre>\n<p>既然Go方面，我们使用了一套框架，那么Java方面，我们一样也选择一个成熟的框架，Spring在Java EE方面基本可以算是事实标准，而Spring Boot更是大大提升了Spring项目的开发效率，看看同样实现一个REST服务，在SpringBoot里是怎么做的。</p>\n<p>首先，到start.spring.io根据需要生成项目骨架（其实完全可以方便地自己通过Maven手工配置依赖或者是用CLI工具来创建），为了后续的演示，这里我会选上“Web”、“Actuator”和“Remote Shell”，其实就是多了两个Maven的依赖，下文运维部分会提到，然后随便找个顺手的IDE打开工程，敲入如下代码就行了（import、包和类定义的部分基本都是IDE生成的）。</p>\n<pre><code>package demo;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n@SpringBootApplication\n@RestController\npublic class DemoApplication &#123;\n    @RequestMapping(&quot;/&quot;)\n    public String sayHello() &#123;\n        return &quot;hello world!&quot;;\n    &#125;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(DemoApplication.class, args);\n    &#125;\n&#125;\n</code></pre>\n<p>运行这段代码会自动启动内置Tomcat容器，访问<a href=\"http://localhost:8080/\">http://localhost:8080/</a> 就能看到输出了。因为其实就是Spring，所以可以毫无压力地与其他各种框架设施组合，也没有太多学习成本。</p>\n<p>可见两者在实现REST服务方面，并没有太大的差别，加之上文提到的业务逻辑问题，只要运用恰当的工具，<strong>两种语言之间并不会产生质的差异。</strong></p>\n<p>Beego中的ORM支持MySQL、PostgreSQL和Sqlite3，而在Java里Hibernate和myBatis这样的ORM工具几乎能通吃大多数常见的关系型数据库，且相当成熟，社区配备了各种自动生成工具来简化使用，行业里还有JPA这样的公认标准。纵观Go的ORM工具，大家还是在探讨，究竟哪个才好用呢？切到NoSQL方面，双方都有大量的驱动可以使用，比如MongoDB和Redis都有详尽的驱动列表，MongoDB还没有官方驱动，但有社区维护的mgo，算是打成平手吧。再大一点，像用到Hadoop、Spark和Storm的场景下，似乎Java的出镜率更高，或者是直接通过Streaming方式就解决了，此处也就不再展开了。</p>\n<p>虽然说了这么多问题，但如果真的遇到了大流量、高并发的场景，需要从头开始开发用来处理这些问题的基础设施时，Go还是不错的选择。比如，七牛这样的云服务提供商，又或者是BFE（Baidu Front End，号称可能是全世界流量最大的Go语言集群 ，在2015年的Velocity大会上留下了它的身影——图1和图2）这样的硬货，请不要纠结。</p>\n<p><strong>运维</strong></p>\n<p>写完代码只是万里长征的一小步，后面还有一大堆的事情等着你去解决，比如怎么把写完的代码编译、打包、发布上线。编译打包就不说了，Go的命令行工具go build就能直接把你的代码连同它的所有依赖一起打成一个可执行文件。至于部署，大家都称赞Go的部署没有依赖（除了对glibc的版本有要求，不考虑需要cgo的情况），直接把可执行文件往那里一扔就好了，非常方便。Go内置了强大的HTTP支持，不需要其他Web服务器来做支撑就能获得不错的性能。</p>\n<p>再来看看Java，按照常理，一般都会使用Maven或者Gradle来处理编译、打包，甚至是发布，仍旧以Maven为例，mvn package就能完成编译和打包。可以选择Jar包，如果是Web项目部署到容器里的话可以是War包，也可以将各种资源打包到一起放到压缩包（zip、tar等等）里，这个步骤并不复杂。</p>\n<p>接下来的部署环节，大家就有话要说了，“Write Once, Run Anywhere”这曾是Java的宣传语，但正是这句话一直被大家诟病，其实如果代码中不使用平台特定的内容（比如避免绑定在WebLogic上），不使用某个特定版本JDK的内部类（比如com.sun里的东西，这种做法本来就不推荐），Java的代码还是能够做到编译后在任何地方都能运行的，事实上现在绝大部分情况下，大家也都是这么做的，看看广大的Java库都是发布Jar到Maven仓库的，也没谁让你直接拉源码来编译。在不同的环境下，只需要部署了对应的JDK就好了（一般放到装机模板里，或者直接拿安装包部署一下就好了），至于是什么操作系统其实并不重要。</p>\n<p>延续上文REST服务的例子，Java的Web项目一般都会部署到容器里，比如Tomcat或者Jetty，当然也有用商业容器的（很多银行就是用的WebLogic），所以大家就都认为部署Java程序需要先有容器，这其实是几年前的事情了，后来刮起了一股内嵌容器的风潮，Tomcat和Jetty都可以嵌入到你的程序里，再也不用为有没有容器而烦恼了。Spring Boot索性把这件事变得更简单了，mvn package后，一句话就能搞定内置Tomcat的启动、完成各种部署，然后一切就变成下面这样（假设最后生成的Jar包名为demo.jar）：</p>\n<pre><code>java -jar demo.jar\n</code></pre>\n<p>在Spring Boot 1.3里，还能通过调整Maven Plugin的配置，让Jar可以直接执行（不要小看这么一个变化，它可以大大提升可运维性）：</p>\n<pre><code>./demo.jar\n</code></pre>\n<p>所以说Java程序难部署其实也是历史，现在的Java程序部署早已是另一番光景。两者的编译、打包、部署环节完全可以打成平手。笔者认为有些方面Java反而更胜一筹，比如Java基本就不用操心交叉编译的问题；Go的库在发布时推荐直接发布源码而非二进制包，遇到天朝特有的网络无法访问的情况，编译个东西还要自备梯子……至于和Nginx等等的配合，更是大家都很方便，就不再赘述了。</p>\n<p>完成了部署，接下来的日志和监控，都是很常规的问题，日志各自有对应的库，而监控都是依赖专业的监控平台，自己做好信息输出就好了，请容我再秀一下Spring Boot的RemoteShell终端监控，除了常规的HTTP方式输出JSON信息（自带了健康检查、仪表数据、Dump、请求跟踪等一系列REST输出），还自带了这么个类似top的高大上的玩意儿，ssh -p 2000 user@localhost后执行dashboard可以看到这个实时更新的界面。</p>\n<p><img src=\"http://7xjb4o.com1.z0.glb.clouddn.com/spring-remote-shell.png\"></p>\n<p><strong>总结</strong></p>\n<p>说了这么多，来总结下全文的观点——虽然Go在语言上表现的很出色，也融入了很多最佳实践，但是结合多方考虑，在很多情况下它并不会比Java带来更多价值，甚至还不一定能做的比Java好，因此作为一个Java程序员，我不会在自己的生产项目中转向Go。</p>\n<p>此外，除了本文重点讨论的那些问题，还有更现实的问题摆在那里，比如团队转型成本和招聘的成本，千万不要小看招聘，对于管理者而言，招聘也是工作中的重要内容，试想一下，是招个有经验的Go程序员容易，还是招一个有经验的Java程序员容易，就算能招到一个会Go的正式员工，你能招到一个会Go的外包么，特别是在团队急需补充新鲜血液时，结果是显而易见的。</p>\n<p>但这一切都不妨碍大家来学习Go，本文开头就已经表达过这一观点，业余时间学习Go和在生产项目中不用Go并不冲突，Go还是有很多值得学习和借鉴的地方，而且谁也说不准哪天你就真遇上了适合用Go的项目呢。</p>\n","excerpt":"<blockquote>\n<p>原文地址：<a href=\"http://www.infoq.com/cn/articles/why-not-go\">http://www.infoq.com/cn/articles/why-not-go</a></p>\n</blockquote>\n<p>自Google在2009年发布Go语言的第一个正式版之后，这门语言就以出色的语言特性受到大家的追捧，尤其是在需要高并发的场景下，大家都会想到是不是该用Go。随后，在国内涌现出了一批以七牛为代表的使用Go作为主要语言的团队，而许式伟大神本人也在各种场合下极力推动Go在国内的发展，于是在这种大环境下，中国的Go开发者群体逐渐超越了其他地区。</p>\n<p>那么问题来了，业余时间好学是一回事，真正要将一个新东西运用到生产中则是另一回事。JavaScript的开发者可以义无反顾地选择Node.js，但是对于Java开发者来说，在下一个大项目里究竟是该选择Go，还是Java呢？</p>","more":"<blockquote>\n<p>郑重声明：本文并不是来探讨Go或者Java谁是更好的语言，每种语言都有自己的设计哲学和适用场景，今天主要是在探讨实际工程中的选择和权衡的问题，所以请不要上纲上线。</p>\n</blockquote>\n<p><strong>语言本身</strong></p>\n<p>首先，需要说明一下，作为一个技术决策者，在进行技术选型时并不能单方面地根据语言本身的特点直接下结论。实际情况下，大多数人会使用一系列的框架、库及工具，简而言之就是会考虑很多周边生态环境的因素，同时还要结合公司的特点、各种历史问题和实际客观因素等等一系列的考虑点综合下来才能完成决策。所以，接下来我们先从语言开始，一步一步来分析下在你的项目中选择Go是否合适。</p>\n<p>Go在高并发编程方面无疑是出众的，通过goroutine从语言层面支持了协程，这是Java等语言所无法比拟的，这也是大多数人在面对高并发场景选择Go的重要原因之一。虽然Java有Kilim之类的框架，但没有语言层的支持始终稍逊一筹。</p>\n<p>除此之外，Go的其他语法也很有趣，比如多返回值，在一定程度上为开发者带来了一定的便利性。试想，为了返回两到三个值，不得不封装一个对象，或者抹去业务名称使用Map、List等集合类，高级一点用Apache的Pair和Triple，虽然可行，但始终不如Go的实现来得优雅。在此之上，Go也统一了异常的返回方式，不用再去纠结是通过抛异常还是错误码来判断是否成功，多返回值的最后一个是Error就行了。</p>\n<p>Go在语言的原生类型中支持了常用的一些结构，比如map和slice，而其他语言中它们更多是存在于库中，这也体现了这门语言是从实践角度出发的特点，既然人人都需要，为什么不在语言层面支持它呢。函数作为一等公民出现在了Go语言里，不过Java在最近的Java 8中也有了Lambda表达式，也算是有进步了。</p>\n<p>其他的一些特性，则属于锦上添花型的，比如不定参数，早在2004年的Java 1.5中就对varargs有支持了；多重赋值在Ruby中也有出现，但除了多返回值赋值，以及让你在变量交换值时少写一个中间变量，让代码更美观一些之外，其他的作用着实不是怎么明显。</p>\n<p>说了这么多Go的优点，当然它也有一些问题，比如GC，说到它，Java不得不露出洁白的牙齿，虽然在大堆GC上G1还有些不尽如人意，但Java的GC已经发展了很多年，各种策略也比较成熟，CMS或G1足以应付大多数场景，实在有要求还能用Azul Zing JVM。不过从最新的Go 1.5的消息来看，Go的GC实现有了很大地提升，顺便一提的是GOMAXPROCS默认也从1变成了CPU核数，看来官方对Go在多核的利用方面更有信心了。</p>\n<p>许世伟在《Go 语言编程》的前言中预言未来10年，Go会取代Java，位居编程榜之首，当时是2012年，为了看看2009年TIOBE年度编程语言如今的排名，笔者在撰写本文时特意去TIOBE看了下，最近的2015年8月排行榜，Java以19.274%位居榜首，Go已经跌出了前50，这不禁让人有些意外。</p>\n<p>但总体上来说，笔者认为<strong>Go在语言层面的表现还是相当出色的</strong>，解决了一些编程中的痛点，学习曲线也能够接受，特别是对于那些有C&#x2F;C++背景的人，会感觉十分亲切。</p>\n<p><strong>工程问题</strong></p>\n<p>一个人写代码时可以很随性，想怎么写就怎么写，但当一个人变成一个团队后，这种随性或者说随便就会带来很多问题，于是就诞生了编码规范这玩意儿，大厂基本都有自己的编码规范，比如Google就有<a href=\"https://github.com/google/styleguide\">针对不下十种编程语言的规范</a>。团队内约定一套编码规范能够很大程度上地确保代码的风格，降低阅读沟通的成本。Go内置了一套编码规范，违反了该规范代码就无法编译通过，可以说只要你是写Go的，那你的代码就不会太难看，当然Go也没有把所有东西就强制死，还有一些推荐的规范可以通过gofmt进行格式化，但这步不是必须的。</p>\n<p>虽然Go自己解决了这个问题，但并不能说Java在这方面是空白，Java发展至今周边工具无数，并不缺成熟的代码静态分析工具，比如CheckStyle、PMD和FindBugs，它们不仅能扫描编码规范的问题，甚至还能扫描代码中潜在的问题并给出解决方案，并且使用方便，在Java开发者社区中有很高地接受度，应该说大多数靠谱地开发者都会使用这些工具。除此之外，一些大厂也有自己的强制手段，比如百度内部也有很多语言的编码规范，而且大部分情况下如果没有通过编码规范的扫描，你是无法提交代码的；还有一些公司会在持续集成过程中加入代码扫描，有FindBugs高优先级的问题时必须修复才能进入下一个阶段。所以说Go在这个问题上的优势并不明显，或者说在一个成熟的环境下，这只是合格而已。</p>\n<p><strong>这里需要强调笔者的一个观点：</strong></p>\n<blockquote>\n<p>Go在语言本身和发行包中融入了很多最佳实践，正是这些前人的经验才让它看起来如此优秀。拿这么个海陆空混编特种部队去和Java、C、Ruby这些语言本身做对比，显得不太公平，所以本文在考虑问题时都会结合语言及其生态圈中的成员，毕竟这才更接近真实的情况。</p>\n</blockquote>\n<p>Go本身对项目结构有一套约定，代码放哪里，测试文件如何命名，编译打包后的结果输出到哪个目录，甚至还有go cover这种统计测试覆盖率的命令行，开发者不用在这些问题上太过纠结，再一次体现了Go注重工程实践的特点。回过头来，Java方面，Maven、Gradle都是注重于工程生命周期管理的工具，而且Maven更是历史悠久，被广泛用于各种项目之中。以Maven为例，不仅能够实现上述所有功能，还有很强的插件扩展能力，这里需要的只是一次性维护好pom.xml文件就行了，由于Maven的使用群很大，网上有大量的范例，甚至还有很多生成工程的工具和模板，所以使用成本并不高。</p>\n<p>这里还要衍生出一个话题，就是依赖管理，在开发代码时，势必需要依赖很多外部的东西，Go可以直接import远程的内容，这个特性很有创意，但并不能很好地解决版本的问题，在Maven或Gradle里，我们可以直接指定各个依赖项甚至是插件的版本，工具会自动从仓库中下载它们。如果需要同时在同一个系统的不同模块里依赖同一个库的不同版本，我们还能够通过OSGi这种略显复杂的手段来实现，在模块化方面，Jagsaw虽然被一延再延，但估计有望纳入Java 9，这个特性也会解决不少问题。而根据Golang实践群中大家的讨论，似乎godep、gb和gvt都不尽如人意，在这点上看来Go还有一段路要走。</p>\n<p>综上所述，Go在工程方面的确有不少亮点，吸纳了很多最佳实践，甚至可以说用Go之后更容易写出规范的代码，有好的项目结构，但<strong>与生态圈完备的Java相比，Go并不占优势</strong>，因为最终代码的质量还是由人决定的，双方都不缺好的工具，所以这方面的特点并不能影响技术选型的决策。</p>\n<p><strong>开发实践</strong></p>\n<blockquote>\n<p>Talk is cheap. Show me the code.</p>\n</blockquote>\n<p>下面进入编码环节，先从Go引以为傲的并发开始，《Go语言编程》的前言中有这样一段代码：</p>\n<pre><code>func run(arg string) &#123;\n    // ...\n&#125;\nfunc main() &#123;\n    go run(&quot;test&quot;)\n    ...\n&#125;\n</code></pre>\n<p>书中与之对比的Java代码有12行，而且还是线程，不是协程，对比很明显，但那是在2012年的时候，时至今日，Java已经发展到了Java 8，3年了，看看如今的Java代码会是什么样的：</p>\n<pre><code>public class ThreadDemo &#123;\n    public static void main(String[] args) &#123;\n        String str = &quot;test&quot;; // 为了和原先的Java版本对照，说明能传参进入线程内，在外声明了一个字符串，其实可以直接写在Lambda里\n        new Thread(() -&gt; &#123; /* do sth. with str */ &#125;).start();\n    &#125;\n&#125;\n</code></pre>\n<p>不是协程仍是硬伤，但有了Lambda表达式，代码短了不少。不过话又说回来，这样的比较并没有太多意义，所以各位Go粉也不用站出来说Go也支持闭包，Go的版本也能精简。我们比的不是谁写的短，在Java实践中，大多数时候大家会选择线程池，而不是自己new一个Thread对象，Doug Lea大神的Java并发包非常的好用，而且很靠谱。另外，并发中处理的内容才是关键，新启一个线程或者协程才是万里长城的第一步，如果其中的业务逻辑有10个分支，还要多次访问数据库并调用远程服务，那无论用什么语言都白搭。所以<strong>在业务逻辑复杂的情况下，语言的差异并不会太明显</strong>，至少在Java和Go的对比下不明显，至于其他更高阶、表达力更强的语言（比如Common Lisp），大家就要拼智商了。</p>\n<p>还有一些情况中，由于客观因素制约，完全就无法使用Go，比如现在如火如荼的互联网金融系统里，与银行对接的系统几乎没有选择，都是Java实现的，因为有的银行只会给Jar包啊……给Jar包啊……Jar包啊……如果是个so文件，也许还能用cgo应付一下，面对一个Jar你让Go该何去何从？</p>\n<p>抛开这些让人心烦的问题，让我们再来看看现在比较常见的如何实现REST服务。说到这里，就一定要祭出国人出品的Beego框架。一个最简单的REST服务可以是这样的：</p>\n<pre><code>package main\nimport (\n    &quot;github.com/astaxie/beego&quot;\n)\ntype MainController struct &#123;\n    beego.Controller\n&#125;\nfunc (this *MainController) Get() &#123;\n    this.Ctx.WriteString(&quot;hello world!&quot;)\n&#125;\nfunc main() &#123;\n    beego.Router(&quot;/&quot;, &amp;MainController&#123;&#125;)\n    beego.Run()\n&#125;\n</code></pre>\n<p>既然Go方面，我们使用了一套框架，那么Java方面，我们一样也选择一个成熟的框架，Spring在Java EE方面基本可以算是事实标准，而Spring Boot更是大大提升了Spring项目的开发效率，看看同样实现一个REST服务，在SpringBoot里是怎么做的。</p>\n<p>首先，到start.spring.io根据需要生成项目骨架（其实完全可以方便地自己通过Maven手工配置依赖或者是用CLI工具来创建），为了后续的演示，这里我会选上“Web”、“Actuator”和“Remote Shell”，其实就是多了两个Maven的依赖，下文运维部分会提到，然后随便找个顺手的IDE打开工程，敲入如下代码就行了（import、包和类定义的部分基本都是IDE生成的）。</p>\n<pre><code>package demo;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n@SpringBootApplication\n@RestController\npublic class DemoApplication &#123;\n    @RequestMapping(&quot;/&quot;)\n    public String sayHello() &#123;\n        return &quot;hello world!&quot;;\n    &#125;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(DemoApplication.class, args);\n    &#125;\n&#125;\n</code></pre>\n<p>运行这段代码会自动启动内置Tomcat容器，访问<a href=\"http://localhost:8080/\">http://localhost:8080/</a> 就能看到输出了。因为其实就是Spring，所以可以毫无压力地与其他各种框架设施组合，也没有太多学习成本。</p>\n<p>可见两者在实现REST服务方面，并没有太大的差别，加之上文提到的业务逻辑问题，只要运用恰当的工具，<strong>两种语言之间并不会产生质的差异。</strong></p>\n<p>Beego中的ORM支持MySQL、PostgreSQL和Sqlite3，而在Java里Hibernate和myBatis这样的ORM工具几乎能通吃大多数常见的关系型数据库，且相当成熟，社区配备了各种自动生成工具来简化使用，行业里还有JPA这样的公认标准。纵观Go的ORM工具，大家还是在探讨，究竟哪个才好用呢？切到NoSQL方面，双方都有大量的驱动可以使用，比如MongoDB和Redis都有详尽的驱动列表，MongoDB还没有官方驱动，但有社区维护的mgo，算是打成平手吧。再大一点，像用到Hadoop、Spark和Storm的场景下，似乎Java的出镜率更高，或者是直接通过Streaming方式就解决了，此处也就不再展开了。</p>\n<p>虽然说了这么多问题，但如果真的遇到了大流量、高并发的场景，需要从头开始开发用来处理这些问题的基础设施时，Go还是不错的选择。比如，七牛这样的云服务提供商，又或者是BFE（Baidu Front End，号称可能是全世界流量最大的Go语言集群 ，在2015年的Velocity大会上留下了它的身影——图1和图2）这样的硬货，请不要纠结。</p>\n<p><strong>运维</strong></p>\n<p>写完代码只是万里长征的一小步，后面还有一大堆的事情等着你去解决，比如怎么把写完的代码编译、打包、发布上线。编译打包就不说了，Go的命令行工具go build就能直接把你的代码连同它的所有依赖一起打成一个可执行文件。至于部署，大家都称赞Go的部署没有依赖（除了对glibc的版本有要求，不考虑需要cgo的情况），直接把可执行文件往那里一扔就好了，非常方便。Go内置了强大的HTTP支持，不需要其他Web服务器来做支撑就能获得不错的性能。</p>\n<p>再来看看Java，按照常理，一般都会使用Maven或者Gradle来处理编译、打包，甚至是发布，仍旧以Maven为例，mvn package就能完成编译和打包。可以选择Jar包，如果是Web项目部署到容器里的话可以是War包，也可以将各种资源打包到一起放到压缩包（zip、tar等等）里，这个步骤并不复杂。</p>\n<p>接下来的部署环节，大家就有话要说了，“Write Once, Run Anywhere”这曾是Java的宣传语，但正是这句话一直被大家诟病，其实如果代码中不使用平台特定的内容（比如避免绑定在WebLogic上），不使用某个特定版本JDK的内部类（比如com.sun里的东西，这种做法本来就不推荐），Java的代码还是能够做到编译后在任何地方都能运行的，事实上现在绝大部分情况下，大家也都是这么做的，看看广大的Java库都是发布Jar到Maven仓库的，也没谁让你直接拉源码来编译。在不同的环境下，只需要部署了对应的JDK就好了（一般放到装机模板里，或者直接拿安装包部署一下就好了），至于是什么操作系统其实并不重要。</p>\n<p>延续上文REST服务的例子，Java的Web项目一般都会部署到容器里，比如Tomcat或者Jetty，当然也有用商业容器的（很多银行就是用的WebLogic），所以大家就都认为部署Java程序需要先有容器，这其实是几年前的事情了，后来刮起了一股内嵌容器的风潮，Tomcat和Jetty都可以嵌入到你的程序里，再也不用为有没有容器而烦恼了。Spring Boot索性把这件事变得更简单了，mvn package后，一句话就能搞定内置Tomcat的启动、完成各种部署，然后一切就变成下面这样（假设最后生成的Jar包名为demo.jar）：</p>\n<pre><code>java -jar demo.jar\n</code></pre>\n<p>在Spring Boot 1.3里，还能通过调整Maven Plugin的配置，让Jar可以直接执行（不要小看这么一个变化，它可以大大提升可运维性）：</p>\n<pre><code>./demo.jar\n</code></pre>\n<p>所以说Java程序难部署其实也是历史，现在的Java程序部署早已是另一番光景。两者的编译、打包、部署环节完全可以打成平手。笔者认为有些方面Java反而更胜一筹，比如Java基本就不用操心交叉编译的问题；Go的库在发布时推荐直接发布源码而非二进制包，遇到天朝特有的网络无法访问的情况，编译个东西还要自备梯子……至于和Nginx等等的配合，更是大家都很方便，就不再赘述了。</p>\n<p>完成了部署，接下来的日志和监控，都是很常规的问题，日志各自有对应的库，而监控都是依赖专业的监控平台，自己做好信息输出就好了，请容我再秀一下Spring Boot的RemoteShell终端监控，除了常规的HTTP方式输出JSON信息（自带了健康检查、仪表数据、Dump、请求跟踪等一系列REST输出），还自带了这么个类似top的高大上的玩意儿，ssh -p 2000 user@localhost后执行dashboard可以看到这个实时更新的界面。</p>\n<p><img src=\"http://7xjb4o.com1.z0.glb.clouddn.com/spring-remote-shell.png\"></p>\n<p><strong>总结</strong></p>\n<p>说了这么多，来总结下全文的观点——虽然Go在语言上表现的很出色，也融入了很多最佳实践，但是结合多方考虑，在很多情况下它并不会比Java带来更多价值，甚至还不一定能做的比Java好，因此作为一个Java程序员，我不会在自己的生产项目中转向Go。</p>\n<p>此外，除了本文重点讨论的那些问题，还有更现实的问题摆在那里，比如团队转型成本和招聘的成本，千万不要小看招聘，对于管理者而言，招聘也是工作中的重要内容，试想一下，是招个有经验的Go程序员容易，还是招一个有经验的Java程序员容易，就算能招到一个会Go的正式员工，你能招到一个会Go的外包么，特别是在团队急需补充新鲜血液时，结果是显而易见的。</p>\n<p>但这一切都不妨碍大家来学习Go，本文开头就已经表达过这一观点，业余时间学习Go和在生产项目中不用Go并不冲突，Go还是有很多值得学习和借鉴的地方，而且谁也说不准哪天你就真遇上了适合用Go的项目呢。</p>"},{"title":"MongoDB常用API总结","date":"2015-08-23T10:27:41.000Z","_content":"\n>类转换\n\n当把一个类对象存到mongoDB后，从mongoDB取出来时使用setObjectClass()将其转换回原来的类。\n\n    public class Tweet implements DBObject { \n        /* ... */ \n    } \n    Tweet myTweet = new Tweet(); \n    myTweet.put(\"user\", \"bruce\"); \n    myTweet.put(\"message\", \"fun\"); \n    myTweet.put(\"date\", new Date()); \n    collection.insert(myTweet); \n    //转换 \n    collection.setObjectClass(Tweet.class); \n    Tweet myTweet = (Tweet)collection.findOne(); \n    \n\n<!--more-->\n\n>默认ID\n\n当保存的对象没有设置ID时，mongoDB会默认给该条记录设置一个ID（\"_id\"）。\n当然你也可以设置自己指定的ID，如：(在mongoDB中执行用db.users.save({_id:1,name:'bruce'});)\n\n    BasicDBObject bo = new BasicDBObject();\n    bo.put('_id', 1);\n    bo.put('name', 'bruce');\n    collection.insert(bo);\n    \n>权限\n\n判断是否有mongoDB的访问权限，有就返回true，否则返回false。\n\n    boolean auth = db.authenticate(myUserName, myPassword);\n    \n    \n>查看mongoDB数据库列表\n\n    Mongo m = new Mongo(); \n    for (String s : m.getDatabaseNames()) { \n        System.out.println(s); \n    }\n    \n>查看当前库下所有的表名，等于在mongoDB中执行showtables;\n\n    Set colls = db.getCollectionNames(); \n    for (String s : colls) { \n        System.out.println(s); \n    }\n    \n>查看一个表的索引\n\n    List list = coll.getIndexInfo(); \n    for (DBObject o : list) { \n        System.out.println(o); \n    } \n    \n>删除一个数据库\n\n    Mongo m = new Mongo(); \n    m.dropDatabase(\"myDatabaseName\");\n    \n>建立mongoDB的链接\n\n    Mongo m = new Mongo(\"localhost\", 27017); //有多个重载方法，可根据需要选择\n    DB db = m.getDB(\"myDatabaseName\"); //相当于库名 \n    DBCollection coll = db.getCollection(\"myUsersTable\")；//相当于表名 \n    \n\n查询数据\n\n>查询第一条记录\n\n    DBObject firstDoc = coll.findOne(); \n    \nfindOne()返回一个记录，而find()返回的是DBCursor游标对象。\n\n>查询全部数据\n\n    DBCursor cur = coll.find(); \n    while(cur.hasNext()) { \n        System.out.println(cur.next()); \n    }\n    \n>查询记录数量\n\n    coll.find().count(); \n    coll.find(new BasicDBObject(\"age\", 26)).count();\n    \n>条件查询\n\n    BasicDBObject condition = new BasicDBObject(); \n    condition.put(\"name\", \"bruce\"); \n    condition.put(\"age\", 26); \n    coll.find(condition);\n    \n>查询部分数据块\n\n    DBCursor cursor = coll.find().skip(0).limit(10); \n    while(cursor.hasNext()) { \n        System.out.println(cursor.next()); \n    } \n    \n>比较查询(age >50)\n\n    BasicDBObject condition = new BasicDBObject(); \n    condition.put(\"age\", new BasicDBObject(\"$gt\",50)); \n    coll.find(condition);\n    \n>比较符\n\n    \"$gt\"： 大于\n    \"$gte\"：大于等于\n    \"$lt\"： 小于\n    \"$lte\"：小于等于\n    \"$in\"： 包含\n    //以下条件查询20<age<=30\n    condition.put(\"age\", new BasicDBObject(\"$gt\",20).append(\"$lte\", 30));\n    \n\n插入数据\n\n>批量插入\n\n    List datas = new ArrayList(); \n    for (int i=0; i < 100; i++) { \n        BasicDBObject bo = new BasicDBObject(); \n        bo.put(\"name\", \"bruce\"); \n        bo.append(\"age\", i); \n        datas.add(bo); \n    } \n    coll.insert(datas); \n    \n又如：\n\n    DBCollection coll = db.getCollection(\"testCollection\");   \n    for(int i=1; i<=100; i++) {//插入100条记录   \n        User user = new User();   \n        user.setName(\"user_\"+i);  \n        user.setPoint(i);   \n        coll.insert(user);\n    }\n    \n>正则表达式\n\n查询所有名字匹配 /joh?n/i 的记录\n\n    Pattern pattern = Pattern.compile(\"joh?n\",CASE_INSENSITIVE); \n    BasicDBObject query = new BasicDBObject(\"name\", pattern); \n    DBCursor cursor = coll.find(query);\n","source":"_posts/mongodb-api.md","raw":"title: MongoDB常用API总结\ndate: 2015-08-23 18:27:41\ncategories: 技术\n---\n\n>类转换\n\n当把一个类对象存到mongoDB后，从mongoDB取出来时使用setObjectClass()将其转换回原来的类。\n\n    public class Tweet implements DBObject { \n        /* ... */ \n    } \n    Tweet myTweet = new Tweet(); \n    myTweet.put(\"user\", \"bruce\"); \n    myTweet.put(\"message\", \"fun\"); \n    myTweet.put(\"date\", new Date()); \n    collection.insert(myTweet); \n    //转换 \n    collection.setObjectClass(Tweet.class); \n    Tweet myTweet = (Tweet)collection.findOne(); \n    \n\n<!--more-->\n\n>默认ID\n\n当保存的对象没有设置ID时，mongoDB会默认给该条记录设置一个ID（\"_id\"）。\n当然你也可以设置自己指定的ID，如：(在mongoDB中执行用db.users.save({_id:1,name:'bruce'});)\n\n    BasicDBObject bo = new BasicDBObject();\n    bo.put('_id', 1);\n    bo.put('name', 'bruce');\n    collection.insert(bo);\n    \n>权限\n\n判断是否有mongoDB的访问权限，有就返回true，否则返回false。\n\n    boolean auth = db.authenticate(myUserName, myPassword);\n    \n    \n>查看mongoDB数据库列表\n\n    Mongo m = new Mongo(); \n    for (String s : m.getDatabaseNames()) { \n        System.out.println(s); \n    }\n    \n>查看当前库下所有的表名，等于在mongoDB中执行showtables;\n\n    Set colls = db.getCollectionNames(); \n    for (String s : colls) { \n        System.out.println(s); \n    }\n    \n>查看一个表的索引\n\n    List list = coll.getIndexInfo(); \n    for (DBObject o : list) { \n        System.out.println(o); \n    } \n    \n>删除一个数据库\n\n    Mongo m = new Mongo(); \n    m.dropDatabase(\"myDatabaseName\");\n    \n>建立mongoDB的链接\n\n    Mongo m = new Mongo(\"localhost\", 27017); //有多个重载方法，可根据需要选择\n    DB db = m.getDB(\"myDatabaseName\"); //相当于库名 \n    DBCollection coll = db.getCollection(\"myUsersTable\")；//相当于表名 \n    \n\n查询数据\n\n>查询第一条记录\n\n    DBObject firstDoc = coll.findOne(); \n    \nfindOne()返回一个记录，而find()返回的是DBCursor游标对象。\n\n>查询全部数据\n\n    DBCursor cur = coll.find(); \n    while(cur.hasNext()) { \n        System.out.println(cur.next()); \n    }\n    \n>查询记录数量\n\n    coll.find().count(); \n    coll.find(new BasicDBObject(\"age\", 26)).count();\n    \n>条件查询\n\n    BasicDBObject condition = new BasicDBObject(); \n    condition.put(\"name\", \"bruce\"); \n    condition.put(\"age\", 26); \n    coll.find(condition);\n    \n>查询部分数据块\n\n    DBCursor cursor = coll.find().skip(0).limit(10); \n    while(cursor.hasNext()) { \n        System.out.println(cursor.next()); \n    } \n    \n>比较查询(age >50)\n\n    BasicDBObject condition = new BasicDBObject(); \n    condition.put(\"age\", new BasicDBObject(\"$gt\",50)); \n    coll.find(condition);\n    \n>比较符\n\n    \"$gt\"： 大于\n    \"$gte\"：大于等于\n    \"$lt\"： 小于\n    \"$lte\"：小于等于\n    \"$in\"： 包含\n    //以下条件查询20<age<=30\n    condition.put(\"age\", new BasicDBObject(\"$gt\",20).append(\"$lte\", 30));\n    \n\n插入数据\n\n>批量插入\n\n    List datas = new ArrayList(); \n    for (int i=0; i < 100; i++) { \n        BasicDBObject bo = new BasicDBObject(); \n        bo.put(\"name\", \"bruce\"); \n        bo.append(\"age\", i); \n        datas.add(bo); \n    } \n    coll.insert(datas); \n    \n又如：\n\n    DBCollection coll = db.getCollection(\"testCollection\");   \n    for(int i=1; i<=100; i++) {//插入100条记录   \n        User user = new User();   \n        user.setName(\"user_\"+i);  \n        user.setPoint(i);   \n        coll.insert(user);\n    }\n    \n>正则表达式\n\n查询所有名字匹配 /joh?n/i 的记录\n\n    Pattern pattern = Pattern.compile(\"joh?n\",CASE_INSENSITIVE); \n    BasicDBObject query = new BasicDBObject(\"name\", pattern); \n    DBCursor cursor = coll.find(query);\n","slug":"mongodb-api","published":1,"updated":"2024-04-11T13:25:35.646Z","comments":1,"layout":"post","photos":[],"_id":"cluvablv10005cbihgqb21kw0","content":"<blockquote>\n<p>类转换</p>\n</blockquote>\n<p>当把一个类对象存到mongoDB后，从mongoDB取出来时使用setObjectClass()将其转换回原来的类。</p>\n<pre><code>public class Tweet implements DBObject &#123; \n    /* ... */ \n&#125; \nTweet myTweet = new Tweet(); \nmyTweet.put(&quot;user&quot;, &quot;bruce&quot;); \nmyTweet.put(&quot;message&quot;, &quot;fun&quot;); \nmyTweet.put(&quot;date&quot;, new Date()); \ncollection.insert(myTweet); \n//转换 \ncollection.setObjectClass(Tweet.class); \nTweet myTweet = (Tweet)collection.findOne(); \n</code></pre>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>默认ID</p>\n</blockquote>\n<p>当保存的对象没有设置ID时，mongoDB会默认给该条记录设置一个ID（”_id”）。<br>当然你也可以设置自己指定的ID，如：(在mongoDB中执行用db.users.save({_id:1,name:’bruce’});)</p>\n<pre><code>BasicDBObject bo = new BasicDBObject();\nbo.put(&#39;_id&#39;, 1);\nbo.put(&#39;name&#39;, &#39;bruce&#39;);\ncollection.insert(bo);\n</code></pre>\n<blockquote>\n<p>权限</p>\n</blockquote>\n<p>判断是否有mongoDB的访问权限，有就返回true，否则返回false。</p>\n<pre><code>boolean auth = db.authenticate(myUserName, myPassword);\n</code></pre>\n<blockquote>\n<p>查看mongoDB数据库列表</p>\n</blockquote>\n<pre><code>Mongo m = new Mongo(); \nfor (String s : m.getDatabaseNames()) &#123; \n    System.out.println(s); \n&#125;\n</code></pre>\n<blockquote>\n<p>查看当前库下所有的表名，等于在mongoDB中执行showtables;</p>\n</blockquote>\n<pre><code>Set colls = db.getCollectionNames(); \nfor (String s : colls) &#123; \n    System.out.println(s); \n&#125;\n</code></pre>\n<blockquote>\n<p>查看一个表的索引</p>\n</blockquote>\n<pre><code>List list = coll.getIndexInfo(); \nfor (DBObject o : list) &#123; \n    System.out.println(o); \n&#125; \n</code></pre>\n<blockquote>\n<p>删除一个数据库</p>\n</blockquote>\n<pre><code>Mongo m = new Mongo(); \nm.dropDatabase(&quot;myDatabaseName&quot;);\n</code></pre>\n<blockquote>\n<p>建立mongoDB的链接</p>\n</blockquote>\n<pre><code>Mongo m = new Mongo(&quot;localhost&quot;, 27017); //有多个重载方法，可根据需要选择\nDB db = m.getDB(&quot;myDatabaseName&quot;); //相当于库名 \nDBCollection coll = db.getCollection(&quot;myUsersTable&quot;)；//相当于表名 \n</code></pre>\n<p>查询数据</p>\n<blockquote>\n<p>查询第一条记录</p>\n</blockquote>\n<pre><code>DBObject firstDoc = coll.findOne(); \n</code></pre>\n<p>findOne()返回一个记录，而find()返回的是DBCursor游标对象。</p>\n<blockquote>\n<p>查询全部数据</p>\n</blockquote>\n<pre><code>DBCursor cur = coll.find(); \nwhile(cur.hasNext()) &#123; \n    System.out.println(cur.next()); \n&#125;\n</code></pre>\n<blockquote>\n<p>查询记录数量</p>\n</blockquote>\n<pre><code>coll.find().count(); \ncoll.find(new BasicDBObject(&quot;age&quot;, 26)).count();\n</code></pre>\n<blockquote>\n<p>条件查询</p>\n</blockquote>\n<pre><code>BasicDBObject condition = new BasicDBObject(); \ncondition.put(&quot;name&quot;, &quot;bruce&quot;); \ncondition.put(&quot;age&quot;, 26); \ncoll.find(condition);\n</code></pre>\n<blockquote>\n<p>查询部分数据块</p>\n</blockquote>\n<pre><code>DBCursor cursor = coll.find().skip(0).limit(10); \nwhile(cursor.hasNext()) &#123; \n    System.out.println(cursor.next()); \n&#125; \n</code></pre>\n<blockquote>\n<p>比较查询(age &gt;50)</p>\n</blockquote>\n<pre><code>BasicDBObject condition = new BasicDBObject(); \ncondition.put(&quot;age&quot;, new BasicDBObject(&quot;$gt&quot;,50)); \ncoll.find(condition);\n</code></pre>\n<blockquote>\n<p>比较符</p>\n</blockquote>\n<pre><code>&quot;$gt&quot;： 大于\n&quot;$gte&quot;：大于等于\n&quot;$lt&quot;： 小于\n&quot;$lte&quot;：小于等于\n&quot;$in&quot;： 包含\n//以下条件查询20&lt;age&lt;=30\ncondition.put(&quot;age&quot;, new BasicDBObject(&quot;$gt&quot;,20).append(&quot;$lte&quot;, 30));\n</code></pre>\n<p>插入数据</p>\n<blockquote>\n<p>批量插入</p>\n</blockquote>\n<pre><code>List datas = new ArrayList(); \nfor (int i=0; i &lt; 100; i++) &#123; \n    BasicDBObject bo = new BasicDBObject(); \n    bo.put(&quot;name&quot;, &quot;bruce&quot;); \n    bo.append(&quot;age&quot;, i); \n    datas.add(bo); \n&#125; \ncoll.insert(datas); \n</code></pre>\n<p>又如：</p>\n<pre><code>DBCollection coll = db.getCollection(&quot;testCollection&quot;);   \nfor(int i=1; i&lt;=100; i++) &#123;//插入100条记录   \n    User user = new User();   \n    user.setName(&quot;user_&quot;+i);  \n    user.setPoint(i);   \n    coll.insert(user);\n&#125;\n</code></pre>\n<blockquote>\n<p>正则表达式</p>\n</blockquote>\n<p>查询所有名字匹配 &#x2F;joh?n&#x2F;i 的记录</p>\n<pre><code>Pattern pattern = Pattern.compile(&quot;joh?n&quot;,CASE_INSENSITIVE); \nBasicDBObject query = new BasicDBObject(&quot;name&quot;, pattern); \nDBCursor cursor = coll.find(query);\n</code></pre>\n","excerpt":"<blockquote>\n<p>类转换</p>\n</blockquote>\n<p>当把一个类对象存到mongoDB后，从mongoDB取出来时使用setObjectClass()将其转换回原来的类。</p>\n<pre><code>public class Tweet implements DBObject &#123; \n    /* ... */ \n&#125; \nTweet myTweet = new Tweet(); \nmyTweet.put(&quot;user&quot;, &quot;bruce&quot;); \nmyTweet.put(&quot;message&quot;, &quot;fun&quot;); \nmyTweet.put(&quot;date&quot;, new Date()); \ncollection.insert(myTweet); \n//转换 \ncollection.setObjectClass(Tweet.class); \nTweet myTweet = (Tweet)collection.findOne(); \n</code></pre>","more":"<blockquote>\n<p>默认ID</p>\n</blockquote>\n<p>当保存的对象没有设置ID时，mongoDB会默认给该条记录设置一个ID（”_id”）。<br>当然你也可以设置自己指定的ID，如：(在mongoDB中执行用db.users.save({_id:1,name:’bruce’});)</p>\n<pre><code>BasicDBObject bo = new BasicDBObject();\nbo.put(&#39;_id&#39;, 1);\nbo.put(&#39;name&#39;, &#39;bruce&#39;);\ncollection.insert(bo);\n</code></pre>\n<blockquote>\n<p>权限</p>\n</blockquote>\n<p>判断是否有mongoDB的访问权限，有就返回true，否则返回false。</p>\n<pre><code>boolean auth = db.authenticate(myUserName, myPassword);\n</code></pre>\n<blockquote>\n<p>查看mongoDB数据库列表</p>\n</blockquote>\n<pre><code>Mongo m = new Mongo(); \nfor (String s : m.getDatabaseNames()) &#123; \n    System.out.println(s); \n&#125;\n</code></pre>\n<blockquote>\n<p>查看当前库下所有的表名，等于在mongoDB中执行showtables;</p>\n</blockquote>\n<pre><code>Set colls = db.getCollectionNames(); \nfor (String s : colls) &#123; \n    System.out.println(s); \n&#125;\n</code></pre>\n<blockquote>\n<p>查看一个表的索引</p>\n</blockquote>\n<pre><code>List list = coll.getIndexInfo(); \nfor (DBObject o : list) &#123; \n    System.out.println(o); \n&#125; \n</code></pre>\n<blockquote>\n<p>删除一个数据库</p>\n</blockquote>\n<pre><code>Mongo m = new Mongo(); \nm.dropDatabase(&quot;myDatabaseName&quot;);\n</code></pre>\n<blockquote>\n<p>建立mongoDB的链接</p>\n</blockquote>\n<pre><code>Mongo m = new Mongo(&quot;localhost&quot;, 27017); //有多个重载方法，可根据需要选择\nDB db = m.getDB(&quot;myDatabaseName&quot;); //相当于库名 \nDBCollection coll = db.getCollection(&quot;myUsersTable&quot;)；//相当于表名 \n</code></pre>\n<p>查询数据</p>\n<blockquote>\n<p>查询第一条记录</p>\n</blockquote>\n<pre><code>DBObject firstDoc = coll.findOne(); \n</code></pre>\n<p>findOne()返回一个记录，而find()返回的是DBCursor游标对象。</p>\n<blockquote>\n<p>查询全部数据</p>\n</blockquote>\n<pre><code>DBCursor cur = coll.find(); \nwhile(cur.hasNext()) &#123; \n    System.out.println(cur.next()); \n&#125;\n</code></pre>\n<blockquote>\n<p>查询记录数量</p>\n</blockquote>\n<pre><code>coll.find().count(); \ncoll.find(new BasicDBObject(&quot;age&quot;, 26)).count();\n</code></pre>\n<blockquote>\n<p>条件查询</p>\n</blockquote>\n<pre><code>BasicDBObject condition = new BasicDBObject(); \ncondition.put(&quot;name&quot;, &quot;bruce&quot;); \ncondition.put(&quot;age&quot;, 26); \ncoll.find(condition);\n</code></pre>\n<blockquote>\n<p>查询部分数据块</p>\n</blockquote>\n<pre><code>DBCursor cursor = coll.find().skip(0).limit(10); \nwhile(cursor.hasNext()) &#123; \n    System.out.println(cursor.next()); \n&#125; \n</code></pre>\n<blockquote>\n<p>比较查询(age &gt;50)</p>\n</blockquote>\n<pre><code>BasicDBObject condition = new BasicDBObject(); \ncondition.put(&quot;age&quot;, new BasicDBObject(&quot;$gt&quot;,50)); \ncoll.find(condition);\n</code></pre>\n<blockquote>\n<p>比较符</p>\n</blockquote>\n<pre><code>&quot;$gt&quot;： 大于\n&quot;$gte&quot;：大于等于\n&quot;$lt&quot;： 小于\n&quot;$lte&quot;：小于等于\n&quot;$in&quot;： 包含\n//以下条件查询20&lt;age&lt;=30\ncondition.put(&quot;age&quot;, new BasicDBObject(&quot;$gt&quot;,20).append(&quot;$lte&quot;, 30));\n</code></pre>\n<p>插入数据</p>\n<blockquote>\n<p>批量插入</p>\n</blockquote>\n<pre><code>List datas = new ArrayList(); \nfor (int i=0; i &lt; 100; i++) &#123; \n    BasicDBObject bo = new BasicDBObject(); \n    bo.put(&quot;name&quot;, &quot;bruce&quot;); \n    bo.append(&quot;age&quot;, i); \n    datas.add(bo); \n&#125; \ncoll.insert(datas); \n</code></pre>\n<p>又如：</p>\n<pre><code>DBCollection coll = db.getCollection(&quot;testCollection&quot;);   \nfor(int i=1; i&lt;=100; i++) &#123;//插入100条记录   \n    User user = new User();   \n    user.setName(&quot;user_&quot;+i);  \n    user.setPoint(i);   \n    coll.insert(user);\n&#125;\n</code></pre>\n<blockquote>\n<p>正则表达式</p>\n</blockquote>\n<p>查询所有名字匹配 &#x2F;joh?n&#x2F;i 的记录</p>\n<pre><code>Pattern pattern = Pattern.compile(&quot;joh?n&quot;,CASE_INSENSITIVE); \nBasicDBObject query = new BasicDBObject(&quot;name&quot;, pattern); \nDBCursor cursor = coll.find(query);\n</code></pre>"},{"title":"Redis命令总结","date":"2015-07-26T08:01:26.000Z","_content":"\n>Redis提供了丰富的命令（command）对数据库和各种数据类型进行操作，这些command可以在Linux终端使用。在编程时，比如使用Redis 的Java语言包，这些命令都有对应的方法，比如上面例子中使用的sadd方法，就是对集合操作中的SADD命令。下面将Redis提供的命令做一总结。\n\n<!--more-->\n\n1.连接操作相关的命令\n\n    quit：关闭连接（connection）\n    auth：简单密码认证\n\n2.对value操作的命令\n\n    exists(key)：确认一个key是否存在\n    del(key)：删除一个key\n    type(key)：返回值的类型\n    keys(pattern)：返回满足给定pattern的所有key\n    randomkey：随机返回key空间的一个key\n    rename(oldname, newname)：将key由oldname重命名为newname，若newname存在则删除  newname表示的key\n    dbsize：返回当前数据库中key的数目\n    expire：设定一个key的活动时间（s）\n    ttl：获得一个key的活动时间\n    select(index)：按索引查询\n    move(key, dbindex)：将当前数据库中的key转移到有dbindex索引的数据库\n    flushdb：删除当前选择数据库中的所有key\n    flushall：删除所有数据库中的所有key\n    \n3.对String操作的命令\n\n    set(key, value)：给数据库中名称为key的string赋予值value\n    get(key)：返回数据库中名称为key的string的value\n    getset(key, value)：给名称为key的string赋予上一次的value\n    mget(key1, key2,…, key N)：返回库中多个string（它们的名称为key1，key2…）的value\n    setnx(key, value)：如果不存在名称为key的string，则向库中添加string，名称为key，值为value\n    setex(key, time,value)：向库中添加string（名称为key，值为value）同时，设定过期时间time\n    mset(key1, value1, key2, value2,…key N, value N)：同时给多个string赋值，名称为keyi的string赋值valuei\n    msetnx(key1, value1, key2, value2,…key N, value N)：如果所有名称为keyi的string都不存在，则向库中添加string，名称keyi赋值为value i\n    incr(key)：名称为key的string增1操作\n    incrby(key, integer)：名称为key的string增加integer\n    decr(key)：名称为key的string减1操作\n    decrby(key, integer)：名称为key的string减少integer\n    append(key, value)：名称为key的string的值附加value\n    substr(key, start, end)：返回名称为key的string的value的子串\n    \n4.对List操作的命令\n\n    rpush(key, value)：在名称为key的list尾添加一个值为value的元素\n    lpush(key, value)：在名称为key的list头添加一个值为value的元素\n    llen(key)：返回名称为key的list的长度\n    lrange(key, start, end)：返回名称为key的list中start至end之间的元素（下标从0开始，下同）\n    ltrim(key, start, end)：截取名称为key的list，保留start至end之间的元素\n    lindex(key, index)：返回名称为key的list中index位置的元素\n    lset(key, index, value)：给名称为key的list中index位置的元素赋值为value\n    lrem(key, count, value)：删除count个名称为key的list中值为value的元素。count为0，删除所有值为value的元素，count>0从头至尾删除count个值为value的元素，count<0从尾到头删除|count|个值为value的元素。\n    lpop(key)：返回并删除名称为key的list中的首元素\n    rpop(key)：返回并删除名称为key的list中的尾元素\n    blpop(key1, key2,… key N, timeout)：lpop命令的block版本。即当timeout为0时，若遇到名称为keyi的list不存在或该list为空，则命令结束。如果timeout>0，则遇到上述情况时，等待timeout秒，如果问题没有解决，则对key i+1开始的list执行pop操作。\n    brpop(key1, key2,… key N, timeout)：rpop的block版本。参考上一命令。\n    rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部\n    \n5.对Set操作的命令\n\n    sadd(key, member)：向名称为key的set中添加元素member\n    srem(key, member) ：删除名称为key的set中的元素member\n    spop(key) ：随机返回并删除名称为key的set中一个元素\n    smove(srckey, dstkey, member) ：将member元素从名称为srckey的集合移到名称为dstkey的集合\n    scard(key) ：返回名称为key的set的基数\n    sismember(key, member) ：测试member是否是名称为key的set的元素\n    sinter(key1, key2,…key N) ：求交集\n    sinterstore(dstkey, key1, key2,…key N) ：求交集并将交集保存到dstkey的集合\n    sunion(key1, key2,…key N) ：求并集\n    sunionstore(dstkey, key1, key2,…key N) ：求并集并将并集保存到dstkey的集合\n    sdiff(key1, key2,…key N) ：求差集\n    sdiffstore(dstkey, key1, key2,…key N) ：求差集并将差集保存到dstkey的集合\n    smembers(key) ：返回名称为key的set的所有元素\n    srandmember(key) ：随机返回名称为key的set的一个元素\n    \n6.对zset（sorted set）操作的命令\n\n    zadd(key, score, member)：向名称为key的zset中添加元素member，score用于排序。如果该元素已经存在，则根据score更新该元素的顺序。\n    zrem(key, member) ：删除名称为key的zset中的元素member\n    zincrby(key, increment, member) ：如果在名称为key的zset中已经存在元素member，则该元素的score增加increment；否则向集合中添加该元素，其score的值为increment\n    zrank(key, member) ：返回名称为key的zset（元素已按score从小到大排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”\n    zrevrank(key, member) ：返回名称为key的zset（元素已按score从大到小排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”\n    zrange(key, start, end)：返回名称为key的zset（元素已按score从小到大排序）中的index从start到end的所有元素\n    zrevrange(key, start, end)：返回名称为key的zset（元素已按score从大到小排序）中的index从start到end的所有元素\n    zrangebyscore(key, min, max)：返回名称为key的zset中score>= min且score <= max的所有元素\n    zcard(key)：返回名称为key的zset的基数\n    zscore(key, element)：返回名称为key的zset中元素element的score\n    zremrangebyrank(key, min, max)：删除名称为key的zset中rank>= min且rank <= max的所有元素\n    zremrangebyscore(key, min, max) ：删除名称为key的zset中score>= min且score <= max的所有元素\n    zunionstore/ zinterstore(dstkeyN, key1,…,keyN, WEIGHTS w1,…wN, AGGREGATE SUM|MIN|MAX)：对N个zset求并集和交集，并将最后的集合保存在dstkeyN中。对于集合中每一个元素的score，在进行AGGREGATE运算前，都要乘以对于的WEIGHT参数。如果没有提供WEIGHT，默认为1。默认的AGGREGATE是SUM，即结果集合中元素的score是所有集合对应元素进行SUM运算的值，而MIN和MAX是指，结果集合中元素的score是所有集合对应元素中最小值和最大值。\n    \n7.对Hash操作的命令\n\n    hset(key, field, value)：向名称为key的hash中添加元素field<—>value\n    hget(key, field)：返回名称为key的hash中field对应的value\n    hmget(key, field1, …,field N)：返回名称为key的hash中fieldi对应的value\n    hmset(key, field1, value1,…,field N, value N)：向名称为key的hash中添加元素fieldi<—>value i\n    hincrby(key, field, integer)：将名称为key的hash中field的value增加integer\n    hexists(key, field)：名称为key的hash中是否存在键为field的域\n    hdel(key, field)：删除名称为key的hash中键为field的域\n    hlen(key)：返回名称为key的hash中元素个数\n    hkeys(key)：返回名称为key的hash中所有键\n    hvals(key)：返回名称为key的hash中所有键对应的value\n    hgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value\n    \n8.持久化\n\n    save：将数据同步保存到磁盘\n    bgsave：将数据异步保存到磁盘\n    lastsave：返回上次成功将数据保存到磁盘的Unix时戳\n    shundown：将数据同步保存到磁盘，然后关闭服务\n    \n9.远程服务控制\n\n    info：提供服务器的信息和统计\n    monitor：实时转储收到的请求\n    slaveof：改变复制策略设置\n    config：在运行时配置Redis服务器\n\n","source":"_posts/redis-command.md","raw":"title: Redis命令总结\ndate: 2015-07-26 16:01:26\ncategories: 技术\n---\n\n>Redis提供了丰富的命令（command）对数据库和各种数据类型进行操作，这些command可以在Linux终端使用。在编程时，比如使用Redis 的Java语言包，这些命令都有对应的方法，比如上面例子中使用的sadd方法，就是对集合操作中的SADD命令。下面将Redis提供的命令做一总结。\n\n<!--more-->\n\n1.连接操作相关的命令\n\n    quit：关闭连接（connection）\n    auth：简单密码认证\n\n2.对value操作的命令\n\n    exists(key)：确认一个key是否存在\n    del(key)：删除一个key\n    type(key)：返回值的类型\n    keys(pattern)：返回满足给定pattern的所有key\n    randomkey：随机返回key空间的一个key\n    rename(oldname, newname)：将key由oldname重命名为newname，若newname存在则删除  newname表示的key\n    dbsize：返回当前数据库中key的数目\n    expire：设定一个key的活动时间（s）\n    ttl：获得一个key的活动时间\n    select(index)：按索引查询\n    move(key, dbindex)：将当前数据库中的key转移到有dbindex索引的数据库\n    flushdb：删除当前选择数据库中的所有key\n    flushall：删除所有数据库中的所有key\n    \n3.对String操作的命令\n\n    set(key, value)：给数据库中名称为key的string赋予值value\n    get(key)：返回数据库中名称为key的string的value\n    getset(key, value)：给名称为key的string赋予上一次的value\n    mget(key1, key2,…, key N)：返回库中多个string（它们的名称为key1，key2…）的value\n    setnx(key, value)：如果不存在名称为key的string，则向库中添加string，名称为key，值为value\n    setex(key, time,value)：向库中添加string（名称为key，值为value）同时，设定过期时间time\n    mset(key1, value1, key2, value2,…key N, value N)：同时给多个string赋值，名称为keyi的string赋值valuei\n    msetnx(key1, value1, key2, value2,…key N, value N)：如果所有名称为keyi的string都不存在，则向库中添加string，名称keyi赋值为value i\n    incr(key)：名称为key的string增1操作\n    incrby(key, integer)：名称为key的string增加integer\n    decr(key)：名称为key的string减1操作\n    decrby(key, integer)：名称为key的string减少integer\n    append(key, value)：名称为key的string的值附加value\n    substr(key, start, end)：返回名称为key的string的value的子串\n    \n4.对List操作的命令\n\n    rpush(key, value)：在名称为key的list尾添加一个值为value的元素\n    lpush(key, value)：在名称为key的list头添加一个值为value的元素\n    llen(key)：返回名称为key的list的长度\n    lrange(key, start, end)：返回名称为key的list中start至end之间的元素（下标从0开始，下同）\n    ltrim(key, start, end)：截取名称为key的list，保留start至end之间的元素\n    lindex(key, index)：返回名称为key的list中index位置的元素\n    lset(key, index, value)：给名称为key的list中index位置的元素赋值为value\n    lrem(key, count, value)：删除count个名称为key的list中值为value的元素。count为0，删除所有值为value的元素，count>0从头至尾删除count个值为value的元素，count<0从尾到头删除|count|个值为value的元素。\n    lpop(key)：返回并删除名称为key的list中的首元素\n    rpop(key)：返回并删除名称为key的list中的尾元素\n    blpop(key1, key2,… key N, timeout)：lpop命令的block版本。即当timeout为0时，若遇到名称为keyi的list不存在或该list为空，则命令结束。如果timeout>0，则遇到上述情况时，等待timeout秒，如果问题没有解决，则对key i+1开始的list执行pop操作。\n    brpop(key1, key2,… key N, timeout)：rpop的block版本。参考上一命令。\n    rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部\n    \n5.对Set操作的命令\n\n    sadd(key, member)：向名称为key的set中添加元素member\n    srem(key, member) ：删除名称为key的set中的元素member\n    spop(key) ：随机返回并删除名称为key的set中一个元素\n    smove(srckey, dstkey, member) ：将member元素从名称为srckey的集合移到名称为dstkey的集合\n    scard(key) ：返回名称为key的set的基数\n    sismember(key, member) ：测试member是否是名称为key的set的元素\n    sinter(key1, key2,…key N) ：求交集\n    sinterstore(dstkey, key1, key2,…key N) ：求交集并将交集保存到dstkey的集合\n    sunion(key1, key2,…key N) ：求并集\n    sunionstore(dstkey, key1, key2,…key N) ：求并集并将并集保存到dstkey的集合\n    sdiff(key1, key2,…key N) ：求差集\n    sdiffstore(dstkey, key1, key2,…key N) ：求差集并将差集保存到dstkey的集合\n    smembers(key) ：返回名称为key的set的所有元素\n    srandmember(key) ：随机返回名称为key的set的一个元素\n    \n6.对zset（sorted set）操作的命令\n\n    zadd(key, score, member)：向名称为key的zset中添加元素member，score用于排序。如果该元素已经存在，则根据score更新该元素的顺序。\n    zrem(key, member) ：删除名称为key的zset中的元素member\n    zincrby(key, increment, member) ：如果在名称为key的zset中已经存在元素member，则该元素的score增加increment；否则向集合中添加该元素，其score的值为increment\n    zrank(key, member) ：返回名称为key的zset（元素已按score从小到大排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”\n    zrevrank(key, member) ：返回名称为key的zset（元素已按score从大到小排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”\n    zrange(key, start, end)：返回名称为key的zset（元素已按score从小到大排序）中的index从start到end的所有元素\n    zrevrange(key, start, end)：返回名称为key的zset（元素已按score从大到小排序）中的index从start到end的所有元素\n    zrangebyscore(key, min, max)：返回名称为key的zset中score>= min且score <= max的所有元素\n    zcard(key)：返回名称为key的zset的基数\n    zscore(key, element)：返回名称为key的zset中元素element的score\n    zremrangebyrank(key, min, max)：删除名称为key的zset中rank>= min且rank <= max的所有元素\n    zremrangebyscore(key, min, max) ：删除名称为key的zset中score>= min且score <= max的所有元素\n    zunionstore/ zinterstore(dstkeyN, key1,…,keyN, WEIGHTS w1,…wN, AGGREGATE SUM|MIN|MAX)：对N个zset求并集和交集，并将最后的集合保存在dstkeyN中。对于集合中每一个元素的score，在进行AGGREGATE运算前，都要乘以对于的WEIGHT参数。如果没有提供WEIGHT，默认为1。默认的AGGREGATE是SUM，即结果集合中元素的score是所有集合对应元素进行SUM运算的值，而MIN和MAX是指，结果集合中元素的score是所有集合对应元素中最小值和最大值。\n    \n7.对Hash操作的命令\n\n    hset(key, field, value)：向名称为key的hash中添加元素field<—>value\n    hget(key, field)：返回名称为key的hash中field对应的value\n    hmget(key, field1, …,field N)：返回名称为key的hash中fieldi对应的value\n    hmset(key, field1, value1,…,field N, value N)：向名称为key的hash中添加元素fieldi<—>value i\n    hincrby(key, field, integer)：将名称为key的hash中field的value增加integer\n    hexists(key, field)：名称为key的hash中是否存在键为field的域\n    hdel(key, field)：删除名称为key的hash中键为field的域\n    hlen(key)：返回名称为key的hash中元素个数\n    hkeys(key)：返回名称为key的hash中所有键\n    hvals(key)：返回名称为key的hash中所有键对应的value\n    hgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value\n    \n8.持久化\n\n    save：将数据同步保存到磁盘\n    bgsave：将数据异步保存到磁盘\n    lastsave：返回上次成功将数据保存到磁盘的Unix时戳\n    shundown：将数据同步保存到磁盘，然后关闭服务\n    \n9.远程服务控制\n\n    info：提供服务器的信息和统计\n    monitor：实时转储收到的请求\n    slaveof：改变复制策略设置\n    config：在运行时配置Redis服务器\n\n","slug":"redis-command","published":1,"updated":"2024-04-11T13:25:35.639Z","comments":1,"layout":"post","photos":[],"_id":"cluvablv10006cbiheli8eln7","content":"<blockquote>\n<p>Redis提供了丰富的命令（command）对数据库和各种数据类型进行操作，这些command可以在Linux终端使用。在编程时，比如使用Redis 的Java语言包，这些命令都有对应的方法，比如上面例子中使用的sadd方法，就是对集合操作中的SADD命令。下面将Redis提供的命令做一总结。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>1.连接操作相关的命令</p>\n<pre><code>quit：关闭连接（connection）\nauth：简单密码认证\n</code></pre>\n<p>2.对value操作的命令</p>\n<pre><code>exists(key)：确认一个key是否存在\ndel(key)：删除一个key\ntype(key)：返回值的类型\nkeys(pattern)：返回满足给定pattern的所有key\nrandomkey：随机返回key空间的一个key\nrename(oldname, newname)：将key由oldname重命名为newname，若newname存在则删除  newname表示的key\ndbsize：返回当前数据库中key的数目\nexpire：设定一个key的活动时间（s）\nttl：获得一个key的活动时间\nselect(index)：按索引查询\nmove(key, dbindex)：将当前数据库中的key转移到有dbindex索引的数据库\nflushdb：删除当前选择数据库中的所有key\nflushall：删除所有数据库中的所有key\n</code></pre>\n<p>3.对String操作的命令</p>\n<pre><code>set(key, value)：给数据库中名称为key的string赋予值value\nget(key)：返回数据库中名称为key的string的value\ngetset(key, value)：给名称为key的string赋予上一次的value\nmget(key1, key2,…, key N)：返回库中多个string（它们的名称为key1，key2…）的value\nsetnx(key, value)：如果不存在名称为key的string，则向库中添加string，名称为key，值为value\nsetex(key, time,value)：向库中添加string（名称为key，值为value）同时，设定过期时间time\nmset(key1, value1, key2, value2,…key N, value N)：同时给多个string赋值，名称为keyi的string赋值valuei\nmsetnx(key1, value1, key2, value2,…key N, value N)：如果所有名称为keyi的string都不存在，则向库中添加string，名称keyi赋值为value i\nincr(key)：名称为key的string增1操作\nincrby(key, integer)：名称为key的string增加integer\ndecr(key)：名称为key的string减1操作\ndecrby(key, integer)：名称为key的string减少integer\nappend(key, value)：名称为key的string的值附加value\nsubstr(key, start, end)：返回名称为key的string的value的子串\n</code></pre>\n<p>4.对List操作的命令</p>\n<pre><code>rpush(key, value)：在名称为key的list尾添加一个值为value的元素\nlpush(key, value)：在名称为key的list头添加一个值为value的元素\nllen(key)：返回名称为key的list的长度\nlrange(key, start, end)：返回名称为key的list中start至end之间的元素（下标从0开始，下同）\nltrim(key, start, end)：截取名称为key的list，保留start至end之间的元素\nlindex(key, index)：返回名称为key的list中index位置的元素\nlset(key, index, value)：给名称为key的list中index位置的元素赋值为value\nlrem(key, count, value)：删除count个名称为key的list中值为value的元素。count为0，删除所有值为value的元素，count&gt;0从头至尾删除count个值为value的元素，count&lt;0从尾到头删除|count|个值为value的元素。\nlpop(key)：返回并删除名称为key的list中的首元素\nrpop(key)：返回并删除名称为key的list中的尾元素\nblpop(key1, key2,… key N, timeout)：lpop命令的block版本。即当timeout为0时，若遇到名称为keyi的list不存在或该list为空，则命令结束。如果timeout&gt;0，则遇到上述情况时，等待timeout秒，如果问题没有解决，则对key i+1开始的list执行pop操作。\nbrpop(key1, key2,… key N, timeout)：rpop的block版本。参考上一命令。\nrpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部\n</code></pre>\n<p>5.对Set操作的命令</p>\n<pre><code>sadd(key, member)：向名称为key的set中添加元素member\nsrem(key, member) ：删除名称为key的set中的元素member\nspop(key) ：随机返回并删除名称为key的set中一个元素\nsmove(srckey, dstkey, member) ：将member元素从名称为srckey的集合移到名称为dstkey的集合\nscard(key) ：返回名称为key的set的基数\nsismember(key, member) ：测试member是否是名称为key的set的元素\nsinter(key1, key2,…key N) ：求交集\nsinterstore(dstkey, key1, key2,…key N) ：求交集并将交集保存到dstkey的集合\nsunion(key1, key2,…key N) ：求并集\nsunionstore(dstkey, key1, key2,…key N) ：求并集并将并集保存到dstkey的集合\nsdiff(key1, key2,…key N) ：求差集\nsdiffstore(dstkey, key1, key2,…key N) ：求差集并将差集保存到dstkey的集合\nsmembers(key) ：返回名称为key的set的所有元素\nsrandmember(key) ：随机返回名称为key的set的一个元素\n</code></pre>\n<p>6.对zset（sorted set）操作的命令</p>\n<pre><code>zadd(key, score, member)：向名称为key的zset中添加元素member，score用于排序。如果该元素已经存在，则根据score更新该元素的顺序。\nzrem(key, member) ：删除名称为key的zset中的元素member\nzincrby(key, increment, member) ：如果在名称为key的zset中已经存在元素member，则该元素的score增加increment；否则向集合中添加该元素，其score的值为increment\nzrank(key, member) ：返回名称为key的zset（元素已按score从小到大排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”\nzrevrank(key, member) ：返回名称为key的zset（元素已按score从大到小排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”\nzrange(key, start, end)：返回名称为key的zset（元素已按score从小到大排序）中的index从start到end的所有元素\nzrevrange(key, start, end)：返回名称为key的zset（元素已按score从大到小排序）中的index从start到end的所有元素\nzrangebyscore(key, min, max)：返回名称为key的zset中score&gt;= min且score &lt;= max的所有元素\nzcard(key)：返回名称为key的zset的基数\nzscore(key, element)：返回名称为key的zset中元素element的score\nzremrangebyrank(key, min, max)：删除名称为key的zset中rank&gt;= min且rank &lt;= max的所有元素\nzremrangebyscore(key, min, max) ：删除名称为key的zset中score&gt;= min且score &lt;= max的所有元素\nzunionstore/ zinterstore(dstkeyN, key1,…,keyN, WEIGHTS w1,…wN, AGGREGATE SUM|MIN|MAX)：对N个zset求并集和交集，并将最后的集合保存在dstkeyN中。对于集合中每一个元素的score，在进行AGGREGATE运算前，都要乘以对于的WEIGHT参数。如果没有提供WEIGHT，默认为1。默认的AGGREGATE是SUM，即结果集合中元素的score是所有集合对应元素进行SUM运算的值，而MIN和MAX是指，结果集合中元素的score是所有集合对应元素中最小值和最大值。\n</code></pre>\n<p>7.对Hash操作的命令</p>\n<pre><code>hset(key, field, value)：向名称为key的hash中添加元素field&lt;—&gt;value\nhget(key, field)：返回名称为key的hash中field对应的value\nhmget(key, field1, …,field N)：返回名称为key的hash中fieldi对应的value\nhmset(key, field1, value1,…,field N, value N)：向名称为key的hash中添加元素fieldi&lt;—&gt;value i\nhincrby(key, field, integer)：将名称为key的hash中field的value增加integer\nhexists(key, field)：名称为key的hash中是否存在键为field的域\nhdel(key, field)：删除名称为key的hash中键为field的域\nhlen(key)：返回名称为key的hash中元素个数\nhkeys(key)：返回名称为key的hash中所有键\nhvals(key)：返回名称为key的hash中所有键对应的value\nhgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value\n</code></pre>\n<p>8.持久化</p>\n<pre><code>save：将数据同步保存到磁盘\nbgsave：将数据异步保存到磁盘\nlastsave：返回上次成功将数据保存到磁盘的Unix时戳\nshundown：将数据同步保存到磁盘，然后关闭服务\n</code></pre>\n<p>9.远程服务控制</p>\n<pre><code>info：提供服务器的信息和统计\nmonitor：实时转储收到的请求\nslaveof：改变复制策略设置\nconfig：在运行时配置Redis服务器\n</code></pre>\n","excerpt":"<blockquote>\n<p>Redis提供了丰富的命令（command）对数据库和各种数据类型进行操作，这些command可以在Linux终端使用。在编程时，比如使用Redis 的Java语言包，这些命令都有对应的方法，比如上面例子中使用的sadd方法，就是对集合操作中的SADD命令。下面将Redis提供的命令做一总结。</p>\n</blockquote>","more":"<p>1.连接操作相关的命令</p>\n<pre><code>quit：关闭连接（connection）\nauth：简单密码认证\n</code></pre>\n<p>2.对value操作的命令</p>\n<pre><code>exists(key)：确认一个key是否存在\ndel(key)：删除一个key\ntype(key)：返回值的类型\nkeys(pattern)：返回满足给定pattern的所有key\nrandomkey：随机返回key空间的一个key\nrename(oldname, newname)：将key由oldname重命名为newname，若newname存在则删除  newname表示的key\ndbsize：返回当前数据库中key的数目\nexpire：设定一个key的活动时间（s）\nttl：获得一个key的活动时间\nselect(index)：按索引查询\nmove(key, dbindex)：将当前数据库中的key转移到有dbindex索引的数据库\nflushdb：删除当前选择数据库中的所有key\nflushall：删除所有数据库中的所有key\n</code></pre>\n<p>3.对String操作的命令</p>\n<pre><code>set(key, value)：给数据库中名称为key的string赋予值value\nget(key)：返回数据库中名称为key的string的value\ngetset(key, value)：给名称为key的string赋予上一次的value\nmget(key1, key2,…, key N)：返回库中多个string（它们的名称为key1，key2…）的value\nsetnx(key, value)：如果不存在名称为key的string，则向库中添加string，名称为key，值为value\nsetex(key, time,value)：向库中添加string（名称为key，值为value）同时，设定过期时间time\nmset(key1, value1, key2, value2,…key N, value N)：同时给多个string赋值，名称为keyi的string赋值valuei\nmsetnx(key1, value1, key2, value2,…key N, value N)：如果所有名称为keyi的string都不存在，则向库中添加string，名称keyi赋值为value i\nincr(key)：名称为key的string增1操作\nincrby(key, integer)：名称为key的string增加integer\ndecr(key)：名称为key的string减1操作\ndecrby(key, integer)：名称为key的string减少integer\nappend(key, value)：名称为key的string的值附加value\nsubstr(key, start, end)：返回名称为key的string的value的子串\n</code></pre>\n<p>4.对List操作的命令</p>\n<pre><code>rpush(key, value)：在名称为key的list尾添加一个值为value的元素\nlpush(key, value)：在名称为key的list头添加一个值为value的元素\nllen(key)：返回名称为key的list的长度\nlrange(key, start, end)：返回名称为key的list中start至end之间的元素（下标从0开始，下同）\nltrim(key, start, end)：截取名称为key的list，保留start至end之间的元素\nlindex(key, index)：返回名称为key的list中index位置的元素\nlset(key, index, value)：给名称为key的list中index位置的元素赋值为value\nlrem(key, count, value)：删除count个名称为key的list中值为value的元素。count为0，删除所有值为value的元素，count&gt;0从头至尾删除count个值为value的元素，count&lt;0从尾到头删除|count|个值为value的元素。\nlpop(key)：返回并删除名称为key的list中的首元素\nrpop(key)：返回并删除名称为key的list中的尾元素\nblpop(key1, key2,… key N, timeout)：lpop命令的block版本。即当timeout为0时，若遇到名称为keyi的list不存在或该list为空，则命令结束。如果timeout&gt;0，则遇到上述情况时，等待timeout秒，如果问题没有解决，则对key i+1开始的list执行pop操作。\nbrpop(key1, key2,… key N, timeout)：rpop的block版本。参考上一命令。\nrpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部\n</code></pre>\n<p>5.对Set操作的命令</p>\n<pre><code>sadd(key, member)：向名称为key的set中添加元素member\nsrem(key, member) ：删除名称为key的set中的元素member\nspop(key) ：随机返回并删除名称为key的set中一个元素\nsmove(srckey, dstkey, member) ：将member元素从名称为srckey的集合移到名称为dstkey的集合\nscard(key) ：返回名称为key的set的基数\nsismember(key, member) ：测试member是否是名称为key的set的元素\nsinter(key1, key2,…key N) ：求交集\nsinterstore(dstkey, key1, key2,…key N) ：求交集并将交集保存到dstkey的集合\nsunion(key1, key2,…key N) ：求并集\nsunionstore(dstkey, key1, key2,…key N) ：求并集并将并集保存到dstkey的集合\nsdiff(key1, key2,…key N) ：求差集\nsdiffstore(dstkey, key1, key2,…key N) ：求差集并将差集保存到dstkey的集合\nsmembers(key) ：返回名称为key的set的所有元素\nsrandmember(key) ：随机返回名称为key的set的一个元素\n</code></pre>\n<p>6.对zset（sorted set）操作的命令</p>\n<pre><code>zadd(key, score, member)：向名称为key的zset中添加元素member，score用于排序。如果该元素已经存在，则根据score更新该元素的顺序。\nzrem(key, member) ：删除名称为key的zset中的元素member\nzincrby(key, increment, member) ：如果在名称为key的zset中已经存在元素member，则该元素的score增加increment；否则向集合中添加该元素，其score的值为increment\nzrank(key, member) ：返回名称为key的zset（元素已按score从小到大排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”\nzrevrank(key, member) ：返回名称为key的zset（元素已按score从大到小排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”\nzrange(key, start, end)：返回名称为key的zset（元素已按score从小到大排序）中的index从start到end的所有元素\nzrevrange(key, start, end)：返回名称为key的zset（元素已按score从大到小排序）中的index从start到end的所有元素\nzrangebyscore(key, min, max)：返回名称为key的zset中score&gt;= min且score &lt;= max的所有元素\nzcard(key)：返回名称为key的zset的基数\nzscore(key, element)：返回名称为key的zset中元素element的score\nzremrangebyrank(key, min, max)：删除名称为key的zset中rank&gt;= min且rank &lt;= max的所有元素\nzremrangebyscore(key, min, max) ：删除名称为key的zset中score&gt;= min且score &lt;= max的所有元素\nzunionstore/ zinterstore(dstkeyN, key1,…,keyN, WEIGHTS w1,…wN, AGGREGATE SUM|MIN|MAX)：对N个zset求并集和交集，并将最后的集合保存在dstkeyN中。对于集合中每一个元素的score，在进行AGGREGATE运算前，都要乘以对于的WEIGHT参数。如果没有提供WEIGHT，默认为1。默认的AGGREGATE是SUM，即结果集合中元素的score是所有集合对应元素进行SUM运算的值，而MIN和MAX是指，结果集合中元素的score是所有集合对应元素中最小值和最大值。\n</code></pre>\n<p>7.对Hash操作的命令</p>\n<pre><code>hset(key, field, value)：向名称为key的hash中添加元素field&lt;—&gt;value\nhget(key, field)：返回名称为key的hash中field对应的value\nhmget(key, field1, …,field N)：返回名称为key的hash中fieldi对应的value\nhmset(key, field1, value1,…,field N, value N)：向名称为key的hash中添加元素fieldi&lt;—&gt;value i\nhincrby(key, field, integer)：将名称为key的hash中field的value增加integer\nhexists(key, field)：名称为key的hash中是否存在键为field的域\nhdel(key, field)：删除名称为key的hash中键为field的域\nhlen(key)：返回名称为key的hash中元素个数\nhkeys(key)：返回名称为key的hash中所有键\nhvals(key)：返回名称为key的hash中所有键对应的value\nhgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value\n</code></pre>\n<p>8.持久化</p>\n<pre><code>save：将数据同步保存到磁盘\nbgsave：将数据异步保存到磁盘\nlastsave：返回上次成功将数据保存到磁盘的Unix时戳\nshundown：将数据同步保存到磁盘，然后关闭服务\n</code></pre>\n<p>9.远程服务控制</p>\n<pre><code>info：提供服务器的信息和统计\nmonitor：实时转储收到的请求\nslaveof：改变复制策略设置\nconfig：在运行时配置Redis服务器\n</code></pre>"},{"title":"Redis系列-存储篇list操作","date":"2015-07-24T05:45:53.000Z","_content":"\nlist相关概念\n* 列表：一个从左到右的队列，类似于一个栈，常规模式下，先进列表的元素，后出。\n* 表头元素：列表最左端第一个元素。\n* 表尾元素：列表最右端的最后一个元素。不包含任何元素的列表成为空列表。\n\n<!--more-->\n\n1.新增\n---\n>lpush\n>语法：lpush key value[value]\n\n解释：把一个或多个元素插入表头。如果是多个value时，按照从左到右的次序插。返回插入元素的个数\n\n    [root@xsf001 ~]# redis-cli  \n    redis 127.0.0.1:6379> lpush lst.user zhangsan   #插入一个元素  \n    (integer) 1  \n    redis 127.0.0.1:6379> lpush lst.user zhangsan lisi   #插入多个元素，list中允许插入重复的元素  \n    (integer) 3 \n    \n\n>lpushx\n>语法：lpushx key value\n\n解释：插入一个表头元素，当且仅当列表key存在时，才能插入。返回列表中元素的个数\n\n    redis 127.0.0.1:6379> lpushx lst.user wangwu   #列表存在  \n    (integer) 4  \n    redis 127.0.0.1:6379> lpushx lst.tech wangwu   #列表不存在，不插入  \n    (integer) 0 \n    \n\n>rpush\n>语法：rpush key [value]\n\n解释：将一个或多个值插入到队列的队尾。多值时，从左到右依次添加。返回列表中元素个数\n\n    redis 127.0.0.1:6379> rpush lst.user ls005     #列表存在  \n    (integer) 5  \n    redis 127.0.0.1:6379> rpush lst.tech tec01 tec02 tec03  #列表不存在  \n    (integer) 3 \n    \n\n>rpushx\n>语法：rpushx key value\n\n解释：讲值插入到列表队尾，当且仅当列表key存在时，才添加。返回列表元素个数\n\n    redis 127.0.0.1:6379> rpushx lst.tech tec04  #key 存在  \n    (integer) 4  \n    redis 127.0.0.1:6379> rpushx lst.sub englist #key 不存在  \n    (integer) 0\n    \n\n>linsert\n>语法：linsert key before|after pivot value\n\n解释：将值插入到pivot的前面或后面。返回列表元素个数。如果参照点pivot不存在不插入。如果有多个pivot，以离表头最近的为准\n\n    redis 127.0.0.1:6379> linsert lst.tech after tec04 tec06  #后面插  \n    (integer) 5   \n    redis 127.0.0.1:6379> linsert lst.tech before tec06 tec05 #前面插  \n    (integer) 6   \n    redis 127.0.0.1:6379> linsert lst.tech before tec08 tec07 #参照点不存在，不插  \n    (integer) -1  \n    redis 127.0.0.1:6379> linsert lst.user after zhangsan zhangsan01  #列表中有多个pivot，以从左到右的第一个为准  \n    (integer) 6\n    \n\n2.查询\n---\n>lindex\n>语法：lindex key index\n\n解释：通过索引index获取列表的元素。 index>=0时， 0 表头，1 第二个元素，依次类推；index<0时，-1，表尾，-2倒数第二个元素，依次类推\n\n    redis 127.0.0.1:6379> lindex lst.user 0  #表头  \n    \"wangwu\"   \n    redis 127.0.0.1:6379> lindex lst.user -1 #表尾  \n    \"ls005\"  \n    redis 127.0.0.1:6379> lindex lst.user 2 #第三个元素  \n    \"zhangsan\"  \n    redis 127.0.0.1:6379> lindex lst.user -2 #倒数第二个元素  \n    \"zhangsan\" \n\n>lrange\n>语法：lrange key start stop\n\n解释：获取指定开始和结束范围的一些列元素。0：表头，-1：表尾。如果stop指定的元素在start的左边，返回空列表\n\n    redis 127.0.0.1:6379> lrange lst.user 0 -1 #返回所有  \n    1) \"wangwu\"  \n    2) \"lisi\"  \n    3) \"zhangsan\"  \n    4) \"zhangsan01\"  \n    5) \"zhangsan\"  \n    6) \"ls005\"  \n    redis 127.0.0.1:6379> lrange lst.user -1 0  #返回空  \n    (empty list or set)  \n    redis 127.0.0.1:6379> lrange lst.user 1 2  #返回多个  \n    1) \"lisi\"  \n    2) \"zhangsan\"  \n    redis 127.0.0.1:6379> lrange lst.user 1 1   #返回一个元素  \n    1) \"lisi\"\n    \n\n3.修改\n---\n>lset\n>语法：lset key index value\n\n解释：设置列表指定索引的值，如果指定索引不存在则报错\n\n    redis 127.0.0.1:6379> lset lst.user 2 zhangsan1  #设置第三个元素为zhangsan1  \n    OK  \n    redis 127.0.0.1:6379> lrange lst.user 0 -1  \n    1) \"wangwu\"  \n    2) \"lisi\"  \n    3) \"zhangsan1\"  \n    4) \"zhangsan01\"  \n    5) \"zhangsan\"  \n    6) \"ls005\"  \n    redis 127.0.0.1:6379> lset lst.user 6 ls006  #指定索引不存在  \n    (error) ERR index out of range\n    \n\n4.删除\n---\n>ltrim\n>语法：ltrim key start stop\n\n解释：保留指定区域的元素，其他元素全部删除\n\n    redis 127.0.0.1:6379> ltrim lst.user 0 -2  \n    OK  \n    redis 127.0.0.1:6379> lrange lst.user 0 -1  \n    1) \"wangwu\"  \n    2) \"lisi\"  \n    3) \"zhangsan1\"  \n    4) \"zhangsan01\"  \n    5) \"zhangsan\"\n    \n\n>lrem\n>语法：lrem key count value\n\n解释：移除等于value的元素，当count>0时，从表头开始查找，移除count个；当count=0时，从表头开始查找，移除所有等于value的；当count<0时，从表尾开始查找，移除|count| 个。\n\n    redis 127.0.0.1:6379> lrange lst.user 0 -1  \n    1) \"zhangsan\"  \n    2) \"wangwu\"  \n    3) \"lisi\"  \n    4) \"zhangsan1\"  \n    5) \"zhangsan01\"  \n    6) \"zhangsan\"  \n    7) \"lisi\"  \n    8) \"zhangsan\"  \n    9) \"lisi\"  \n    10) \"zhangsan\"  \n    redis 127.0.0.1:6379> lrem lst.user 2 zhangsan #移除前两个zhangsan  \n    (integer) 2  \n    redis 127.0.0.1:6379> lrange lst.user 0 -1  \n    1) \"wangwu\"  \n    2) \"lisi\"  \n    3) \"zhangsan1\"  \n    4) \"zhangsan01\"  \n    5) \"lisi\"  \n    6) \"zhangsan\"  \n    7) \"lisi\"  \n    8) \"zhangsan\"  \n    redis 127.0.0.1:6379> lrange lst.user -1 zhangsan #移除最后一个zhangsan  \n    (empty list or set)  \n    redis 127.0.0.1:6379> lrange lst.user 0 -1  \n    1) \"wangwu\"  \n    2) \"lisi\"  \n    3) \"zhangsan1\"  \n    4) \"zhangsan01\"  \n    5) \"lisi\"  \n    6) \"zhangsan\"  \n    7) \"lisi\"  \n    redis 127.0.0.1:6379> lrem lst.user 0 lisi  #移除所有lisi  \n    (integer) 3  \n    redis 127.0.0.1:6379> lrange lst.user 0 -1  \n    1) \"wangwu\"  \n    2) \"zhangsan1\"  \n    3) \"zhangsan01\"  \n    4) \"zhangsan\"  \n    redis 127.0.0.1:6379> \n    \n\n>rpop\n>语法：rpop key\n\n解释：移除并返回表尾元素\n\n    redis 127.0.0.1:6379> rpop lst.user  \n    \"zhangsan\"\n    \n\n>lpop\n>语法：lpop key \n\n解释：移除并返回表尾元素\n    \n    redis 127.0.0.1:6379> lpop lst.user  \n    \"wangwu\"\n    \n\n5.其他\n---\n>llen\n>语法：llen key\n\n解释：获取列表长度\n\n    redis 127.0.0.1:6379> llen lst.user  \n    (integer) 2\n\n","source":"_posts/redis-list.md","raw":"title: Redis系列-存储篇list操作\ndate: 2015-07-24 13:45:53\ncategories: 技术\n---\n\nlist相关概念\n* 列表：一个从左到右的队列，类似于一个栈，常规模式下，先进列表的元素，后出。\n* 表头元素：列表最左端第一个元素。\n* 表尾元素：列表最右端的最后一个元素。不包含任何元素的列表成为空列表。\n\n<!--more-->\n\n1.新增\n---\n>lpush\n>语法：lpush key value[value]\n\n解释：把一个或多个元素插入表头。如果是多个value时，按照从左到右的次序插。返回插入元素的个数\n\n    [root@xsf001 ~]# redis-cli  \n    redis 127.0.0.1:6379> lpush lst.user zhangsan   #插入一个元素  \n    (integer) 1  \n    redis 127.0.0.1:6379> lpush lst.user zhangsan lisi   #插入多个元素，list中允许插入重复的元素  \n    (integer) 3 \n    \n\n>lpushx\n>语法：lpushx key value\n\n解释：插入一个表头元素，当且仅当列表key存在时，才能插入。返回列表中元素的个数\n\n    redis 127.0.0.1:6379> lpushx lst.user wangwu   #列表存在  \n    (integer) 4  \n    redis 127.0.0.1:6379> lpushx lst.tech wangwu   #列表不存在，不插入  \n    (integer) 0 \n    \n\n>rpush\n>语法：rpush key [value]\n\n解释：将一个或多个值插入到队列的队尾。多值时，从左到右依次添加。返回列表中元素个数\n\n    redis 127.0.0.1:6379> rpush lst.user ls005     #列表存在  \n    (integer) 5  \n    redis 127.0.0.1:6379> rpush lst.tech tec01 tec02 tec03  #列表不存在  \n    (integer) 3 \n    \n\n>rpushx\n>语法：rpushx key value\n\n解释：讲值插入到列表队尾，当且仅当列表key存在时，才添加。返回列表元素个数\n\n    redis 127.0.0.1:6379> rpushx lst.tech tec04  #key 存在  \n    (integer) 4  \n    redis 127.0.0.1:6379> rpushx lst.sub englist #key 不存在  \n    (integer) 0\n    \n\n>linsert\n>语法：linsert key before|after pivot value\n\n解释：将值插入到pivot的前面或后面。返回列表元素个数。如果参照点pivot不存在不插入。如果有多个pivot，以离表头最近的为准\n\n    redis 127.0.0.1:6379> linsert lst.tech after tec04 tec06  #后面插  \n    (integer) 5   \n    redis 127.0.0.1:6379> linsert lst.tech before tec06 tec05 #前面插  \n    (integer) 6   \n    redis 127.0.0.1:6379> linsert lst.tech before tec08 tec07 #参照点不存在，不插  \n    (integer) -1  \n    redis 127.0.0.1:6379> linsert lst.user after zhangsan zhangsan01  #列表中有多个pivot，以从左到右的第一个为准  \n    (integer) 6\n    \n\n2.查询\n---\n>lindex\n>语法：lindex key index\n\n解释：通过索引index获取列表的元素。 index>=0时， 0 表头，1 第二个元素，依次类推；index<0时，-1，表尾，-2倒数第二个元素，依次类推\n\n    redis 127.0.0.1:6379> lindex lst.user 0  #表头  \n    \"wangwu\"   \n    redis 127.0.0.1:6379> lindex lst.user -1 #表尾  \n    \"ls005\"  \n    redis 127.0.0.1:6379> lindex lst.user 2 #第三个元素  \n    \"zhangsan\"  \n    redis 127.0.0.1:6379> lindex lst.user -2 #倒数第二个元素  \n    \"zhangsan\" \n\n>lrange\n>语法：lrange key start stop\n\n解释：获取指定开始和结束范围的一些列元素。0：表头，-1：表尾。如果stop指定的元素在start的左边，返回空列表\n\n    redis 127.0.0.1:6379> lrange lst.user 0 -1 #返回所有  \n    1) \"wangwu\"  \n    2) \"lisi\"  \n    3) \"zhangsan\"  \n    4) \"zhangsan01\"  \n    5) \"zhangsan\"  \n    6) \"ls005\"  \n    redis 127.0.0.1:6379> lrange lst.user -1 0  #返回空  \n    (empty list or set)  \n    redis 127.0.0.1:6379> lrange lst.user 1 2  #返回多个  \n    1) \"lisi\"  \n    2) \"zhangsan\"  \n    redis 127.0.0.1:6379> lrange lst.user 1 1   #返回一个元素  \n    1) \"lisi\"\n    \n\n3.修改\n---\n>lset\n>语法：lset key index value\n\n解释：设置列表指定索引的值，如果指定索引不存在则报错\n\n    redis 127.0.0.1:6379> lset lst.user 2 zhangsan1  #设置第三个元素为zhangsan1  \n    OK  \n    redis 127.0.0.1:6379> lrange lst.user 0 -1  \n    1) \"wangwu\"  \n    2) \"lisi\"  \n    3) \"zhangsan1\"  \n    4) \"zhangsan01\"  \n    5) \"zhangsan\"  \n    6) \"ls005\"  \n    redis 127.0.0.1:6379> lset lst.user 6 ls006  #指定索引不存在  \n    (error) ERR index out of range\n    \n\n4.删除\n---\n>ltrim\n>语法：ltrim key start stop\n\n解释：保留指定区域的元素，其他元素全部删除\n\n    redis 127.0.0.1:6379> ltrim lst.user 0 -2  \n    OK  \n    redis 127.0.0.1:6379> lrange lst.user 0 -1  \n    1) \"wangwu\"  \n    2) \"lisi\"  \n    3) \"zhangsan1\"  \n    4) \"zhangsan01\"  \n    5) \"zhangsan\"\n    \n\n>lrem\n>语法：lrem key count value\n\n解释：移除等于value的元素，当count>0时，从表头开始查找，移除count个；当count=0时，从表头开始查找，移除所有等于value的；当count<0时，从表尾开始查找，移除|count| 个。\n\n    redis 127.0.0.1:6379> lrange lst.user 0 -1  \n    1) \"zhangsan\"  \n    2) \"wangwu\"  \n    3) \"lisi\"  \n    4) \"zhangsan1\"  \n    5) \"zhangsan01\"  \n    6) \"zhangsan\"  \n    7) \"lisi\"  \n    8) \"zhangsan\"  \n    9) \"lisi\"  \n    10) \"zhangsan\"  \n    redis 127.0.0.1:6379> lrem lst.user 2 zhangsan #移除前两个zhangsan  \n    (integer) 2  \n    redis 127.0.0.1:6379> lrange lst.user 0 -1  \n    1) \"wangwu\"  \n    2) \"lisi\"  \n    3) \"zhangsan1\"  \n    4) \"zhangsan01\"  \n    5) \"lisi\"  \n    6) \"zhangsan\"  \n    7) \"lisi\"  \n    8) \"zhangsan\"  \n    redis 127.0.0.1:6379> lrange lst.user -1 zhangsan #移除最后一个zhangsan  \n    (empty list or set)  \n    redis 127.0.0.1:6379> lrange lst.user 0 -1  \n    1) \"wangwu\"  \n    2) \"lisi\"  \n    3) \"zhangsan1\"  \n    4) \"zhangsan01\"  \n    5) \"lisi\"  \n    6) \"zhangsan\"  \n    7) \"lisi\"  \n    redis 127.0.0.1:6379> lrem lst.user 0 lisi  #移除所有lisi  \n    (integer) 3  \n    redis 127.0.0.1:6379> lrange lst.user 0 -1  \n    1) \"wangwu\"  \n    2) \"zhangsan1\"  \n    3) \"zhangsan01\"  \n    4) \"zhangsan\"  \n    redis 127.0.0.1:6379> \n    \n\n>rpop\n>语法：rpop key\n\n解释：移除并返回表尾元素\n\n    redis 127.0.0.1:6379> rpop lst.user  \n    \"zhangsan\"\n    \n\n>lpop\n>语法：lpop key \n\n解释：移除并返回表尾元素\n    \n    redis 127.0.0.1:6379> lpop lst.user  \n    \"wangwu\"\n    \n\n5.其他\n---\n>llen\n>语法：llen key\n\n解释：获取列表长度\n\n    redis 127.0.0.1:6379> llen lst.user  \n    (integer) 2\n\n","slug":"redis-list","published":1,"updated":"2024-04-11T13:25:35.636Z","comments":1,"layout":"post","photos":[],"_id":"cluvablv20008cbih2e1qd3uw","content":"<p>list相关概念</p>\n<ul>\n<li>列表：一个从左到右的队列，类似于一个栈，常规模式下，先进列表的元素，后出。</li>\n<li>表头元素：列表最左端第一个元素。</li>\n<li>表尾元素：列表最右端的最后一个元素。不包含任何元素的列表成为空列表。</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"1-新增\"><a href=\"#1-新增\" class=\"headerlink\" title=\"1.新增\"></a>1.新增</h2><blockquote>\n<p>lpush<br>语法：lpush key value[value]</p>\n</blockquote>\n<p>解释：把一个或多个元素插入表头。如果是多个value时，按照从左到右的次序插。返回插入元素的个数</p>\n<pre><code>[root@xsf001 ~]# redis-cli  \nredis 127.0.0.1:6379&gt; lpush lst.user zhangsan   #插入一个元素  \n(integer) 1  \nredis 127.0.0.1:6379&gt; lpush lst.user zhangsan lisi   #插入多个元素，list中允许插入重复的元素  \n(integer) 3 \n</code></pre>\n<blockquote>\n<p>lpushx<br>语法：lpushx key value</p>\n</blockquote>\n<p>解释：插入一个表头元素，当且仅当列表key存在时，才能插入。返回列表中元素的个数</p>\n<pre><code>redis 127.0.0.1:6379&gt; lpushx lst.user wangwu   #列表存在  \n(integer) 4  \nredis 127.0.0.1:6379&gt; lpushx lst.tech wangwu   #列表不存在，不插入  \n(integer) 0 \n</code></pre>\n<blockquote>\n<p>rpush<br>语法：rpush key [value]</p>\n</blockquote>\n<p>解释：将一个或多个值插入到队列的队尾。多值时，从左到右依次添加。返回列表中元素个数</p>\n<pre><code>redis 127.0.0.1:6379&gt; rpush lst.user ls005     #列表存在  \n(integer) 5  \nredis 127.0.0.1:6379&gt; rpush lst.tech tec01 tec02 tec03  #列表不存在  \n(integer) 3 \n</code></pre>\n<blockquote>\n<p>rpushx<br>语法：rpushx key value</p>\n</blockquote>\n<p>解释：讲值插入到列表队尾，当且仅当列表key存在时，才添加。返回列表元素个数</p>\n<pre><code>redis 127.0.0.1:6379&gt; rpushx lst.tech tec04  #key 存在  \n(integer) 4  \nredis 127.0.0.1:6379&gt; rpushx lst.sub englist #key 不存在  \n(integer) 0\n</code></pre>\n<blockquote>\n<p>linsert<br>语法：linsert key before|after pivot value</p>\n</blockquote>\n<p>解释：将值插入到pivot的前面或后面。返回列表元素个数。如果参照点pivot不存在不插入。如果有多个pivot，以离表头最近的为准</p>\n<pre><code>redis 127.0.0.1:6379&gt; linsert lst.tech after tec04 tec06  #后面插  \n(integer) 5   \nredis 127.0.0.1:6379&gt; linsert lst.tech before tec06 tec05 #前面插  \n(integer) 6   \nredis 127.0.0.1:6379&gt; linsert lst.tech before tec08 tec07 #参照点不存在，不插  \n(integer) -1  \nredis 127.0.0.1:6379&gt; linsert lst.user after zhangsan zhangsan01  #列表中有多个pivot，以从左到右的第一个为准  \n(integer) 6\n</code></pre>\n<h2 id=\"2-查询\"><a href=\"#2-查询\" class=\"headerlink\" title=\"2.查询\"></a>2.查询</h2><blockquote>\n<p>lindex<br>语法：lindex key index</p>\n</blockquote>\n<p>解释：通过索引index获取列表的元素。 index&gt;&#x3D;0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</p>\n<pre><code>redis 127.0.0.1:6379&gt; lindex lst.user 0  #表头  \n&quot;wangwu&quot;   \nredis 127.0.0.1:6379&gt; lindex lst.user -1 #表尾  \n&quot;ls005&quot;  \nredis 127.0.0.1:6379&gt; lindex lst.user 2 #第三个元素  \n&quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; lindex lst.user -2 #倒数第二个元素  \n&quot;zhangsan&quot; \n</code></pre>\n<blockquote>\n<p>lrange<br>语法：lrange key start stop</p>\n</blockquote>\n<p>解释：获取指定开始和结束范围的一些列元素。0：表头，-1：表尾。如果stop指定的元素在start的左边，返回空列表</p>\n<pre><code>redis 127.0.0.1:6379&gt; lrange lst.user 0 -1 #返回所有  \n1) &quot;wangwu&quot;  \n2) &quot;lisi&quot;  \n3) &quot;zhangsan&quot;  \n4) &quot;zhangsan01&quot;  \n5) &quot;zhangsan&quot;  \n6) &quot;ls005&quot;  \nredis 127.0.0.1:6379&gt; lrange lst.user -1 0  #返回空  \n(empty list or set)  \nredis 127.0.0.1:6379&gt; lrange lst.user 1 2  #返回多个  \n1) &quot;lisi&quot;  \n2) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; lrange lst.user 1 1   #返回一个元素  \n1) &quot;lisi&quot;\n</code></pre>\n<h2 id=\"3-修改\"><a href=\"#3-修改\" class=\"headerlink\" title=\"3.修改\"></a>3.修改</h2><blockquote>\n<p>lset<br>语法：lset key index value</p>\n</blockquote>\n<p>解释：设置列表指定索引的值，如果指定索引不存在则报错</p>\n<pre><code>redis 127.0.0.1:6379&gt; lset lst.user 2 zhangsan1  #设置第三个元素为zhangsan1  \nOK  \nredis 127.0.0.1:6379&gt; lrange lst.user 0 -1  \n1) &quot;wangwu&quot;  \n2) &quot;lisi&quot;  \n3) &quot;zhangsan1&quot;  \n4) &quot;zhangsan01&quot;  \n5) &quot;zhangsan&quot;  \n6) &quot;ls005&quot;  \nredis 127.0.0.1:6379&gt; lset lst.user 6 ls006  #指定索引不存在  \n(error) ERR index out of range\n</code></pre>\n<h2 id=\"4-删除\"><a href=\"#4-删除\" class=\"headerlink\" title=\"4.删除\"></a>4.删除</h2><blockquote>\n<p>ltrim<br>语法：ltrim key start stop</p>\n</blockquote>\n<p>解释：保留指定区域的元素，其他元素全部删除</p>\n<pre><code>redis 127.0.0.1:6379&gt; ltrim lst.user 0 -2  \nOK  \nredis 127.0.0.1:6379&gt; lrange lst.user 0 -1  \n1) &quot;wangwu&quot;  \n2) &quot;lisi&quot;  \n3) &quot;zhangsan1&quot;  \n4) &quot;zhangsan01&quot;  \n5) &quot;zhangsan&quot;\n</code></pre>\n<blockquote>\n<p>lrem<br>语法：lrem key count value</p>\n</blockquote>\n<p>解释：移除等于value的元素，当count&gt;0时，从表头开始查找，移除count个；当count&#x3D;0时，从表头开始查找，移除所有等于value的；当count&lt;0时，从表尾开始查找，移除|count| 个。</p>\n<pre><code>redis 127.0.0.1:6379&gt; lrange lst.user 0 -1  \n1) &quot;zhangsan&quot;  \n2) &quot;wangwu&quot;  \n3) &quot;lisi&quot;  \n4) &quot;zhangsan1&quot;  \n5) &quot;zhangsan01&quot;  \n6) &quot;zhangsan&quot;  \n7) &quot;lisi&quot;  \n8) &quot;zhangsan&quot;  \n9) &quot;lisi&quot;  \n10) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; lrem lst.user 2 zhangsan #移除前两个zhangsan  \n(integer) 2  \nredis 127.0.0.1:6379&gt; lrange lst.user 0 -1  \n1) &quot;wangwu&quot;  \n2) &quot;lisi&quot;  \n3) &quot;zhangsan1&quot;  \n4) &quot;zhangsan01&quot;  \n5) &quot;lisi&quot;  \n6) &quot;zhangsan&quot;  \n7) &quot;lisi&quot;  \n8) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; lrange lst.user -1 zhangsan #移除最后一个zhangsan  \n(empty list or set)  \nredis 127.0.0.1:6379&gt; lrange lst.user 0 -1  \n1) &quot;wangwu&quot;  \n2) &quot;lisi&quot;  \n3) &quot;zhangsan1&quot;  \n4) &quot;zhangsan01&quot;  \n5) &quot;lisi&quot;  \n6) &quot;zhangsan&quot;  \n7) &quot;lisi&quot;  \nredis 127.0.0.1:6379&gt; lrem lst.user 0 lisi  #移除所有lisi  \n(integer) 3  \nredis 127.0.0.1:6379&gt; lrange lst.user 0 -1  \n1) &quot;wangwu&quot;  \n2) &quot;zhangsan1&quot;  \n3) &quot;zhangsan01&quot;  \n4) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; \n</code></pre>\n<blockquote>\n<p>rpop<br>语法：rpop key</p>\n</blockquote>\n<p>解释：移除并返回表尾元素</p>\n<pre><code>redis 127.0.0.1:6379&gt; rpop lst.user  \n&quot;zhangsan&quot;\n</code></pre>\n<blockquote>\n<p>lpop<br>语法：lpop key </p>\n</blockquote>\n<p>解释：移除并返回表尾元素</p>\n<pre><code>redis 127.0.0.1:6379&gt; lpop lst.user  \n&quot;wangwu&quot;\n</code></pre>\n<h2 id=\"5-其他\"><a href=\"#5-其他\" class=\"headerlink\" title=\"5.其他\"></a>5.其他</h2><blockquote>\n<p>llen<br>语法：llen key</p>\n</blockquote>\n<p>解释：获取列表长度</p>\n<pre><code>redis 127.0.0.1:6379&gt; llen lst.user  \n(integer) 2\n</code></pre>\n","excerpt":"<p>list相关概念</p>\n<ul>\n<li>列表：一个从左到右的队列，类似于一个栈，常规模式下，先进列表的元素，后出。</li>\n<li>表头元素：列表最左端第一个元素。</li>\n<li>表尾元素：列表最右端的最后一个元素。不包含任何元素的列表成为空列表。</li>\n</ul>","more":"<h2 id=\"1-新增\"><a href=\"#1-新增\" class=\"headerlink\" title=\"1.新增\"></a>1.新增</h2><blockquote>\n<p>lpush<br>语法：lpush key value[value]</p>\n</blockquote>\n<p>解释：把一个或多个元素插入表头。如果是多个value时，按照从左到右的次序插。返回插入元素的个数</p>\n<pre><code>[root@xsf001 ~]# redis-cli  \nredis 127.0.0.1:6379&gt; lpush lst.user zhangsan   #插入一个元素  \n(integer) 1  \nredis 127.0.0.1:6379&gt; lpush lst.user zhangsan lisi   #插入多个元素，list中允许插入重复的元素  \n(integer) 3 \n</code></pre>\n<blockquote>\n<p>lpushx<br>语法：lpushx key value</p>\n</blockquote>\n<p>解释：插入一个表头元素，当且仅当列表key存在时，才能插入。返回列表中元素的个数</p>\n<pre><code>redis 127.0.0.1:6379&gt; lpushx lst.user wangwu   #列表存在  \n(integer) 4  \nredis 127.0.0.1:6379&gt; lpushx lst.tech wangwu   #列表不存在，不插入  \n(integer) 0 \n</code></pre>\n<blockquote>\n<p>rpush<br>语法：rpush key [value]</p>\n</blockquote>\n<p>解释：将一个或多个值插入到队列的队尾。多值时，从左到右依次添加。返回列表中元素个数</p>\n<pre><code>redis 127.0.0.1:6379&gt; rpush lst.user ls005     #列表存在  \n(integer) 5  \nredis 127.0.0.1:6379&gt; rpush lst.tech tec01 tec02 tec03  #列表不存在  \n(integer) 3 \n</code></pre>\n<blockquote>\n<p>rpushx<br>语法：rpushx key value</p>\n</blockquote>\n<p>解释：讲值插入到列表队尾，当且仅当列表key存在时，才添加。返回列表元素个数</p>\n<pre><code>redis 127.0.0.1:6379&gt; rpushx lst.tech tec04  #key 存在  \n(integer) 4  \nredis 127.0.0.1:6379&gt; rpushx lst.sub englist #key 不存在  \n(integer) 0\n</code></pre>\n<blockquote>\n<p>linsert<br>语法：linsert key before|after pivot value</p>\n</blockquote>\n<p>解释：将值插入到pivot的前面或后面。返回列表元素个数。如果参照点pivot不存在不插入。如果有多个pivot，以离表头最近的为准</p>\n<pre><code>redis 127.0.0.1:6379&gt; linsert lst.tech after tec04 tec06  #后面插  \n(integer) 5   \nredis 127.0.0.1:6379&gt; linsert lst.tech before tec06 tec05 #前面插  \n(integer) 6   \nredis 127.0.0.1:6379&gt; linsert lst.tech before tec08 tec07 #参照点不存在，不插  \n(integer) -1  \nredis 127.0.0.1:6379&gt; linsert lst.user after zhangsan zhangsan01  #列表中有多个pivot，以从左到右的第一个为准  \n(integer) 6\n</code></pre>\n<h2 id=\"2-查询\"><a href=\"#2-查询\" class=\"headerlink\" title=\"2.查询\"></a>2.查询</h2><blockquote>\n<p>lindex<br>语法：lindex key index</p>\n</blockquote>\n<p>解释：通过索引index获取列表的元素。 index&gt;&#x3D;0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</p>\n<pre><code>redis 127.0.0.1:6379&gt; lindex lst.user 0  #表头  \n&quot;wangwu&quot;   \nredis 127.0.0.1:6379&gt; lindex lst.user -1 #表尾  \n&quot;ls005&quot;  \nredis 127.0.0.1:6379&gt; lindex lst.user 2 #第三个元素  \n&quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; lindex lst.user -2 #倒数第二个元素  \n&quot;zhangsan&quot; \n</code></pre>\n<blockquote>\n<p>lrange<br>语法：lrange key start stop</p>\n</blockquote>\n<p>解释：获取指定开始和结束范围的一些列元素。0：表头，-1：表尾。如果stop指定的元素在start的左边，返回空列表</p>\n<pre><code>redis 127.0.0.1:6379&gt; lrange lst.user 0 -1 #返回所有  \n1) &quot;wangwu&quot;  \n2) &quot;lisi&quot;  \n3) &quot;zhangsan&quot;  \n4) &quot;zhangsan01&quot;  \n5) &quot;zhangsan&quot;  \n6) &quot;ls005&quot;  \nredis 127.0.0.1:6379&gt; lrange lst.user -1 0  #返回空  \n(empty list or set)  \nredis 127.0.0.1:6379&gt; lrange lst.user 1 2  #返回多个  \n1) &quot;lisi&quot;  \n2) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; lrange lst.user 1 1   #返回一个元素  \n1) &quot;lisi&quot;\n</code></pre>\n<h2 id=\"3-修改\"><a href=\"#3-修改\" class=\"headerlink\" title=\"3.修改\"></a>3.修改</h2><blockquote>\n<p>lset<br>语法：lset key index value</p>\n</blockquote>\n<p>解释：设置列表指定索引的值，如果指定索引不存在则报错</p>\n<pre><code>redis 127.0.0.1:6379&gt; lset lst.user 2 zhangsan1  #设置第三个元素为zhangsan1  \nOK  \nredis 127.0.0.1:6379&gt; lrange lst.user 0 -1  \n1) &quot;wangwu&quot;  \n2) &quot;lisi&quot;  \n3) &quot;zhangsan1&quot;  \n4) &quot;zhangsan01&quot;  \n5) &quot;zhangsan&quot;  \n6) &quot;ls005&quot;  \nredis 127.0.0.1:6379&gt; lset lst.user 6 ls006  #指定索引不存在  \n(error) ERR index out of range\n</code></pre>\n<h2 id=\"4-删除\"><a href=\"#4-删除\" class=\"headerlink\" title=\"4.删除\"></a>4.删除</h2><blockquote>\n<p>ltrim<br>语法：ltrim key start stop</p>\n</blockquote>\n<p>解释：保留指定区域的元素，其他元素全部删除</p>\n<pre><code>redis 127.0.0.1:6379&gt; ltrim lst.user 0 -2  \nOK  \nredis 127.0.0.1:6379&gt; lrange lst.user 0 -1  \n1) &quot;wangwu&quot;  \n2) &quot;lisi&quot;  \n3) &quot;zhangsan1&quot;  \n4) &quot;zhangsan01&quot;  \n5) &quot;zhangsan&quot;\n</code></pre>\n<blockquote>\n<p>lrem<br>语法：lrem key count value</p>\n</blockquote>\n<p>解释：移除等于value的元素，当count&gt;0时，从表头开始查找，移除count个；当count&#x3D;0时，从表头开始查找，移除所有等于value的；当count&lt;0时，从表尾开始查找，移除|count| 个。</p>\n<pre><code>redis 127.0.0.1:6379&gt; lrange lst.user 0 -1  \n1) &quot;zhangsan&quot;  \n2) &quot;wangwu&quot;  \n3) &quot;lisi&quot;  \n4) &quot;zhangsan1&quot;  \n5) &quot;zhangsan01&quot;  \n6) &quot;zhangsan&quot;  \n7) &quot;lisi&quot;  \n8) &quot;zhangsan&quot;  \n9) &quot;lisi&quot;  \n10) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; lrem lst.user 2 zhangsan #移除前两个zhangsan  \n(integer) 2  \nredis 127.0.0.1:6379&gt; lrange lst.user 0 -1  \n1) &quot;wangwu&quot;  \n2) &quot;lisi&quot;  \n3) &quot;zhangsan1&quot;  \n4) &quot;zhangsan01&quot;  \n5) &quot;lisi&quot;  \n6) &quot;zhangsan&quot;  \n7) &quot;lisi&quot;  \n8) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; lrange lst.user -1 zhangsan #移除最后一个zhangsan  \n(empty list or set)  \nredis 127.0.0.1:6379&gt; lrange lst.user 0 -1  \n1) &quot;wangwu&quot;  \n2) &quot;lisi&quot;  \n3) &quot;zhangsan1&quot;  \n4) &quot;zhangsan01&quot;  \n5) &quot;lisi&quot;  \n6) &quot;zhangsan&quot;  \n7) &quot;lisi&quot;  \nredis 127.0.0.1:6379&gt; lrem lst.user 0 lisi  #移除所有lisi  \n(integer) 3  \nredis 127.0.0.1:6379&gt; lrange lst.user 0 -1  \n1) &quot;wangwu&quot;  \n2) &quot;zhangsan1&quot;  \n3) &quot;zhangsan01&quot;  \n4) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; \n</code></pre>\n<blockquote>\n<p>rpop<br>语法：rpop key</p>\n</blockquote>\n<p>解释：移除并返回表尾元素</p>\n<pre><code>redis 127.0.0.1:6379&gt; rpop lst.user  \n&quot;zhangsan&quot;\n</code></pre>\n<blockquote>\n<p>lpop<br>语法：lpop key </p>\n</blockquote>\n<p>解释：移除并返回表尾元素</p>\n<pre><code>redis 127.0.0.1:6379&gt; lpop lst.user  \n&quot;wangwu&quot;\n</code></pre>\n<h2 id=\"5-其他\"><a href=\"#5-其他\" class=\"headerlink\" title=\"5.其他\"></a>5.其他</h2><blockquote>\n<p>llen<br>语法：llen key</p>\n</blockquote>\n<p>解释：获取列表长度</p>\n<pre><code>redis 127.0.0.1:6379&gt; llen lst.user  \n(integer) 2\n</code></pre>"},{"title":"敏捷开发：如何通过回顾保持学习状态","date":"2015-09-26T14:14:26.000Z","_content":"\n>英文原文：[How To: Live and Learn with Retrospectives](http://www.infoq.com/articles/agile-retrospectives-davies)\n\n　　软件开发不是孤独的追击，它需要同其他开发者和其他部门协作。大多数组织建立的软件生命周期没有涉及到如何进行这些交互。现实是许多团队的过程并不符合他们的要求或没有得到一贯地遵循。当发生这种情况时，很容易让人产生抱怨情绪，如果你已经有了改进的想法却又无从下手，也会让人感到沮丧。本文提供了一个工具，可以帮助你的团队基于其日常经验进行过程改进。回顾是工具，团队可以利用它来产生积极的变化：从遵循过程到驾驭过程。\n\n　　回顾是会议，让整个团队都参与到检查过去的事件过程中，并对就今后如何更高效的工作进行头脑风暴。团队根据获得教训制定对应措施，并应用于自身。本文旨在说明为推动你的团队进行回顾，你需要做些什么。\n\n<!--more-->\n\n**背景**\n\n　　术语“回顾”是由Norman Kerth在其著作《项目回顾：团队审查手册》中创造的。书中描述了如何推动团队在项目结束时举行三天脱岗会议（off-site meetings），以总结经验教训。这种回顾是一种履行后检查（post-implementation review）——有时称为验尸（post-mortems）！等到项目结束时才开始总结经验教训是一件憾事。在2001年，极限编程团队将回顾纳入迭代周期。回顾被加入到另一种敏捷方法 —— Scrum中。并且，在项目生命周期内举行多次简短的“心跳”回顾，是现今采用敏捷方法团队普遍的做法，这使得他们能够在项目进行期间就能收集和总结其开发过程的经验教训，而不是等到项目结束后。\n\n**从经验中学习**\n\n　　没有经过反省的经验仅仅是数据而已。退一步说，反省我们的经验是我们日常生活中学习和转变的方式。举一个简单的例子，如果我在开车上班途中碰到了严重堵车，我会考虑换一条路径，甚至用其他方式赶到办公室。经过几次试验后，我会习惯于一个新的路径。\n\n　　如果人们不愿意做那些注定要重复的工作，说明他们并不是真正地在工作（有些疯狂的定义）。虽然回顾始于回首往事，但这样做的原因是为了改变我们未来的行事方法 —— 回顾是在进行长远地转变。有时候，我们必须重新思考我们的做法，而不是试图以加快现有过程。\n\n　　回顾还能改善团队沟通。有一个古老的格言“共享的问题就是减半的问题（a problem shared is a problem halved）”。把我们的经验复述给朋友和同事是我们日常生活中都做过的事情。在团队的成果中，没有人知道完整故事的始末。完整的故事只能通过整理个体经验来了解。通过探讨如何从不同的视角感知同一事件，团队成员能够更好的了解对方，并调整了团队中人们的需求。\n\n**化解定时炸弹**\n\n　　让我们看看如何举行一次有效的回顾。当团队一直受到压力或面临严重困难时，人们的脾气可能变大了，而且团队成员间的关系可能已经出了问题。指望通过把团队集中在房间里一起讨论近来发生的事情简直就是奇迹，这有点不切实际。像任何富有成果的会议一样，回顾需要明确的议程和主持人去保持会议平稳进行。如果没有这些措施，会谈很可能会充满批评和指责。这只会使进入房间的每个人发泄他们的不满情绪，不可能解决任何问题的，甚至还可能使问题加重。\n\n　　回顾采用精心设计的结构来消除分歧，将重点转移到学习和借鉴已有经验上。基本技巧是放慢谈话节奏，在完全探究大家对事件的不同看法之后，再下结论。\n　　\n**基本指令**\n\n　　检查过去的事件但不评判发生了什么，这更容易使我们转而问：下次是否可以做得更好? 关键是要采用系统思考的角度。为了对此有所帮助，应维持如下假设：问题出在系统创建期间而非个人，这是Norm Kerth所宣称的回顾基本指令，它是所有回顾的基本原则。\n　　\n>基本指令：不管我们发现了什么，我们必须明白并真正相信，在给定时间、其自身的技能和能力、可用资源及最近状态的前提下，每个人都尽力做到了最好。\n\n　　该基本指令的意图经常被误解。显然，有时候人们乱作一团时 —— 或许他们不知道有更好做法，或许他们真的很懒或很残忍。但是在回顾过程中我们的焦点单单是做出改进，因而我们用该基本指令来帮助我们保持在处于有建设性的方式之中。至于个人的拙劣表现则最好交由管理者或人力资源（HR）部来处理，基本指令将这种交流设定在回顾的范围之外。\n\n**基本规则入门**\n\n　　为了有效进行回顾，需要有人推动会议。主持人应努力营造一种气氛，使团队成员对谈话感到轻松。\n\n　　设置基本规则和回顾目标有助于回顾顺利进行。还有一些明显地规则是适用于大多数有成效的会议的，比如设置手机为静音状态。那么我们还需要为回顾增加些什么特别地规则呢？听取每个人的意见是很重要的，因此一个重要的基本规则是“不要打断”，如果在某个激动的瞬间该规则受到了忽视，那么你可以尝试使用“说话棒” —— 某一时间只有一个人可以说话，即持有说话棒令牌的人（令牌不一定非是一根棒子，它可以是办公室的任何东西，如杯子。我所工作过团队用的是一个毛绒玩具，它比杯子更适合在屋里扔来扔去）。\n\n　　一旦会议基本规则建立起来了，就应该把规则写到活动挂图纸（flipchart paper）上，并张贴在人人都能看见的墙上。如果人们开始忘记基本规则了，那么主持人的工作就是提醒大家。例如，如果有人在会议室接听了电话，主持人应该和气地引导其离开，这样他的谈话内容不会干扰到回顾。\n\n**安全检查**\n\n　　另一项重要的基本规则是可选的，即在回顾中参与练习。有些人在小组讨论中可能感到不自在或被揭发了，如果你想让他们在回顾中作出贡献的话，不要在他们的感觉上再雪上加霜是很重要的。当一个团队做最初几次回顾时，执行“安全检查”是很有用的，以了解谁能轻松的对待谈话。来一个匿名投票可以做到这一点，匿名投票要求每个人说明他们多想在回顾中发言，在小纸片上写下范围从1到5的一个数字（1表示“不可能分享我的观点”，5表示“完全可以公开谈论”），主持人收集并统计这些选票，将结果张贴在房间的活动挂图（flipchart）上。此举目的是让与会者认识到，房间里人们相互信任程度是不同的，让主持人评估在随后的讨论中采用何种形势。如果个人的信任程度比较低，让人们在更小的组里工作，并做更多的练习（人们可以匿名的写出评论）是有效的做法。\n\n**动作回放**\n\n　　运动员利用动作回放来分析自己的动作并寻求改进。在回顾里与之等价的是时间线（Timeline）。\n\n　　首先为团队建立一个空间，将过去的事件按发生顺序张贴出来；从左至右，从过去到现在。每个团队成员用彩色便签（或索引卡）加入时间线。主持人为每种颜色的卡片定义一重含义。例如，粉红——消极事件，黄——中性事件，绿——积极事件。用颜色有助于在这一系列事件中显示出图案。会议的这一部分通常进行地很快，因为团队成员是并行建立一个共同的图案。\n\n　　创建时间线的练习有几个服务宗旨——帮助团队记住都发生了什么事情，为团队的每个人提供机会以张贴要谈论的话题，并试图将讨论定位在实际事件而非大概的预感上。事件时间线是一个短暂的中间成果，以帮助提醒团队都发生了什么事情，但它通常不作为回顾的最终产出。\n\n**总结教训**\n\n　　一旦对事件达成了一致的观点，团队就可以开始总结教训了。让团队按时间线从开始走到结束，其目的是确定：“什么是行之有效的，我们要记住?”，“下次有什么不同做法?” ，“什么还仍然困扰着我们?”。\n\n　　主持人阅读在时间线上的每个注解，并邀请他们作出评论。团队既要找出好的经验和也要总结坏的教训。这个阶段提醒团队是很重要的，我们的想法是要为未来的行动计划找出具体的解决方案。\n\n　　作为主持人，尝试抄写下写字板（或其他看得见的空间）上交流内容的摘要信息，但需与团队一起检查你所抄写的东西是否准确代表了原意。记下原始表达观点有助于显示一个人的关切已经受到了聆听。\n\n　　根据我的经验，开发者倾向于抽象地谈论一些事情——产生无确实证据的观点。作为主持人，深层挖掘、检查假设和推论（请开发者提供具体的例子来支持其所提出的观点）都是很重要的。\n\n**行动计划**\n\n　　通常，大多问题被确定但还不能立即采取行动。团队在开始计划行动前必须先发现问题。团队必须用现实的思维模式而非想象的思维模式。在迭代结束回顾中，不超过3至5项行动将是一个合理的限度。\n\n　　在设置任何新的行动之前，团队应该检查在以前的回顾中是否有出色的行动。如果有，值得探讨一下该行动为什么及是否需要重塑。有时人们确定行动时野心太大，需要减小他们所能实际实现的事情的范围。对每一项行动，尝试从下一步目标（可能是一小步）中分离出长远目标。团队甚至可能决定试试水，把采用新的工作方法改进流程作为实验，在下一次回顾时检验其效力。区分短期修改和解决根源问题也很重要。团队应该需要两种类型的行动，有本书提供了好的模式，用以区分行动的类型，它是Edward De Bono所著的“六双行动鞋”。\n\n　　每次行动都需要一个负责人负责交付，找个哥们儿并与其一起工作，以确保在下一次回顾之前完成行动，可能是一个好主意。有些行动可能是团队外界的直接势力范围，需要管理层支持。为获得支持，团队可能需要出售这些问题！在这种情况下，你的第一个行动是搜集证据，以帮助团队说服老板行动起来。\n\n**包装**\n\n　　在结束回顾之前，主持人需要明确会议将会有怎样的产出。团队可以在其工作区的墙纸墙上展示其行动。或者可以用数码相机记录下写字板纸/白板上的内容，照片可以上传到一个文件共享空间或传送到团队的wiki上。在使产出在组织范围内可见之前，主持人需要与团队一起检查公布该产出是否令人不自在。\n\n**完善回顾**\n\n　　进行回顾有利于磨练你的主持技巧——回顾需要准备和全程跟随。主持人应该预先做完时间的分配工作并不时地改变练习。Esther Derby 和 Diana Larsen所著的“敏捷回顾”是新练习好的资料来源。它给出了一个粗的时间分配指导——团队每周需要30分钟回顾时间，按此计算，每月需要2小时、几个月需要一整天进行回顾。\n\n　　此外，为规划时间和形式，主持人还需要审查：谁应该来？在哪里举行会议？何时举行会议？当一个团队开始回顾，他们会发现他们团队内部付出了大量的行动。一旦团队有自己的房子，通常将与其他团队交互，扩大邀请名单以包括团队之外的人员以获取更广的视角，这样做是有价值的。\n\n　　作为团队领导或经理，当你有观点和看法想与大家分享的时，有时难以发挥中立调解者的角色。如果你与其他使用回顾的团队并肩工作，那么团队间可以互相推动。\n\n　　作为标准做法，在我的回顾结束时，我从参与者那儿收集了“投入时间回报”率，如果你正在尝试在组织内建立一个主持人团队，那么收集这些参与者反馈很可能将有助于新的主持人理解他们所做的事情。\n\n　　找到合适的会议场所能产生的效果有很大不同. 挑选一处远离你正常工作区的会议室可以避免人们在回顾到一半又转回到工作上。尽可能设法避免会议室的布局——围坐在一个大桌子周围立刻会给团队成员之间设置巨大的障碍——取而代之，你可以把几个椅子布置成半圆形。你还需要一下检查室内，至少要有两米长的干净墙壁或白板。当一个地点被登记用作回顾时，检查那儿有无空间能将纸挂在墙上是很重要的。有时我被安排在一个有大量墙纸、书架和古董书画的会议室主持回顾，只好利用门、窗或在桌子的尽头搞一个临时的张贴空间。\n\n　　至于时间，当工作在一个迭代计划周期内，你需要在下一个跌代计划之前举行回顾。但是如果接连举行回顾与计划会议将使每个人疲惫不堪，因此试着将这两个会议分成上下午，甚至单独一天。\n\n**最后一句话**\n\n　　有时我被一些想了解更多关于回顾的人问到这样的问题，“你能举例说明回顾能产生巨大的成果吗?”。我已认识到这个问题类似于“你能不能讲讲这种疾病是如何由正规的治疗方法治愈的?”\n\n　　我曾工作过一些团队，他们长期进行正规的心跳回顾已经使其发生了很大的变化，但这种改变是逐步的而缓慢的，他们并没有制造头条新闻。例如，我曾工作过的一个团队，有一个关于在计划产品开发跌代期间如何处理业务变更的问题。我们花了几个月的时间才为每个人建立了计划，但是如果没有回顾过程可能需要更多的时间。\n\n　　定期回顾和定期实践的能力是他们避免了重大问题的发生，所以没有战争故事或神奇的转变是应该的！拥抱回顾有助于一个团队以合适的步调来调整他们的过程。\n\n**作者简介**\n\n　　Rachel Davies是一个独立敏捷教练，位于在英国。 Rachel经常出席行业会议，她是敏捷联盟的理事。 欲与之联系，可以访问她的[网站](http://www.agilexp.com/) 。\n\n","source":"_posts/scrum.md","raw":"title: 敏捷开发：如何通过回顾保持学习状态\ndate: 2015-09-26 22:14:26\ncategories: 技术\n---\n\n>英文原文：[How To: Live and Learn with Retrospectives](http://www.infoq.com/articles/agile-retrospectives-davies)\n\n　　软件开发不是孤独的追击，它需要同其他开发者和其他部门协作。大多数组织建立的软件生命周期没有涉及到如何进行这些交互。现实是许多团队的过程并不符合他们的要求或没有得到一贯地遵循。当发生这种情况时，很容易让人产生抱怨情绪，如果你已经有了改进的想法却又无从下手，也会让人感到沮丧。本文提供了一个工具，可以帮助你的团队基于其日常经验进行过程改进。回顾是工具，团队可以利用它来产生积极的变化：从遵循过程到驾驭过程。\n\n　　回顾是会议，让整个团队都参与到检查过去的事件过程中，并对就今后如何更高效的工作进行头脑风暴。团队根据获得教训制定对应措施，并应用于自身。本文旨在说明为推动你的团队进行回顾，你需要做些什么。\n\n<!--more-->\n\n**背景**\n\n　　术语“回顾”是由Norman Kerth在其著作《项目回顾：团队审查手册》中创造的。书中描述了如何推动团队在项目结束时举行三天脱岗会议（off-site meetings），以总结经验教训。这种回顾是一种履行后检查（post-implementation review）——有时称为验尸（post-mortems）！等到项目结束时才开始总结经验教训是一件憾事。在2001年，极限编程团队将回顾纳入迭代周期。回顾被加入到另一种敏捷方法 —— Scrum中。并且，在项目生命周期内举行多次简短的“心跳”回顾，是现今采用敏捷方法团队普遍的做法，这使得他们能够在项目进行期间就能收集和总结其开发过程的经验教训，而不是等到项目结束后。\n\n**从经验中学习**\n\n　　没有经过反省的经验仅仅是数据而已。退一步说，反省我们的经验是我们日常生活中学习和转变的方式。举一个简单的例子，如果我在开车上班途中碰到了严重堵车，我会考虑换一条路径，甚至用其他方式赶到办公室。经过几次试验后，我会习惯于一个新的路径。\n\n　　如果人们不愿意做那些注定要重复的工作，说明他们并不是真正地在工作（有些疯狂的定义）。虽然回顾始于回首往事，但这样做的原因是为了改变我们未来的行事方法 —— 回顾是在进行长远地转变。有时候，我们必须重新思考我们的做法，而不是试图以加快现有过程。\n\n　　回顾还能改善团队沟通。有一个古老的格言“共享的问题就是减半的问题（a problem shared is a problem halved）”。把我们的经验复述给朋友和同事是我们日常生活中都做过的事情。在团队的成果中，没有人知道完整故事的始末。完整的故事只能通过整理个体经验来了解。通过探讨如何从不同的视角感知同一事件，团队成员能够更好的了解对方，并调整了团队中人们的需求。\n\n**化解定时炸弹**\n\n　　让我们看看如何举行一次有效的回顾。当团队一直受到压力或面临严重困难时，人们的脾气可能变大了，而且团队成员间的关系可能已经出了问题。指望通过把团队集中在房间里一起讨论近来发生的事情简直就是奇迹，这有点不切实际。像任何富有成果的会议一样，回顾需要明确的议程和主持人去保持会议平稳进行。如果没有这些措施，会谈很可能会充满批评和指责。这只会使进入房间的每个人发泄他们的不满情绪，不可能解决任何问题的，甚至还可能使问题加重。\n\n　　回顾采用精心设计的结构来消除分歧，将重点转移到学习和借鉴已有经验上。基本技巧是放慢谈话节奏，在完全探究大家对事件的不同看法之后，再下结论。\n　　\n**基本指令**\n\n　　检查过去的事件但不评判发生了什么，这更容易使我们转而问：下次是否可以做得更好? 关键是要采用系统思考的角度。为了对此有所帮助，应维持如下假设：问题出在系统创建期间而非个人，这是Norm Kerth所宣称的回顾基本指令，它是所有回顾的基本原则。\n　　\n>基本指令：不管我们发现了什么，我们必须明白并真正相信，在给定时间、其自身的技能和能力、可用资源及最近状态的前提下，每个人都尽力做到了最好。\n\n　　该基本指令的意图经常被误解。显然，有时候人们乱作一团时 —— 或许他们不知道有更好做法，或许他们真的很懒或很残忍。但是在回顾过程中我们的焦点单单是做出改进，因而我们用该基本指令来帮助我们保持在处于有建设性的方式之中。至于个人的拙劣表现则最好交由管理者或人力资源（HR）部来处理，基本指令将这种交流设定在回顾的范围之外。\n\n**基本规则入门**\n\n　　为了有效进行回顾，需要有人推动会议。主持人应努力营造一种气氛，使团队成员对谈话感到轻松。\n\n　　设置基本规则和回顾目标有助于回顾顺利进行。还有一些明显地规则是适用于大多数有成效的会议的，比如设置手机为静音状态。那么我们还需要为回顾增加些什么特别地规则呢？听取每个人的意见是很重要的，因此一个重要的基本规则是“不要打断”，如果在某个激动的瞬间该规则受到了忽视，那么你可以尝试使用“说话棒” —— 某一时间只有一个人可以说话，即持有说话棒令牌的人（令牌不一定非是一根棒子，它可以是办公室的任何东西，如杯子。我所工作过团队用的是一个毛绒玩具，它比杯子更适合在屋里扔来扔去）。\n\n　　一旦会议基本规则建立起来了，就应该把规则写到活动挂图纸（flipchart paper）上，并张贴在人人都能看见的墙上。如果人们开始忘记基本规则了，那么主持人的工作就是提醒大家。例如，如果有人在会议室接听了电话，主持人应该和气地引导其离开，这样他的谈话内容不会干扰到回顾。\n\n**安全检查**\n\n　　另一项重要的基本规则是可选的，即在回顾中参与练习。有些人在小组讨论中可能感到不自在或被揭发了，如果你想让他们在回顾中作出贡献的话，不要在他们的感觉上再雪上加霜是很重要的。当一个团队做最初几次回顾时，执行“安全检查”是很有用的，以了解谁能轻松的对待谈话。来一个匿名投票可以做到这一点，匿名投票要求每个人说明他们多想在回顾中发言，在小纸片上写下范围从1到5的一个数字（1表示“不可能分享我的观点”，5表示“完全可以公开谈论”），主持人收集并统计这些选票，将结果张贴在房间的活动挂图（flipchart）上。此举目的是让与会者认识到，房间里人们相互信任程度是不同的，让主持人评估在随后的讨论中采用何种形势。如果个人的信任程度比较低，让人们在更小的组里工作，并做更多的练习（人们可以匿名的写出评论）是有效的做法。\n\n**动作回放**\n\n　　运动员利用动作回放来分析自己的动作并寻求改进。在回顾里与之等价的是时间线（Timeline）。\n\n　　首先为团队建立一个空间，将过去的事件按发生顺序张贴出来；从左至右，从过去到现在。每个团队成员用彩色便签（或索引卡）加入时间线。主持人为每种颜色的卡片定义一重含义。例如，粉红——消极事件，黄——中性事件，绿——积极事件。用颜色有助于在这一系列事件中显示出图案。会议的这一部分通常进行地很快，因为团队成员是并行建立一个共同的图案。\n\n　　创建时间线的练习有几个服务宗旨——帮助团队记住都发生了什么事情，为团队的每个人提供机会以张贴要谈论的话题，并试图将讨论定位在实际事件而非大概的预感上。事件时间线是一个短暂的中间成果，以帮助提醒团队都发生了什么事情，但它通常不作为回顾的最终产出。\n\n**总结教训**\n\n　　一旦对事件达成了一致的观点，团队就可以开始总结教训了。让团队按时间线从开始走到结束，其目的是确定：“什么是行之有效的，我们要记住?”，“下次有什么不同做法?” ，“什么还仍然困扰着我们?”。\n\n　　主持人阅读在时间线上的每个注解，并邀请他们作出评论。团队既要找出好的经验和也要总结坏的教训。这个阶段提醒团队是很重要的，我们的想法是要为未来的行动计划找出具体的解决方案。\n\n　　作为主持人，尝试抄写下写字板（或其他看得见的空间）上交流内容的摘要信息，但需与团队一起检查你所抄写的东西是否准确代表了原意。记下原始表达观点有助于显示一个人的关切已经受到了聆听。\n\n　　根据我的经验，开发者倾向于抽象地谈论一些事情——产生无确实证据的观点。作为主持人，深层挖掘、检查假设和推论（请开发者提供具体的例子来支持其所提出的观点）都是很重要的。\n\n**行动计划**\n\n　　通常，大多问题被确定但还不能立即采取行动。团队在开始计划行动前必须先发现问题。团队必须用现实的思维模式而非想象的思维模式。在迭代结束回顾中，不超过3至5项行动将是一个合理的限度。\n\n　　在设置任何新的行动之前，团队应该检查在以前的回顾中是否有出色的行动。如果有，值得探讨一下该行动为什么及是否需要重塑。有时人们确定行动时野心太大，需要减小他们所能实际实现的事情的范围。对每一项行动，尝试从下一步目标（可能是一小步）中分离出长远目标。团队甚至可能决定试试水，把采用新的工作方法改进流程作为实验，在下一次回顾时检验其效力。区分短期修改和解决根源问题也很重要。团队应该需要两种类型的行动，有本书提供了好的模式，用以区分行动的类型，它是Edward De Bono所著的“六双行动鞋”。\n\n　　每次行动都需要一个负责人负责交付，找个哥们儿并与其一起工作，以确保在下一次回顾之前完成行动，可能是一个好主意。有些行动可能是团队外界的直接势力范围，需要管理层支持。为获得支持，团队可能需要出售这些问题！在这种情况下，你的第一个行动是搜集证据，以帮助团队说服老板行动起来。\n\n**包装**\n\n　　在结束回顾之前，主持人需要明确会议将会有怎样的产出。团队可以在其工作区的墙纸墙上展示其行动。或者可以用数码相机记录下写字板纸/白板上的内容，照片可以上传到一个文件共享空间或传送到团队的wiki上。在使产出在组织范围内可见之前，主持人需要与团队一起检查公布该产出是否令人不自在。\n\n**完善回顾**\n\n　　进行回顾有利于磨练你的主持技巧——回顾需要准备和全程跟随。主持人应该预先做完时间的分配工作并不时地改变练习。Esther Derby 和 Diana Larsen所著的“敏捷回顾”是新练习好的资料来源。它给出了一个粗的时间分配指导——团队每周需要30分钟回顾时间，按此计算，每月需要2小时、几个月需要一整天进行回顾。\n\n　　此外，为规划时间和形式，主持人还需要审查：谁应该来？在哪里举行会议？何时举行会议？当一个团队开始回顾，他们会发现他们团队内部付出了大量的行动。一旦团队有自己的房子，通常将与其他团队交互，扩大邀请名单以包括团队之外的人员以获取更广的视角，这样做是有价值的。\n\n　　作为团队领导或经理，当你有观点和看法想与大家分享的时，有时难以发挥中立调解者的角色。如果你与其他使用回顾的团队并肩工作，那么团队间可以互相推动。\n\n　　作为标准做法，在我的回顾结束时，我从参与者那儿收集了“投入时间回报”率，如果你正在尝试在组织内建立一个主持人团队，那么收集这些参与者反馈很可能将有助于新的主持人理解他们所做的事情。\n\n　　找到合适的会议场所能产生的效果有很大不同. 挑选一处远离你正常工作区的会议室可以避免人们在回顾到一半又转回到工作上。尽可能设法避免会议室的布局——围坐在一个大桌子周围立刻会给团队成员之间设置巨大的障碍——取而代之，你可以把几个椅子布置成半圆形。你还需要一下检查室内，至少要有两米长的干净墙壁或白板。当一个地点被登记用作回顾时，检查那儿有无空间能将纸挂在墙上是很重要的。有时我被安排在一个有大量墙纸、书架和古董书画的会议室主持回顾，只好利用门、窗或在桌子的尽头搞一个临时的张贴空间。\n\n　　至于时间，当工作在一个迭代计划周期内，你需要在下一个跌代计划之前举行回顾。但是如果接连举行回顾与计划会议将使每个人疲惫不堪，因此试着将这两个会议分成上下午，甚至单独一天。\n\n**最后一句话**\n\n　　有时我被一些想了解更多关于回顾的人问到这样的问题，“你能举例说明回顾能产生巨大的成果吗?”。我已认识到这个问题类似于“你能不能讲讲这种疾病是如何由正规的治疗方法治愈的?”\n\n　　我曾工作过一些团队，他们长期进行正规的心跳回顾已经使其发生了很大的变化，但这种改变是逐步的而缓慢的，他们并没有制造头条新闻。例如，我曾工作过的一个团队，有一个关于在计划产品开发跌代期间如何处理业务变更的问题。我们花了几个月的时间才为每个人建立了计划，但是如果没有回顾过程可能需要更多的时间。\n\n　　定期回顾和定期实践的能力是他们避免了重大问题的发生，所以没有战争故事或神奇的转变是应该的！拥抱回顾有助于一个团队以合适的步调来调整他们的过程。\n\n**作者简介**\n\n　　Rachel Davies是一个独立敏捷教练，位于在英国。 Rachel经常出席行业会议，她是敏捷联盟的理事。 欲与之联系，可以访问她的[网站](http://www.agilexp.com/) 。\n\n","slug":"scrum","published":1,"updated":"2024-04-11T13:25:35.642Z","comments":1,"layout":"post","photos":[],"_id":"cluvablv5000jcbih21nv28b4","content":"<blockquote>\n<p>英文原文：<a href=\"http://www.infoq.com/articles/agile-retrospectives-davies\">How To: Live and Learn with Retrospectives</a></p>\n</blockquote>\n<p>　　软件开发不是孤独的追击，它需要同其他开发者和其他部门协作。大多数组织建立的软件生命周期没有涉及到如何进行这些交互。现实是许多团队的过程并不符合他们的要求或没有得到一贯地遵循。当发生这种情况时，很容易让人产生抱怨情绪，如果你已经有了改进的想法却又无从下手，也会让人感到沮丧。本文提供了一个工具，可以帮助你的团队基于其日常经验进行过程改进。回顾是工具，团队可以利用它来产生积极的变化：从遵循过程到驾驭过程。</p>\n<p>　　回顾是会议，让整个团队都参与到检查过去的事件过程中，并对就今后如何更高效的工作进行头脑风暴。团队根据获得教训制定对应措施，并应用于自身。本文旨在说明为推动你的团队进行回顾，你需要做些什么。</p>\n<span id=\"more\"></span>\n\n<p><strong>背景</strong></p>\n<p>　　术语“回顾”是由Norman Kerth在其著作《项目回顾：团队审查手册》中创造的。书中描述了如何推动团队在项目结束时举行三天脱岗会议（off-site meetings），以总结经验教训。这种回顾是一种履行后检查（post-implementation review）——有时称为验尸（post-mortems）！等到项目结束时才开始总结经验教训是一件憾事。在2001年，极限编程团队将回顾纳入迭代周期。回顾被加入到另一种敏捷方法 —— Scrum中。并且，在项目生命周期内举行多次简短的“心跳”回顾，是现今采用敏捷方法团队普遍的做法，这使得他们能够在项目进行期间就能收集和总结其开发过程的经验教训，而不是等到项目结束后。</p>\n<p><strong>从经验中学习</strong></p>\n<p>　　没有经过反省的经验仅仅是数据而已。退一步说，反省我们的经验是我们日常生活中学习和转变的方式。举一个简单的例子，如果我在开车上班途中碰到了严重堵车，我会考虑换一条路径，甚至用其他方式赶到办公室。经过几次试验后，我会习惯于一个新的路径。</p>\n<p>　　如果人们不愿意做那些注定要重复的工作，说明他们并不是真正地在工作（有些疯狂的定义）。虽然回顾始于回首往事，但这样做的原因是为了改变我们未来的行事方法 —— 回顾是在进行长远地转变。有时候，我们必须重新思考我们的做法，而不是试图以加快现有过程。</p>\n<p>　　回顾还能改善团队沟通。有一个古老的格言“共享的问题就是减半的问题（a problem shared is a problem halved）”。把我们的经验复述给朋友和同事是我们日常生活中都做过的事情。在团队的成果中，没有人知道完整故事的始末。完整的故事只能通过整理个体经验来了解。通过探讨如何从不同的视角感知同一事件，团队成员能够更好的了解对方，并调整了团队中人们的需求。</p>\n<p><strong>化解定时炸弹</strong></p>\n<p>　　让我们看看如何举行一次有效的回顾。当团队一直受到压力或面临严重困难时，人们的脾气可能变大了，而且团队成员间的关系可能已经出了问题。指望通过把团队集中在房间里一起讨论近来发生的事情简直就是奇迹，这有点不切实际。像任何富有成果的会议一样，回顾需要明确的议程和主持人去保持会议平稳进行。如果没有这些措施，会谈很可能会充满批评和指责。这只会使进入房间的每个人发泄他们的不满情绪，不可能解决任何问题的，甚至还可能使问题加重。</p>\n<p>　　回顾采用精心设计的结构来消除分歧，将重点转移到学习和借鉴已有经验上。基本技巧是放慢谈话节奏，在完全探究大家对事件的不同看法之后，再下结论。<br>　　<br><strong>基本指令</strong></p>\n<p>　　检查过去的事件但不评判发生了什么，这更容易使我们转而问：下次是否可以做得更好? 关键是要采用系统思考的角度。为了对此有所帮助，应维持如下假设：问题出在系统创建期间而非个人，这是Norm Kerth所宣称的回顾基本指令，它是所有回顾的基本原则。\n　　</p>\n<blockquote>\n<p>基本指令：不管我们发现了什么，我们必须明白并真正相信，在给定时间、其自身的技能和能力、可用资源及最近状态的前提下，每个人都尽力做到了最好。</p>\n</blockquote>\n<p>　　该基本指令的意图经常被误解。显然，有时候人们乱作一团时 —— 或许他们不知道有更好做法，或许他们真的很懒或很残忍。但是在回顾过程中我们的焦点单单是做出改进，因而我们用该基本指令来帮助我们保持在处于有建设性的方式之中。至于个人的拙劣表现则最好交由管理者或人力资源（HR）部来处理，基本指令将这种交流设定在回顾的范围之外。</p>\n<p><strong>基本规则入门</strong></p>\n<p>　　为了有效进行回顾，需要有人推动会议。主持人应努力营造一种气氛，使团队成员对谈话感到轻松。</p>\n<p>　　设置基本规则和回顾目标有助于回顾顺利进行。还有一些明显地规则是适用于大多数有成效的会议的，比如设置手机为静音状态。那么我们还需要为回顾增加些什么特别地规则呢？听取每个人的意见是很重要的，因此一个重要的基本规则是“不要打断”，如果在某个激动的瞬间该规则受到了忽视，那么你可以尝试使用“说话棒” —— 某一时间只有一个人可以说话，即持有说话棒令牌的人（令牌不一定非是一根棒子，它可以是办公室的任何东西，如杯子。我所工作过团队用的是一个毛绒玩具，它比杯子更适合在屋里扔来扔去）。</p>\n<p>　　一旦会议基本规则建立起来了，就应该把规则写到活动挂图纸（flipchart paper）上，并张贴在人人都能看见的墙上。如果人们开始忘记基本规则了，那么主持人的工作就是提醒大家。例如，如果有人在会议室接听了电话，主持人应该和气地引导其离开，这样他的谈话内容不会干扰到回顾。</p>\n<p><strong>安全检查</strong></p>\n<p>　　另一项重要的基本规则是可选的，即在回顾中参与练习。有些人在小组讨论中可能感到不自在或被揭发了，如果你想让他们在回顾中作出贡献的话，不要在他们的感觉上再雪上加霜是很重要的。当一个团队做最初几次回顾时，执行“安全检查”是很有用的，以了解谁能轻松的对待谈话。来一个匿名投票可以做到这一点，匿名投票要求每个人说明他们多想在回顾中发言，在小纸片上写下范围从1到5的一个数字（1表示“不可能分享我的观点”，5表示“完全可以公开谈论”），主持人收集并统计这些选票，将结果张贴在房间的活动挂图（flipchart）上。此举目的是让与会者认识到，房间里人们相互信任程度是不同的，让主持人评估在随后的讨论中采用何种形势。如果个人的信任程度比较低，让人们在更小的组里工作，并做更多的练习（人们可以匿名的写出评论）是有效的做法。</p>\n<p><strong>动作回放</strong></p>\n<p>　　运动员利用动作回放来分析自己的动作并寻求改进。在回顾里与之等价的是时间线（Timeline）。</p>\n<p>　　首先为团队建立一个空间，将过去的事件按发生顺序张贴出来；从左至右，从过去到现在。每个团队成员用彩色便签（或索引卡）加入时间线。主持人为每种颜色的卡片定义一重含义。例如，粉红——消极事件，黄——中性事件，绿——积极事件。用颜色有助于在这一系列事件中显示出图案。会议的这一部分通常进行地很快，因为团队成员是并行建立一个共同的图案。</p>\n<p>　　创建时间线的练习有几个服务宗旨——帮助团队记住都发生了什么事情，为团队的每个人提供机会以张贴要谈论的话题，并试图将讨论定位在实际事件而非大概的预感上。事件时间线是一个短暂的中间成果，以帮助提醒团队都发生了什么事情，但它通常不作为回顾的最终产出。</p>\n<p><strong>总结教训</strong></p>\n<p>　　一旦对事件达成了一致的观点，团队就可以开始总结教训了。让团队按时间线从开始走到结束，其目的是确定：“什么是行之有效的，我们要记住?”，“下次有什么不同做法?” ，“什么还仍然困扰着我们?”。</p>\n<p>　　主持人阅读在时间线上的每个注解，并邀请他们作出评论。团队既要找出好的经验和也要总结坏的教训。这个阶段提醒团队是很重要的，我们的想法是要为未来的行动计划找出具体的解决方案。</p>\n<p>　　作为主持人，尝试抄写下写字板（或其他看得见的空间）上交流内容的摘要信息，但需与团队一起检查你所抄写的东西是否准确代表了原意。记下原始表达观点有助于显示一个人的关切已经受到了聆听。</p>\n<p>　　根据我的经验，开发者倾向于抽象地谈论一些事情——产生无确实证据的观点。作为主持人，深层挖掘、检查假设和推论（请开发者提供具体的例子来支持其所提出的观点）都是很重要的。</p>\n<p><strong>行动计划</strong></p>\n<p>　　通常，大多问题被确定但还不能立即采取行动。团队在开始计划行动前必须先发现问题。团队必须用现实的思维模式而非想象的思维模式。在迭代结束回顾中，不超过3至5项行动将是一个合理的限度。</p>\n<p>　　在设置任何新的行动之前，团队应该检查在以前的回顾中是否有出色的行动。如果有，值得探讨一下该行动为什么及是否需要重塑。有时人们确定行动时野心太大，需要减小他们所能实际实现的事情的范围。对每一项行动，尝试从下一步目标（可能是一小步）中分离出长远目标。团队甚至可能决定试试水，把采用新的工作方法改进流程作为实验，在下一次回顾时检验其效力。区分短期修改和解决根源问题也很重要。团队应该需要两种类型的行动，有本书提供了好的模式，用以区分行动的类型，它是Edward De Bono所著的“六双行动鞋”。</p>\n<p>　　每次行动都需要一个负责人负责交付，找个哥们儿并与其一起工作，以确保在下一次回顾之前完成行动，可能是一个好主意。有些行动可能是团队外界的直接势力范围，需要管理层支持。为获得支持，团队可能需要出售这些问题！在这种情况下，你的第一个行动是搜集证据，以帮助团队说服老板行动起来。</p>\n<p><strong>包装</strong></p>\n<p>　　在结束回顾之前，主持人需要明确会议将会有怎样的产出。团队可以在其工作区的墙纸墙上展示其行动。或者可以用数码相机记录下写字板纸&#x2F;白板上的内容，照片可以上传到一个文件共享空间或传送到团队的wiki上。在使产出在组织范围内可见之前，主持人需要与团队一起检查公布该产出是否令人不自在。</p>\n<p><strong>完善回顾</strong></p>\n<p>　　进行回顾有利于磨练你的主持技巧——回顾需要准备和全程跟随。主持人应该预先做完时间的分配工作并不时地改变练习。Esther Derby 和 Diana Larsen所著的“敏捷回顾”是新练习好的资料来源。它给出了一个粗的时间分配指导——团队每周需要30分钟回顾时间，按此计算，每月需要2小时、几个月需要一整天进行回顾。</p>\n<p>　　此外，为规划时间和形式，主持人还需要审查：谁应该来？在哪里举行会议？何时举行会议？当一个团队开始回顾，他们会发现他们团队内部付出了大量的行动。一旦团队有自己的房子，通常将与其他团队交互，扩大邀请名单以包括团队之外的人员以获取更广的视角，这样做是有价值的。</p>\n<p>　　作为团队领导或经理，当你有观点和看法想与大家分享的时，有时难以发挥中立调解者的角色。如果你与其他使用回顾的团队并肩工作，那么团队间可以互相推动。</p>\n<p>　　作为标准做法，在我的回顾结束时，我从参与者那儿收集了“投入时间回报”率，如果你正在尝试在组织内建立一个主持人团队，那么收集这些参与者反馈很可能将有助于新的主持人理解他们所做的事情。</p>\n<p>　　找到合适的会议场所能产生的效果有很大不同. 挑选一处远离你正常工作区的会议室可以避免人们在回顾到一半又转回到工作上。尽可能设法避免会议室的布局——围坐在一个大桌子周围立刻会给团队成员之间设置巨大的障碍——取而代之，你可以把几个椅子布置成半圆形。你还需要一下检查室内，至少要有两米长的干净墙壁或白板。当一个地点被登记用作回顾时，检查那儿有无空间能将纸挂在墙上是很重要的。有时我被安排在一个有大量墙纸、书架和古董书画的会议室主持回顾，只好利用门、窗或在桌子的尽头搞一个临时的张贴空间。</p>\n<p>　　至于时间，当工作在一个迭代计划周期内，你需要在下一个跌代计划之前举行回顾。但是如果接连举行回顾与计划会议将使每个人疲惫不堪，因此试着将这两个会议分成上下午，甚至单独一天。</p>\n<p><strong>最后一句话</strong></p>\n<p>　　有时我被一些想了解更多关于回顾的人问到这样的问题，“你能举例说明回顾能产生巨大的成果吗?”。我已认识到这个问题类似于“你能不能讲讲这种疾病是如何由正规的治疗方法治愈的?”</p>\n<p>　　我曾工作过一些团队，他们长期进行正规的心跳回顾已经使其发生了很大的变化，但这种改变是逐步的而缓慢的，他们并没有制造头条新闻。例如，我曾工作过的一个团队，有一个关于在计划产品开发跌代期间如何处理业务变更的问题。我们花了几个月的时间才为每个人建立了计划，但是如果没有回顾过程可能需要更多的时间。</p>\n<p>　　定期回顾和定期实践的能力是他们避免了重大问题的发生，所以没有战争故事或神奇的转变是应该的！拥抱回顾有助于一个团队以合适的步调来调整他们的过程。</p>\n<p><strong>作者简介</strong></p>\n<p>　　Rachel Davies是一个独立敏捷教练，位于在英国。 Rachel经常出席行业会议，她是敏捷联盟的理事。 欲与之联系，可以访问她的<a href=\"http://www.agilexp.com/\">网站</a> 。</p>\n","excerpt":"<blockquote>\n<p>英文原文：<a href=\"http://www.infoq.com/articles/agile-retrospectives-davies\">How To: Live and Learn with Retrospectives</a></p>\n</blockquote>\n<p>　　软件开发不是孤独的追击，它需要同其他开发者和其他部门协作。大多数组织建立的软件生命周期没有涉及到如何进行这些交互。现实是许多团队的过程并不符合他们的要求或没有得到一贯地遵循。当发生这种情况时，很容易让人产生抱怨情绪，如果你已经有了改进的想法却又无从下手，也会让人感到沮丧。本文提供了一个工具，可以帮助你的团队基于其日常经验进行过程改进。回顾是工具，团队可以利用它来产生积极的变化：从遵循过程到驾驭过程。</p>\n<p>　　回顾是会议，让整个团队都参与到检查过去的事件过程中，并对就今后如何更高效的工作进行头脑风暴。团队根据获得教训制定对应措施，并应用于自身。本文旨在说明为推动你的团队进行回顾，你需要做些什么。</p>","more":"<p><strong>背景</strong></p>\n<p>　　术语“回顾”是由Norman Kerth在其著作《项目回顾：团队审查手册》中创造的。书中描述了如何推动团队在项目结束时举行三天脱岗会议（off-site meetings），以总结经验教训。这种回顾是一种履行后检查（post-implementation review）——有时称为验尸（post-mortems）！等到项目结束时才开始总结经验教训是一件憾事。在2001年，极限编程团队将回顾纳入迭代周期。回顾被加入到另一种敏捷方法 —— Scrum中。并且，在项目生命周期内举行多次简短的“心跳”回顾，是现今采用敏捷方法团队普遍的做法，这使得他们能够在项目进行期间就能收集和总结其开发过程的经验教训，而不是等到项目结束后。</p>\n<p><strong>从经验中学习</strong></p>\n<p>　　没有经过反省的经验仅仅是数据而已。退一步说，反省我们的经验是我们日常生活中学习和转变的方式。举一个简单的例子，如果我在开车上班途中碰到了严重堵车，我会考虑换一条路径，甚至用其他方式赶到办公室。经过几次试验后，我会习惯于一个新的路径。</p>\n<p>　　如果人们不愿意做那些注定要重复的工作，说明他们并不是真正地在工作（有些疯狂的定义）。虽然回顾始于回首往事，但这样做的原因是为了改变我们未来的行事方法 —— 回顾是在进行长远地转变。有时候，我们必须重新思考我们的做法，而不是试图以加快现有过程。</p>\n<p>　　回顾还能改善团队沟通。有一个古老的格言“共享的问题就是减半的问题（a problem shared is a problem halved）”。把我们的经验复述给朋友和同事是我们日常生活中都做过的事情。在团队的成果中，没有人知道完整故事的始末。完整的故事只能通过整理个体经验来了解。通过探讨如何从不同的视角感知同一事件，团队成员能够更好的了解对方，并调整了团队中人们的需求。</p>\n<p><strong>化解定时炸弹</strong></p>\n<p>　　让我们看看如何举行一次有效的回顾。当团队一直受到压力或面临严重困难时，人们的脾气可能变大了，而且团队成员间的关系可能已经出了问题。指望通过把团队集中在房间里一起讨论近来发生的事情简直就是奇迹，这有点不切实际。像任何富有成果的会议一样，回顾需要明确的议程和主持人去保持会议平稳进行。如果没有这些措施，会谈很可能会充满批评和指责。这只会使进入房间的每个人发泄他们的不满情绪，不可能解决任何问题的，甚至还可能使问题加重。</p>\n<p>　　回顾采用精心设计的结构来消除分歧，将重点转移到学习和借鉴已有经验上。基本技巧是放慢谈话节奏，在完全探究大家对事件的不同看法之后，再下结论。<br>　　<br><strong>基本指令</strong></p>\n<p>　　检查过去的事件但不评判发生了什么，这更容易使我们转而问：下次是否可以做得更好? 关键是要采用系统思考的角度。为了对此有所帮助，应维持如下假设：问题出在系统创建期间而非个人，这是Norm Kerth所宣称的回顾基本指令，它是所有回顾的基本原则。\n　　</p>\n<blockquote>\n<p>基本指令：不管我们发现了什么，我们必须明白并真正相信，在给定时间、其自身的技能和能力、可用资源及最近状态的前提下，每个人都尽力做到了最好。</p>\n</blockquote>\n<p>　　该基本指令的意图经常被误解。显然，有时候人们乱作一团时 —— 或许他们不知道有更好做法，或许他们真的很懒或很残忍。但是在回顾过程中我们的焦点单单是做出改进，因而我们用该基本指令来帮助我们保持在处于有建设性的方式之中。至于个人的拙劣表现则最好交由管理者或人力资源（HR）部来处理，基本指令将这种交流设定在回顾的范围之外。</p>\n<p><strong>基本规则入门</strong></p>\n<p>　　为了有效进行回顾，需要有人推动会议。主持人应努力营造一种气氛，使团队成员对谈话感到轻松。</p>\n<p>　　设置基本规则和回顾目标有助于回顾顺利进行。还有一些明显地规则是适用于大多数有成效的会议的，比如设置手机为静音状态。那么我们还需要为回顾增加些什么特别地规则呢？听取每个人的意见是很重要的，因此一个重要的基本规则是“不要打断”，如果在某个激动的瞬间该规则受到了忽视，那么你可以尝试使用“说话棒” —— 某一时间只有一个人可以说话，即持有说话棒令牌的人（令牌不一定非是一根棒子，它可以是办公室的任何东西，如杯子。我所工作过团队用的是一个毛绒玩具，它比杯子更适合在屋里扔来扔去）。</p>\n<p>　　一旦会议基本规则建立起来了，就应该把规则写到活动挂图纸（flipchart paper）上，并张贴在人人都能看见的墙上。如果人们开始忘记基本规则了，那么主持人的工作就是提醒大家。例如，如果有人在会议室接听了电话，主持人应该和气地引导其离开，这样他的谈话内容不会干扰到回顾。</p>\n<p><strong>安全检查</strong></p>\n<p>　　另一项重要的基本规则是可选的，即在回顾中参与练习。有些人在小组讨论中可能感到不自在或被揭发了，如果你想让他们在回顾中作出贡献的话，不要在他们的感觉上再雪上加霜是很重要的。当一个团队做最初几次回顾时，执行“安全检查”是很有用的，以了解谁能轻松的对待谈话。来一个匿名投票可以做到这一点，匿名投票要求每个人说明他们多想在回顾中发言，在小纸片上写下范围从1到5的一个数字（1表示“不可能分享我的观点”，5表示“完全可以公开谈论”），主持人收集并统计这些选票，将结果张贴在房间的活动挂图（flipchart）上。此举目的是让与会者认识到，房间里人们相互信任程度是不同的，让主持人评估在随后的讨论中采用何种形势。如果个人的信任程度比较低，让人们在更小的组里工作，并做更多的练习（人们可以匿名的写出评论）是有效的做法。</p>\n<p><strong>动作回放</strong></p>\n<p>　　运动员利用动作回放来分析自己的动作并寻求改进。在回顾里与之等价的是时间线（Timeline）。</p>\n<p>　　首先为团队建立一个空间，将过去的事件按发生顺序张贴出来；从左至右，从过去到现在。每个团队成员用彩色便签（或索引卡）加入时间线。主持人为每种颜色的卡片定义一重含义。例如，粉红——消极事件，黄——中性事件，绿——积极事件。用颜色有助于在这一系列事件中显示出图案。会议的这一部分通常进行地很快，因为团队成员是并行建立一个共同的图案。</p>\n<p>　　创建时间线的练习有几个服务宗旨——帮助团队记住都发生了什么事情，为团队的每个人提供机会以张贴要谈论的话题，并试图将讨论定位在实际事件而非大概的预感上。事件时间线是一个短暂的中间成果，以帮助提醒团队都发生了什么事情，但它通常不作为回顾的最终产出。</p>\n<p><strong>总结教训</strong></p>\n<p>　　一旦对事件达成了一致的观点，团队就可以开始总结教训了。让团队按时间线从开始走到结束，其目的是确定：“什么是行之有效的，我们要记住?”，“下次有什么不同做法?” ，“什么还仍然困扰着我们?”。</p>\n<p>　　主持人阅读在时间线上的每个注解，并邀请他们作出评论。团队既要找出好的经验和也要总结坏的教训。这个阶段提醒团队是很重要的，我们的想法是要为未来的行动计划找出具体的解决方案。</p>\n<p>　　作为主持人，尝试抄写下写字板（或其他看得见的空间）上交流内容的摘要信息，但需与团队一起检查你所抄写的东西是否准确代表了原意。记下原始表达观点有助于显示一个人的关切已经受到了聆听。</p>\n<p>　　根据我的经验，开发者倾向于抽象地谈论一些事情——产生无确实证据的观点。作为主持人，深层挖掘、检查假设和推论（请开发者提供具体的例子来支持其所提出的观点）都是很重要的。</p>\n<p><strong>行动计划</strong></p>\n<p>　　通常，大多问题被确定但还不能立即采取行动。团队在开始计划行动前必须先发现问题。团队必须用现实的思维模式而非想象的思维模式。在迭代结束回顾中，不超过3至5项行动将是一个合理的限度。</p>\n<p>　　在设置任何新的行动之前，团队应该检查在以前的回顾中是否有出色的行动。如果有，值得探讨一下该行动为什么及是否需要重塑。有时人们确定行动时野心太大，需要减小他们所能实际实现的事情的范围。对每一项行动，尝试从下一步目标（可能是一小步）中分离出长远目标。团队甚至可能决定试试水，把采用新的工作方法改进流程作为实验，在下一次回顾时检验其效力。区分短期修改和解决根源问题也很重要。团队应该需要两种类型的行动，有本书提供了好的模式，用以区分行动的类型，它是Edward De Bono所著的“六双行动鞋”。</p>\n<p>　　每次行动都需要一个负责人负责交付，找个哥们儿并与其一起工作，以确保在下一次回顾之前完成行动，可能是一个好主意。有些行动可能是团队外界的直接势力范围，需要管理层支持。为获得支持，团队可能需要出售这些问题！在这种情况下，你的第一个行动是搜集证据，以帮助团队说服老板行动起来。</p>\n<p><strong>包装</strong></p>\n<p>　　在结束回顾之前，主持人需要明确会议将会有怎样的产出。团队可以在其工作区的墙纸墙上展示其行动。或者可以用数码相机记录下写字板纸&#x2F;白板上的内容，照片可以上传到一个文件共享空间或传送到团队的wiki上。在使产出在组织范围内可见之前，主持人需要与团队一起检查公布该产出是否令人不自在。</p>\n<p><strong>完善回顾</strong></p>\n<p>　　进行回顾有利于磨练你的主持技巧——回顾需要准备和全程跟随。主持人应该预先做完时间的分配工作并不时地改变练习。Esther Derby 和 Diana Larsen所著的“敏捷回顾”是新练习好的资料来源。它给出了一个粗的时间分配指导——团队每周需要30分钟回顾时间，按此计算，每月需要2小时、几个月需要一整天进行回顾。</p>\n<p>　　此外，为规划时间和形式，主持人还需要审查：谁应该来？在哪里举行会议？何时举行会议？当一个团队开始回顾，他们会发现他们团队内部付出了大量的行动。一旦团队有自己的房子，通常将与其他团队交互，扩大邀请名单以包括团队之外的人员以获取更广的视角，这样做是有价值的。</p>\n<p>　　作为团队领导或经理，当你有观点和看法想与大家分享的时，有时难以发挥中立调解者的角色。如果你与其他使用回顾的团队并肩工作，那么团队间可以互相推动。</p>\n<p>　　作为标准做法，在我的回顾结束时，我从参与者那儿收集了“投入时间回报”率，如果你正在尝试在组织内建立一个主持人团队，那么收集这些参与者反馈很可能将有助于新的主持人理解他们所做的事情。</p>\n<p>　　找到合适的会议场所能产生的效果有很大不同. 挑选一处远离你正常工作区的会议室可以避免人们在回顾到一半又转回到工作上。尽可能设法避免会议室的布局——围坐在一个大桌子周围立刻会给团队成员之间设置巨大的障碍——取而代之，你可以把几个椅子布置成半圆形。你还需要一下检查室内，至少要有两米长的干净墙壁或白板。当一个地点被登记用作回顾时，检查那儿有无空间能将纸挂在墙上是很重要的。有时我被安排在一个有大量墙纸、书架和古董书画的会议室主持回顾，只好利用门、窗或在桌子的尽头搞一个临时的张贴空间。</p>\n<p>　　至于时间，当工作在一个迭代计划周期内，你需要在下一个跌代计划之前举行回顾。但是如果接连举行回顾与计划会议将使每个人疲惫不堪，因此试着将这两个会议分成上下午，甚至单独一天。</p>\n<p><strong>最后一句话</strong></p>\n<p>　　有时我被一些想了解更多关于回顾的人问到这样的问题，“你能举例说明回顾能产生巨大的成果吗?”。我已认识到这个问题类似于“你能不能讲讲这种疾病是如何由正规的治疗方法治愈的?”</p>\n<p>　　我曾工作过一些团队，他们长期进行正规的心跳回顾已经使其发生了很大的变化，但这种改变是逐步的而缓慢的，他们并没有制造头条新闻。例如，我曾工作过的一个团队，有一个关于在计划产品开发跌代期间如何处理业务变更的问题。我们花了几个月的时间才为每个人建立了计划，但是如果没有回顾过程可能需要更多的时间。</p>\n<p>　　定期回顾和定期实践的能力是他们避免了重大问题的发生，所以没有战争故事或神奇的转变是应该的！拥抱回顾有助于一个团队以合适的步调来调整他们的过程。</p>\n<p><strong>作者简介</strong></p>\n<p>　　Rachel Davies是一个独立敏捷教练，位于在英国。 Rachel经常出席行业会议，她是敏捷联盟的理事。 欲与之联系，可以访问她的<a href=\"http://www.agilexp.com/\">网站</a> 。</p>"},{"title":"Redis系列-存储篇set操作","date":"2015-07-25T10:34:39.000Z","_content":"\n>redis set 是string类型对象的无序集合，set不管存储多少对象，对存储对象的add，remove和test操作的时间复杂度是O(1)。set最多能包含 232 - 1 个member。\n\n<!--more-->\n\n1.增加\n---\n>语法：sadd key member[member...]\n\n解释：对特定key的set增加一个或多个值，返回是增加元素的个数。注意：对同一个member多次add，set中只会保留一份。\n\n    [root@xsf001 ~]# redis-cli   \n    redis 127.0.0.1:6379> sadd stu zhangsan lisi wangwu #新增  \n    (integer) 3  \n    redis 127.0.0.1:6379> smembers stu    #得到set的所有member  \n    1) \"wangwu\"  \n    2) \"lisi\"  \n    3) \"zhangsan\"  \n    redis 127.0.0.1:6379> sadd stu zhangsan #增加存在的member  \n    (integer) 0  \n    redis 127.0.0.1:6379> smembers stu  \n    1) \"wangwu\"  \n    2) \"lisi\"  \n    3) \"zhangsan\"  \n    redis 127.0.0.1:6379> sadd tech wangwu liming joe  \n    (integer) 3  \n    redis 127.0.0.1:6379> sadd tech jim  \n    (integer) 1  \n    redis 127.0.0.1:6379> smembers tech  \n    1) \"jim\"  \n    2) \"liming\"  \n    3) \"wangwu\"  \n    4) \"joe\"\n2.查询\n---\n>smembers\n>语法：smembers key\n\n解释：获取set中的所有member\n\n    redis 127.0.0.1:6379> smembers stu  \n    1) \"wangwu\"  \n    2) \"lisi\"  \n    3) \"zhangsan\"  \n    redis 127.0.0.1:6379> smembers tech  \n    1) \"jim\"  \n    2) \"liming\"  \n    3) \"wangwu\"  \n    4) \"joe\" \n    \n\n>sismember\n>语法：sismember key member\n\n解释：判断值是否是set的member。如果值是set的member返回1，否则，返回0\n\n    redis 127.0.0.1:6379> sismember tech jim #jim 是set的member  \n    (integer) 1  \n    redis 127.0.0.1:6379> sismember tech jim001 #jim001 不是set的member  \n    (integer) 0 \n    \n\n>scard\n>语法：scard key\n\n解释：返回set的member个数，如果set不存在，返回0\n\n    redis 127.0.0.1:6379> scard tech  # tech 存在  \n    (integer) 4  \n    redis 127.0.0.1:6379> scard stud #stud 不存在  \n    (integer) 0  \n    redis 127.0.0.1:6379> scard stu  \n    (integer) 4\n    \n\n>srandmember\n>语法：srandmember key\n\n解释：从set中返回一个随机member\n\n    redis 127.0.0.1:6379> srandmember stu  \n    \"zhangsan\"  \n    redis 127.0.0.1:6379> srandmember stu  \n    \"zhangsan\"  \n    redis 127.0.0.1:6379> srandmember stu  \n    \"wangwu\"  \n    redis 127.0.0.1:6379> srandmember stu  \n    \"zhangsan01\" \n    \n3.删除\n---\n>spop\n>语法：spop key\n\n解释：移除并返回一个随机member\n\n    redis 127.0.0.1:6379> smembers stu #pop前  \n    1) \"zhangsan01\"  \n    2) \"wangwu\"  \n    3) \"lisi\"  \n    4) \"zhangsan\"  \n    redis 127.0.0.1:6379> spop stu  #移除一个随机member  \n    \"lisi\"  \n    redis 127.0.0.1:6379> smembers stu #pop后  \n    1) \"zhangsan01\"<span style=\"white-space:pre\">   </span>  \n    2) \"wangwu\"  \n    3) \"zhangsan\"\n    \n    \n\n>srem\n>语法：srem key member [member ...]\n\n解释：移除一个或多个member\n\n    redis 127.0.0.1:6379> smembers tech  \n    1) \"jim\"  \n    2) \"liming\"  \n    3) \"wangwu\"  \n    4) \"joe\"  \n    redis 127.0.0.1:6379> srem tech jim   #移除jim  \n    (integer) 1  \n    redis 127.0.0.1:6379> smembers tech     \n    1) \"liming\"  \n    2) \"wangwu\"  \n    3) \"joe\"  \n    redis 127.0.0.1:6379> srem tech liming joe #移除多个member  \n    (integer) 2  \n    redis 127.0.0.1:6379> smembers tech  \n    1) \"wangwu\"\n    \n    \n\n>smove\n>语法：smove source destination member\n\n解释：将source中的member移动到destination\n\n    redis 127.0.0.1:6379> smembers tech   #smove前  \n    1) \"wangwu\"  \n    redis 127.0.0.1:6379> smembers stu  \n    1) \"zhangsan01\"  \n    2) \"wangwu\"  \n    3) \"zhangsan\"  \n    redis 127.0.0.1:6379> smove stu tech zhangsan  #将zhangsan 从stu移动到tech  \n    (integer) 1  \n    redis 127.0.0.1:6379> smembers stu #smove后  \n    1) \"zhangsan01\"  \n    2) \"wangwu\"  \n    redis 127.0.0.1:6379> smembers tech  \n    1) \"wangwu\"  \n    2) \"zhangsan\"\n    \n\n4.其他\n---\n>并集\n>语法：sunion key[key...]\n\n解释：多个set的并集\n\n    redis 127.0.0.1:6379> smembers stu  \n    1) \"zhangsan01\"  \n    2) \"wangwu\"  \n    redis 127.0.0.1:6379> sunion stu  \n    1) \"zhangsan01\"  \n    2) \"wangwu\"  \n    redis 127.0.0.1:6379> smembers tech  \n    1) \"wangwu\"  \n    2) \"zhangsan\"  \n    redis 127.0.0.1:6379> sunion stu tech  \n    1) \"zhangsan01\"  \n    2) \"wangwu\"  \n    3) \"zhangsan\"\n    \n    \n\n>把并集结果存储到set\n>语法：sunionstore destination key [key ...]\n\n解释：求多个set并集，并把结果存储到destination \n\n    redis 127.0.0.1:6379> sunionstore same stu tech #把stu tech并集结果存储在union  \n    (integer) 3  \n    redis 127.0.0.1:6379> smembers union  \n    1) \"zhangsan01\"  \n    2) \"wangwu\"  \n    3) \"zhangsan\"\n    \n    \n\n>交集\n>语法：sinter key[key...]\n\n解释：多个set的交集\n\n    redis 127.0.0.1:6379> smembers stu  \n    1) \"zhangsan01\"  \n    2) \"wangwu\"  \n    redis 127.0.0.1:6379> smembers tech  \n    1) \"wangwu\"  \n    2) \"zhangsan\"  \n    redis 127.0.0.1:6379> sinter stu tech  \n    1) \"wangwu\"\n    \n\n>把交集结果存储到指定set\n>语法：sinterstore destination key [key ...]\n\n解释：把多个set的交集结果存储到destination \n\n    redis 127.0.0.1:6379> sinterstore inter stu tech  \n    (integer) 1  \n    redis 127.0.0.1:6379> smembers inter  \n    1) \"wangwu\"\n    \n\n>set中在其他set中不存在member\n>语法：sdiff key[key ...]\n\n    redis 127.0.0.1:6379>   \n    redis 127.0.0.1:6379> smembers stu  \n    1) \"zhangsan01\"  \n    2) \"wangwu\"  \n    redis 127.0.0.1:6379> smembers tech  \n    1) \"wangwu\"  \n    2) \"zhangsan\"  \n    redis 127.0.0.1:6379> sdiff stu tech  \n    1) \"zhangsan01\"  \n    redis 127.0.0.1:6379> sdiff tech stu  \n    1) \"zhangsan\"\n    \n\n>把set中在其他set中不存在的member存储到新的set\n>语法：sdiffstore key[key...]\n\n    redis 127.0.0.1:6379> sdiffstore diff stu tech  \n    (integer) 1  \n    redis 127.0.0.1:6379> smembers diff  \n    1) \"zhangsan01\"\n    \n\n[http://redis.io/commands#set](http://redis.io/commands#set)\n","source":"_posts/redis-set.md","raw":"title:  Redis系列-存储篇set操作\ndate: 2015-07-25 18:34:39\ncategories: 技术\n---\n\n>redis set 是string类型对象的无序集合，set不管存储多少对象，对存储对象的add，remove和test操作的时间复杂度是O(1)。set最多能包含 232 - 1 个member。\n\n<!--more-->\n\n1.增加\n---\n>语法：sadd key member[member...]\n\n解释：对特定key的set增加一个或多个值，返回是增加元素的个数。注意：对同一个member多次add，set中只会保留一份。\n\n    [root@xsf001 ~]# redis-cli   \n    redis 127.0.0.1:6379> sadd stu zhangsan lisi wangwu #新增  \n    (integer) 3  \n    redis 127.0.0.1:6379> smembers stu    #得到set的所有member  \n    1) \"wangwu\"  \n    2) \"lisi\"  \n    3) \"zhangsan\"  \n    redis 127.0.0.1:6379> sadd stu zhangsan #增加存在的member  \n    (integer) 0  \n    redis 127.0.0.1:6379> smembers stu  \n    1) \"wangwu\"  \n    2) \"lisi\"  \n    3) \"zhangsan\"  \n    redis 127.0.0.1:6379> sadd tech wangwu liming joe  \n    (integer) 3  \n    redis 127.0.0.1:6379> sadd tech jim  \n    (integer) 1  \n    redis 127.0.0.1:6379> smembers tech  \n    1) \"jim\"  \n    2) \"liming\"  \n    3) \"wangwu\"  \n    4) \"joe\"\n2.查询\n---\n>smembers\n>语法：smembers key\n\n解释：获取set中的所有member\n\n    redis 127.0.0.1:6379> smembers stu  \n    1) \"wangwu\"  \n    2) \"lisi\"  \n    3) \"zhangsan\"  \n    redis 127.0.0.1:6379> smembers tech  \n    1) \"jim\"  \n    2) \"liming\"  \n    3) \"wangwu\"  \n    4) \"joe\" \n    \n\n>sismember\n>语法：sismember key member\n\n解释：判断值是否是set的member。如果值是set的member返回1，否则，返回0\n\n    redis 127.0.0.1:6379> sismember tech jim #jim 是set的member  \n    (integer) 1  \n    redis 127.0.0.1:6379> sismember tech jim001 #jim001 不是set的member  \n    (integer) 0 \n    \n\n>scard\n>语法：scard key\n\n解释：返回set的member个数，如果set不存在，返回0\n\n    redis 127.0.0.1:6379> scard tech  # tech 存在  \n    (integer) 4  \n    redis 127.0.0.1:6379> scard stud #stud 不存在  \n    (integer) 0  \n    redis 127.0.0.1:6379> scard stu  \n    (integer) 4\n    \n\n>srandmember\n>语法：srandmember key\n\n解释：从set中返回一个随机member\n\n    redis 127.0.0.1:6379> srandmember stu  \n    \"zhangsan\"  \n    redis 127.0.0.1:6379> srandmember stu  \n    \"zhangsan\"  \n    redis 127.0.0.1:6379> srandmember stu  \n    \"wangwu\"  \n    redis 127.0.0.1:6379> srandmember stu  \n    \"zhangsan01\" \n    \n3.删除\n---\n>spop\n>语法：spop key\n\n解释：移除并返回一个随机member\n\n    redis 127.0.0.1:6379> smembers stu #pop前  \n    1) \"zhangsan01\"  \n    2) \"wangwu\"  \n    3) \"lisi\"  \n    4) \"zhangsan\"  \n    redis 127.0.0.1:6379> spop stu  #移除一个随机member  \n    \"lisi\"  \n    redis 127.0.0.1:6379> smembers stu #pop后  \n    1) \"zhangsan01\"<span style=\"white-space:pre\">   </span>  \n    2) \"wangwu\"  \n    3) \"zhangsan\"\n    \n    \n\n>srem\n>语法：srem key member [member ...]\n\n解释：移除一个或多个member\n\n    redis 127.0.0.1:6379> smembers tech  \n    1) \"jim\"  \n    2) \"liming\"  \n    3) \"wangwu\"  \n    4) \"joe\"  \n    redis 127.0.0.1:6379> srem tech jim   #移除jim  \n    (integer) 1  \n    redis 127.0.0.1:6379> smembers tech     \n    1) \"liming\"  \n    2) \"wangwu\"  \n    3) \"joe\"  \n    redis 127.0.0.1:6379> srem tech liming joe #移除多个member  \n    (integer) 2  \n    redis 127.0.0.1:6379> smembers tech  \n    1) \"wangwu\"\n    \n    \n\n>smove\n>语法：smove source destination member\n\n解释：将source中的member移动到destination\n\n    redis 127.0.0.1:6379> smembers tech   #smove前  \n    1) \"wangwu\"  \n    redis 127.0.0.1:6379> smembers stu  \n    1) \"zhangsan01\"  \n    2) \"wangwu\"  \n    3) \"zhangsan\"  \n    redis 127.0.0.1:6379> smove stu tech zhangsan  #将zhangsan 从stu移动到tech  \n    (integer) 1  \n    redis 127.0.0.1:6379> smembers stu #smove后  \n    1) \"zhangsan01\"  \n    2) \"wangwu\"  \n    redis 127.0.0.1:6379> smembers tech  \n    1) \"wangwu\"  \n    2) \"zhangsan\"\n    \n\n4.其他\n---\n>并集\n>语法：sunion key[key...]\n\n解释：多个set的并集\n\n    redis 127.0.0.1:6379> smembers stu  \n    1) \"zhangsan01\"  \n    2) \"wangwu\"  \n    redis 127.0.0.1:6379> sunion stu  \n    1) \"zhangsan01\"  \n    2) \"wangwu\"  \n    redis 127.0.0.1:6379> smembers tech  \n    1) \"wangwu\"  \n    2) \"zhangsan\"  \n    redis 127.0.0.1:6379> sunion stu tech  \n    1) \"zhangsan01\"  \n    2) \"wangwu\"  \n    3) \"zhangsan\"\n    \n    \n\n>把并集结果存储到set\n>语法：sunionstore destination key [key ...]\n\n解释：求多个set并集，并把结果存储到destination \n\n    redis 127.0.0.1:6379> sunionstore same stu tech #把stu tech并集结果存储在union  \n    (integer) 3  \n    redis 127.0.0.1:6379> smembers union  \n    1) \"zhangsan01\"  \n    2) \"wangwu\"  \n    3) \"zhangsan\"\n    \n    \n\n>交集\n>语法：sinter key[key...]\n\n解释：多个set的交集\n\n    redis 127.0.0.1:6379> smembers stu  \n    1) \"zhangsan01\"  \n    2) \"wangwu\"  \n    redis 127.0.0.1:6379> smembers tech  \n    1) \"wangwu\"  \n    2) \"zhangsan\"  \n    redis 127.0.0.1:6379> sinter stu tech  \n    1) \"wangwu\"\n    \n\n>把交集结果存储到指定set\n>语法：sinterstore destination key [key ...]\n\n解释：把多个set的交集结果存储到destination \n\n    redis 127.0.0.1:6379> sinterstore inter stu tech  \n    (integer) 1  \n    redis 127.0.0.1:6379> smembers inter  \n    1) \"wangwu\"\n    \n\n>set中在其他set中不存在member\n>语法：sdiff key[key ...]\n\n    redis 127.0.0.1:6379>   \n    redis 127.0.0.1:6379> smembers stu  \n    1) \"zhangsan01\"  \n    2) \"wangwu\"  \n    redis 127.0.0.1:6379> smembers tech  \n    1) \"wangwu\"  \n    2) \"zhangsan\"  \n    redis 127.0.0.1:6379> sdiff stu tech  \n    1) \"zhangsan01\"  \n    redis 127.0.0.1:6379> sdiff tech stu  \n    1) \"zhangsan\"\n    \n\n>把set中在其他set中不存在的member存储到新的set\n>语法：sdiffstore key[key...]\n\n    redis 127.0.0.1:6379> sdiffstore diff stu tech  \n    (integer) 1  \n    redis 127.0.0.1:6379> smembers diff  \n    1) \"zhangsan01\"\n    \n\n[http://redis.io/commands#set](http://redis.io/commands#set)\n","slug":"redis-set","published":1,"updated":"2024-04-11T13:25:35.655Z","comments":1,"layout":"post","photos":[],"_id":"cluvablv5000kcbih9aj6bxfq","content":"<blockquote>\n<p>redis set 是string类型对象的无序集合，set不管存储多少对象，对存储对象的add，remove和test操作的时间复杂度是O(1)。set最多能包含 232 - 1 个member。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"1-增加\"><a href=\"#1-增加\" class=\"headerlink\" title=\"1.增加\"></a>1.增加</h2><blockquote>\n<p>语法：sadd key member[member…]</p>\n</blockquote>\n<p>解释：对特定key的set增加一个或多个值，返回是增加元素的个数。注意：对同一个member多次add，set中只会保留一份。</p>\n<pre><code>[root@xsf001 ~]# redis-cli   \nredis 127.0.0.1:6379&gt; sadd stu zhangsan lisi wangwu #新增  \n(integer) 3  \nredis 127.0.0.1:6379&gt; smembers stu    #得到set的所有member  \n1) &quot;wangwu&quot;  \n2) &quot;lisi&quot;  \n3) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; sadd stu zhangsan #增加存在的member  \n(integer) 0  \nredis 127.0.0.1:6379&gt; smembers stu  \n1) &quot;wangwu&quot;  \n2) &quot;lisi&quot;  \n3) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; sadd tech wangwu liming joe  \n(integer) 3  \nredis 127.0.0.1:6379&gt; sadd tech jim  \n(integer) 1  \nredis 127.0.0.1:6379&gt; smembers tech  \n1) &quot;jim&quot;  \n2) &quot;liming&quot;  \n3) &quot;wangwu&quot;  \n4) &quot;joe&quot;\n</code></pre>\n<h2 id=\"2-查询\"><a href=\"#2-查询\" class=\"headerlink\" title=\"2.查询\"></a>2.查询</h2><blockquote>\n<p>smembers<br>语法：smembers key</p>\n</blockquote>\n<p>解释：获取set中的所有member</p>\n<pre><code>redis 127.0.0.1:6379&gt; smembers stu  \n1) &quot;wangwu&quot;  \n2) &quot;lisi&quot;  \n3) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; smembers tech  \n1) &quot;jim&quot;  \n2) &quot;liming&quot;  \n3) &quot;wangwu&quot;  \n4) &quot;joe&quot; \n</code></pre>\n<blockquote>\n<p>sismember<br>语法：sismember key member</p>\n</blockquote>\n<p>解释：判断值是否是set的member。如果值是set的member返回1，否则，返回0</p>\n<pre><code>redis 127.0.0.1:6379&gt; sismember tech jim #jim 是set的member  \n(integer) 1  \nredis 127.0.0.1:6379&gt; sismember tech jim001 #jim001 不是set的member  \n(integer) 0 \n</code></pre>\n<blockquote>\n<p>scard<br>语法：scard key</p>\n</blockquote>\n<p>解释：返回set的member个数，如果set不存在，返回0</p>\n<pre><code>redis 127.0.0.1:6379&gt; scard tech  # tech 存在  \n(integer) 4  \nredis 127.0.0.1:6379&gt; scard stud #stud 不存在  \n(integer) 0  \nredis 127.0.0.1:6379&gt; scard stu  \n(integer) 4\n</code></pre>\n<blockquote>\n<p>srandmember<br>语法：srandmember key</p>\n</blockquote>\n<p>解释：从set中返回一个随机member</p>\n<pre><code>redis 127.0.0.1:6379&gt; srandmember stu  \n&quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; srandmember stu  \n&quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; srandmember stu  \n&quot;wangwu&quot;  \nredis 127.0.0.1:6379&gt; srandmember stu  \n&quot;zhangsan01&quot; \n</code></pre>\n<h2 id=\"3-删除\"><a href=\"#3-删除\" class=\"headerlink\" title=\"3.删除\"></a>3.删除</h2><blockquote>\n<p>spop<br>语法：spop key</p>\n</blockquote>\n<p>解释：移除并返回一个随机member</p>\n<pre><code>redis 127.0.0.1:6379&gt; smembers stu #pop前  \n1) &quot;zhangsan01&quot;  \n2) &quot;wangwu&quot;  \n3) &quot;lisi&quot;  \n4) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; spop stu  #移除一个随机member  \n&quot;lisi&quot;  \nredis 127.0.0.1:6379&gt; smembers stu #pop后  \n1) &quot;zhangsan01&quot;&lt;span style=&quot;white-space:pre&quot;&gt;   &lt;/span&gt;  \n2) &quot;wangwu&quot;  \n3) &quot;zhangsan&quot;\n</code></pre>\n<blockquote>\n<p>srem<br>语法：srem key member [member …]</p>\n</blockquote>\n<p>解释：移除一个或多个member</p>\n<pre><code>redis 127.0.0.1:6379&gt; smembers tech  \n1) &quot;jim&quot;  \n2) &quot;liming&quot;  \n3) &quot;wangwu&quot;  \n4) &quot;joe&quot;  \nredis 127.0.0.1:6379&gt; srem tech jim   #移除jim  \n(integer) 1  \nredis 127.0.0.1:6379&gt; smembers tech     \n1) &quot;liming&quot;  \n2) &quot;wangwu&quot;  \n3) &quot;joe&quot;  \nredis 127.0.0.1:6379&gt; srem tech liming joe #移除多个member  \n(integer) 2  \nredis 127.0.0.1:6379&gt; smembers tech  \n1) &quot;wangwu&quot;\n</code></pre>\n<blockquote>\n<p>smove<br>语法：smove source destination member</p>\n</blockquote>\n<p>解释：将source中的member移动到destination</p>\n<pre><code>redis 127.0.0.1:6379&gt; smembers tech   #smove前  \n1) &quot;wangwu&quot;  \nredis 127.0.0.1:6379&gt; smembers stu  \n1) &quot;zhangsan01&quot;  \n2) &quot;wangwu&quot;  \n3) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; smove stu tech zhangsan  #将zhangsan 从stu移动到tech  \n(integer) 1  \nredis 127.0.0.1:6379&gt; smembers stu #smove后  \n1) &quot;zhangsan01&quot;  \n2) &quot;wangwu&quot;  \nredis 127.0.0.1:6379&gt; smembers tech  \n1) &quot;wangwu&quot;  \n2) &quot;zhangsan&quot;\n</code></pre>\n<h2 id=\"4-其他\"><a href=\"#4-其他\" class=\"headerlink\" title=\"4.其他\"></a>4.其他</h2><blockquote>\n<p>并集<br>语法：sunion key[key…]</p>\n</blockquote>\n<p>解释：多个set的并集</p>\n<pre><code>redis 127.0.0.1:6379&gt; smembers stu  \n1) &quot;zhangsan01&quot;  \n2) &quot;wangwu&quot;  \nredis 127.0.0.1:6379&gt; sunion stu  \n1) &quot;zhangsan01&quot;  \n2) &quot;wangwu&quot;  \nredis 127.0.0.1:6379&gt; smembers tech  \n1) &quot;wangwu&quot;  \n2) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; sunion stu tech  \n1) &quot;zhangsan01&quot;  \n2) &quot;wangwu&quot;  \n3) &quot;zhangsan&quot;\n</code></pre>\n<blockquote>\n<p>把并集结果存储到set<br>语法：sunionstore destination key [key …]</p>\n</blockquote>\n<p>解释：求多个set并集，并把结果存储到destination </p>\n<pre><code>redis 127.0.0.1:6379&gt; sunionstore same stu tech #把stu tech并集结果存储在union  \n(integer) 3  \nredis 127.0.0.1:6379&gt; smembers union  \n1) &quot;zhangsan01&quot;  \n2) &quot;wangwu&quot;  \n3) &quot;zhangsan&quot;\n</code></pre>\n<blockquote>\n<p>交集<br>语法：sinter key[key…]</p>\n</blockquote>\n<p>解释：多个set的交集</p>\n<pre><code>redis 127.0.0.1:6379&gt; smembers stu  \n1) &quot;zhangsan01&quot;  \n2) &quot;wangwu&quot;  \nredis 127.0.0.1:6379&gt; smembers tech  \n1) &quot;wangwu&quot;  \n2) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; sinter stu tech  \n1) &quot;wangwu&quot;\n</code></pre>\n<blockquote>\n<p>把交集结果存储到指定set<br>语法：sinterstore destination key [key …]</p>\n</blockquote>\n<p>解释：把多个set的交集结果存储到destination </p>\n<pre><code>redis 127.0.0.1:6379&gt; sinterstore inter stu tech  \n(integer) 1  \nredis 127.0.0.1:6379&gt; smembers inter  \n1) &quot;wangwu&quot;\n</code></pre>\n<blockquote>\n<p>set中在其他set中不存在member<br>语法：sdiff key[key …]</p>\n</blockquote>\n<pre><code>redis 127.0.0.1:6379&gt;   \nredis 127.0.0.1:6379&gt; smembers stu  \n1) &quot;zhangsan01&quot;  \n2) &quot;wangwu&quot;  \nredis 127.0.0.1:6379&gt; smembers tech  \n1) &quot;wangwu&quot;  \n2) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; sdiff stu tech  \n1) &quot;zhangsan01&quot;  \nredis 127.0.0.1:6379&gt; sdiff tech stu  \n1) &quot;zhangsan&quot;\n</code></pre>\n<blockquote>\n<p>把set中在其他set中不存在的member存储到新的set<br>语法：sdiffstore key[key…]</p>\n</blockquote>\n<pre><code>redis 127.0.0.1:6379&gt; sdiffstore diff stu tech  \n(integer) 1  \nredis 127.0.0.1:6379&gt; smembers diff  \n1) &quot;zhangsan01&quot;\n</code></pre>\n<p><a href=\"http://redis.io/commands#set\">http://redis.io/commands#set</a></p>\n","excerpt":"<blockquote>\n<p>redis set 是string类型对象的无序集合，set不管存储多少对象，对存储对象的add，remove和test操作的时间复杂度是O(1)。set最多能包含 232 - 1 个member。</p>\n</blockquote>","more":"<h2 id=\"1-增加\"><a href=\"#1-增加\" class=\"headerlink\" title=\"1.增加\"></a>1.增加</h2><blockquote>\n<p>语法：sadd key member[member…]</p>\n</blockquote>\n<p>解释：对特定key的set增加一个或多个值，返回是增加元素的个数。注意：对同一个member多次add，set中只会保留一份。</p>\n<pre><code>[root@xsf001 ~]# redis-cli   \nredis 127.0.0.1:6379&gt; sadd stu zhangsan lisi wangwu #新增  \n(integer) 3  \nredis 127.0.0.1:6379&gt; smembers stu    #得到set的所有member  \n1) &quot;wangwu&quot;  \n2) &quot;lisi&quot;  \n3) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; sadd stu zhangsan #增加存在的member  \n(integer) 0  \nredis 127.0.0.1:6379&gt; smembers stu  \n1) &quot;wangwu&quot;  \n2) &quot;lisi&quot;  \n3) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; sadd tech wangwu liming joe  \n(integer) 3  \nredis 127.0.0.1:6379&gt; sadd tech jim  \n(integer) 1  \nredis 127.0.0.1:6379&gt; smembers tech  \n1) &quot;jim&quot;  \n2) &quot;liming&quot;  \n3) &quot;wangwu&quot;  \n4) &quot;joe&quot;\n</code></pre>\n<h2 id=\"2-查询\"><a href=\"#2-查询\" class=\"headerlink\" title=\"2.查询\"></a>2.查询</h2><blockquote>\n<p>smembers<br>语法：smembers key</p>\n</blockquote>\n<p>解释：获取set中的所有member</p>\n<pre><code>redis 127.0.0.1:6379&gt; smembers stu  \n1) &quot;wangwu&quot;  \n2) &quot;lisi&quot;  \n3) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; smembers tech  \n1) &quot;jim&quot;  \n2) &quot;liming&quot;  \n3) &quot;wangwu&quot;  \n4) &quot;joe&quot; \n</code></pre>\n<blockquote>\n<p>sismember<br>语法：sismember key member</p>\n</blockquote>\n<p>解释：判断值是否是set的member。如果值是set的member返回1，否则，返回0</p>\n<pre><code>redis 127.0.0.1:6379&gt; sismember tech jim #jim 是set的member  \n(integer) 1  \nredis 127.0.0.1:6379&gt; sismember tech jim001 #jim001 不是set的member  \n(integer) 0 \n</code></pre>\n<blockquote>\n<p>scard<br>语法：scard key</p>\n</blockquote>\n<p>解释：返回set的member个数，如果set不存在，返回0</p>\n<pre><code>redis 127.0.0.1:6379&gt; scard tech  # tech 存在  \n(integer) 4  \nredis 127.0.0.1:6379&gt; scard stud #stud 不存在  \n(integer) 0  \nredis 127.0.0.1:6379&gt; scard stu  \n(integer) 4\n</code></pre>\n<blockquote>\n<p>srandmember<br>语法：srandmember key</p>\n</blockquote>\n<p>解释：从set中返回一个随机member</p>\n<pre><code>redis 127.0.0.1:6379&gt; srandmember stu  \n&quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; srandmember stu  \n&quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; srandmember stu  \n&quot;wangwu&quot;  \nredis 127.0.0.1:6379&gt; srandmember stu  \n&quot;zhangsan01&quot; \n</code></pre>\n<h2 id=\"3-删除\"><a href=\"#3-删除\" class=\"headerlink\" title=\"3.删除\"></a>3.删除</h2><blockquote>\n<p>spop<br>语法：spop key</p>\n</blockquote>\n<p>解释：移除并返回一个随机member</p>\n<pre><code>redis 127.0.0.1:6379&gt; smembers stu #pop前  \n1) &quot;zhangsan01&quot;  \n2) &quot;wangwu&quot;  \n3) &quot;lisi&quot;  \n4) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; spop stu  #移除一个随机member  \n&quot;lisi&quot;  \nredis 127.0.0.1:6379&gt; smembers stu #pop后  \n1) &quot;zhangsan01&quot;&lt;span style=&quot;white-space:pre&quot;&gt;   &lt;/span&gt;  \n2) &quot;wangwu&quot;  \n3) &quot;zhangsan&quot;\n</code></pre>\n<blockquote>\n<p>srem<br>语法：srem key member [member …]</p>\n</blockquote>\n<p>解释：移除一个或多个member</p>\n<pre><code>redis 127.0.0.1:6379&gt; smembers tech  \n1) &quot;jim&quot;  \n2) &quot;liming&quot;  \n3) &quot;wangwu&quot;  \n4) &quot;joe&quot;  \nredis 127.0.0.1:6379&gt; srem tech jim   #移除jim  \n(integer) 1  \nredis 127.0.0.1:6379&gt; smembers tech     \n1) &quot;liming&quot;  \n2) &quot;wangwu&quot;  \n3) &quot;joe&quot;  \nredis 127.0.0.1:6379&gt; srem tech liming joe #移除多个member  \n(integer) 2  \nredis 127.0.0.1:6379&gt; smembers tech  \n1) &quot;wangwu&quot;\n</code></pre>\n<blockquote>\n<p>smove<br>语法：smove source destination member</p>\n</blockquote>\n<p>解释：将source中的member移动到destination</p>\n<pre><code>redis 127.0.0.1:6379&gt; smembers tech   #smove前  \n1) &quot;wangwu&quot;  \nredis 127.0.0.1:6379&gt; smembers stu  \n1) &quot;zhangsan01&quot;  \n2) &quot;wangwu&quot;  \n3) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; smove stu tech zhangsan  #将zhangsan 从stu移动到tech  \n(integer) 1  \nredis 127.0.0.1:6379&gt; smembers stu #smove后  \n1) &quot;zhangsan01&quot;  \n2) &quot;wangwu&quot;  \nredis 127.0.0.1:6379&gt; smembers tech  \n1) &quot;wangwu&quot;  \n2) &quot;zhangsan&quot;\n</code></pre>\n<h2 id=\"4-其他\"><a href=\"#4-其他\" class=\"headerlink\" title=\"4.其他\"></a>4.其他</h2><blockquote>\n<p>并集<br>语法：sunion key[key…]</p>\n</blockquote>\n<p>解释：多个set的并集</p>\n<pre><code>redis 127.0.0.1:6379&gt; smembers stu  \n1) &quot;zhangsan01&quot;  \n2) &quot;wangwu&quot;  \nredis 127.0.0.1:6379&gt; sunion stu  \n1) &quot;zhangsan01&quot;  \n2) &quot;wangwu&quot;  \nredis 127.0.0.1:6379&gt; smembers tech  \n1) &quot;wangwu&quot;  \n2) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; sunion stu tech  \n1) &quot;zhangsan01&quot;  \n2) &quot;wangwu&quot;  \n3) &quot;zhangsan&quot;\n</code></pre>\n<blockquote>\n<p>把并集结果存储到set<br>语法：sunionstore destination key [key …]</p>\n</blockquote>\n<p>解释：求多个set并集，并把结果存储到destination </p>\n<pre><code>redis 127.0.0.1:6379&gt; sunionstore same stu tech #把stu tech并集结果存储在union  \n(integer) 3  \nredis 127.0.0.1:6379&gt; smembers union  \n1) &quot;zhangsan01&quot;  \n2) &quot;wangwu&quot;  \n3) &quot;zhangsan&quot;\n</code></pre>\n<blockquote>\n<p>交集<br>语法：sinter key[key…]</p>\n</blockquote>\n<p>解释：多个set的交集</p>\n<pre><code>redis 127.0.0.1:6379&gt; smembers stu  \n1) &quot;zhangsan01&quot;  \n2) &quot;wangwu&quot;  \nredis 127.0.0.1:6379&gt; smembers tech  \n1) &quot;wangwu&quot;  \n2) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; sinter stu tech  \n1) &quot;wangwu&quot;\n</code></pre>\n<blockquote>\n<p>把交集结果存储到指定set<br>语法：sinterstore destination key [key …]</p>\n</blockquote>\n<p>解释：把多个set的交集结果存储到destination </p>\n<pre><code>redis 127.0.0.1:6379&gt; sinterstore inter stu tech  \n(integer) 1  \nredis 127.0.0.1:6379&gt; smembers inter  \n1) &quot;wangwu&quot;\n</code></pre>\n<blockquote>\n<p>set中在其他set中不存在member<br>语法：sdiff key[key …]</p>\n</blockquote>\n<pre><code>redis 127.0.0.1:6379&gt;   \nredis 127.0.0.1:6379&gt; smembers stu  \n1) &quot;zhangsan01&quot;  \n2) &quot;wangwu&quot;  \nredis 127.0.0.1:6379&gt; smembers tech  \n1) &quot;wangwu&quot;  \n2) &quot;zhangsan&quot;  \nredis 127.0.0.1:6379&gt; sdiff stu tech  \n1) &quot;zhangsan01&quot;  \nredis 127.0.0.1:6379&gt; sdiff tech stu  \n1) &quot;zhangsan&quot;\n</code></pre>\n<blockquote>\n<p>把set中在其他set中不存在的member存储到新的set<br>语法：sdiffstore key[key…]</p>\n</blockquote>\n<pre><code>redis 127.0.0.1:6379&gt; sdiffstore diff stu tech  \n(integer) 1  \nredis 127.0.0.1:6379&gt; smembers diff  \n1) &quot;zhangsan01&quot;\n</code></pre>\n<p><a href=\"http://redis.io/commands#set\">http://redis.io/commands#set</a></p>"},{"title":"用Keytool和OpenSSL生成和签发数字证书","date":"2014-05-28T10:13:38.000Z","_content":"\n---\nJAVA Keytool\n---\n>JDK目录%JAVA_HOME%/bin提供了密钥库管理工具Keytool，用于管理密钥、证书和证书链。Keytool也可以用来管理对称加密算法中的密钥。\n\n最简单的命令是生成一个自签名的证书，并把它放到指定的keystore文件中：\n\n    keytool -genkey -alias tomcat -keyalg RSA -keystore c:/mykey\n\n注意，公共名称(cn)应该是服务器的域名。这样keystore中就存在一个别名为tomcat的实体，它包括公钥、私钥和证书。这个证书是自签名的。\n\n<!--more-->\n\n下面用Keytool生成CSR（Certificate Signing Request），并用OpenSSL生成CA签名的证书,OpenSSL就不在这介绍了。\n\n1. 准备\n---\n\n    1) 在bin目录下新建目录 demoCA、demoCA/certs、demoCA/newcerts\n    2) 在demoCA建立一个空文件 index.txt\n    3) 在demoCA建立一个文本文件 serial, 没有扩展名，内容是一个合法的16进制数字，例如 0000\n    4) 配置环境变量PATH，加入%JAVA_HOME%/bin，本文用的JavaSDK1.6\n    \n2. 生成CA的自签名证书\n---\n    openssl req -new -x509 -keyout ca.key -out ca.crt -config openssl.cnf\n    \n3. 生成server端证书\n---\n1)生成KeyPair生成密钥对\n\n    keytool -genkey -alias tomcat_server -validity 365 -keyalg RSA -keysize 1024 -keypass 123456  -storepass 123456 -keystore server_keystore\n    \n输入common name时，要和服务器的域名保持一致。\n\n2)生成证书签名请求\n\n    keytool -certreq -alias tomcat_server -sigalg MD5withRSA -file tomcat_server.csr -keypass 123456 -storepass 123456 -keystore server_keystore\n    \n3)用CA私钥进行签名，也可以到权威机构申请CA签名。\n\n    openssl ca -in tomcat_server.csr -out tomcat_server.crt -cert ca.crt -keyfile ca.key -notext -config openssl.cnf\n    \n其中-notext表示不要把证书文件的明文内容输出到文件中去，否则在后面用keytool导入到keystore时会出错。\n\n4)导入信任的CA根证书到keystore\n\n    keytool -import -v -trustcacerts  -alias my_ca_root -file ca.crt -storepass 123456 -keystore server_keystore\n    \n5)把CA签名后的server端证书导入keystore\n\n    keytool -import -v -alias tomcat_server -file tomcat_server.crt -storepass 123456 -keystore server_keystore\n    \n6)查看server端证书\n\n    keytool -list -v -keystore server_keystore\n    \n可以看到tomcat_server的证书链长度是2\n\n4. 生成client端证书\n---\n1)生成客户端CSR\n\n    openssl genrsa -des3 -out tomcat_client.key 1024\n    openssl req -new -key tomcat_client.key -out tomcat_client.csr -confi openssl.cnf\n    \n2)用CA私钥进行签名，也可以到权威机构申请CA签名\n\n    openssl ca -in tomcat_client.csr -out tomcat_client.crt -cert ca.crt -keyfile ca.key -notext -config openssl.cnf\n    \n3)生成PKCS12格式证书\n\n    openssl pkcs12 -export -inkey tomcat_client.key -in tomcat_client.crt -out  tomcat_client.p12\n    \n4)使用Keytool列出pkcs12证书的内容\n\n    keytool -rfc -list -keystore tomcat_client.p12 -storetype pkcs12\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/ssl-ca.md","raw":"title: 用Keytool和OpenSSL生成和签发数字证书\ndate: 2014-05-28 18:13:38\ncategories: 技术\n---\n\n---\nJAVA Keytool\n---\n>JDK目录%JAVA_HOME%/bin提供了密钥库管理工具Keytool，用于管理密钥、证书和证书链。Keytool也可以用来管理对称加密算法中的密钥。\n\n最简单的命令是生成一个自签名的证书，并把它放到指定的keystore文件中：\n\n    keytool -genkey -alias tomcat -keyalg RSA -keystore c:/mykey\n\n注意，公共名称(cn)应该是服务器的域名。这样keystore中就存在一个别名为tomcat的实体，它包括公钥、私钥和证书。这个证书是自签名的。\n\n<!--more-->\n\n下面用Keytool生成CSR（Certificate Signing Request），并用OpenSSL生成CA签名的证书,OpenSSL就不在这介绍了。\n\n1. 准备\n---\n\n    1) 在bin目录下新建目录 demoCA、demoCA/certs、demoCA/newcerts\n    2) 在demoCA建立一个空文件 index.txt\n    3) 在demoCA建立一个文本文件 serial, 没有扩展名，内容是一个合法的16进制数字，例如 0000\n    4) 配置环境变量PATH，加入%JAVA_HOME%/bin，本文用的JavaSDK1.6\n    \n2. 生成CA的自签名证书\n---\n    openssl req -new -x509 -keyout ca.key -out ca.crt -config openssl.cnf\n    \n3. 生成server端证书\n---\n1)生成KeyPair生成密钥对\n\n    keytool -genkey -alias tomcat_server -validity 365 -keyalg RSA -keysize 1024 -keypass 123456  -storepass 123456 -keystore server_keystore\n    \n输入common name时，要和服务器的域名保持一致。\n\n2)生成证书签名请求\n\n    keytool -certreq -alias tomcat_server -sigalg MD5withRSA -file tomcat_server.csr -keypass 123456 -storepass 123456 -keystore server_keystore\n    \n3)用CA私钥进行签名，也可以到权威机构申请CA签名。\n\n    openssl ca -in tomcat_server.csr -out tomcat_server.crt -cert ca.crt -keyfile ca.key -notext -config openssl.cnf\n    \n其中-notext表示不要把证书文件的明文内容输出到文件中去，否则在后面用keytool导入到keystore时会出错。\n\n4)导入信任的CA根证书到keystore\n\n    keytool -import -v -trustcacerts  -alias my_ca_root -file ca.crt -storepass 123456 -keystore server_keystore\n    \n5)把CA签名后的server端证书导入keystore\n\n    keytool -import -v -alias tomcat_server -file tomcat_server.crt -storepass 123456 -keystore server_keystore\n    \n6)查看server端证书\n\n    keytool -list -v -keystore server_keystore\n    \n可以看到tomcat_server的证书链长度是2\n\n4. 生成client端证书\n---\n1)生成客户端CSR\n\n    openssl genrsa -des3 -out tomcat_client.key 1024\n    openssl req -new -key tomcat_client.key -out tomcat_client.csr -confi openssl.cnf\n    \n2)用CA私钥进行签名，也可以到权威机构申请CA签名\n\n    openssl ca -in tomcat_client.csr -out tomcat_client.crt -cert ca.crt -keyfile ca.key -notext -config openssl.cnf\n    \n3)生成PKCS12格式证书\n\n    openssl pkcs12 -export -inkey tomcat_client.key -in tomcat_client.crt -out  tomcat_client.p12\n    \n4)使用Keytool列出pkcs12证书的内容\n\n    keytool -rfc -list -keystore tomcat_client.p12 -storetype pkcs12\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"ssl-ca","published":1,"updated":"2024-04-11T13:25:35.627Z","comments":1,"layout":"post","photos":[],"_id":"cluvablv5000lcbihbzg92r8e","content":"<hr>\n<h2 id=\"JAVA-Keytool\"><a href=\"#JAVA-Keytool\" class=\"headerlink\" title=\"JAVA Keytool\"></a>JAVA Keytool</h2><blockquote>\n<p>JDK目录%JAVA_HOME%&#x2F;bin提供了密钥库管理工具Keytool，用于管理密钥、证书和证书链。Keytool也可以用来管理对称加密算法中的密钥。</p>\n</blockquote>\n<p>最简单的命令是生成一个自签名的证书，并把它放到指定的keystore文件中：</p>\n<pre><code>keytool -genkey -alias tomcat -keyalg RSA -keystore c:/mykey\n</code></pre>\n<p>注意，公共名称(cn)应该是服务器的域名。这样keystore中就存在一个别名为tomcat的实体，它包括公钥、私钥和证书。这个证书是自签名的。</p>\n<span id=\"more\"></span>\n\n<p>下面用Keytool生成CSR（Certificate Signing Request），并用OpenSSL生成CA签名的证书,OpenSSL就不在这介绍了。</p>\n<ol>\n<li>准备</li>\n</ol>\n<hr>\n<pre><code>1) 在bin目录下新建目录 demoCA、demoCA/certs、demoCA/newcerts\n2) 在demoCA建立一个空文件 index.txt\n3) 在demoCA建立一个文本文件 serial, 没有扩展名，内容是一个合法的16进制数字，例如 0000\n4) 配置环境变量PATH，加入%JAVA_HOME%/bin，本文用的JavaSDK1.6\n</code></pre>\n<ol start=\"2\">\n<li>生成CA的自签名证书</li>\n</ol>\n<hr>\n<pre><code>openssl req -new -x509 -keyout ca.key -out ca.crt -config openssl.cnf\n</code></pre>\n<ol start=\"3\">\n<li>生成server端证书</li>\n</ol>\n<hr>\n<p>1)生成KeyPair生成密钥对</p>\n<pre><code>keytool -genkey -alias tomcat_server -validity 365 -keyalg RSA -keysize 1024 -keypass 123456  -storepass 123456 -keystore server_keystore\n</code></pre>\n<p>输入common name时，要和服务器的域名保持一致。</p>\n<p>2)生成证书签名请求</p>\n<pre><code>keytool -certreq -alias tomcat_server -sigalg MD5withRSA -file tomcat_server.csr -keypass 123456 -storepass 123456 -keystore server_keystore\n</code></pre>\n<p>3)用CA私钥进行签名，也可以到权威机构申请CA签名。</p>\n<pre><code>openssl ca -in tomcat_server.csr -out tomcat_server.crt -cert ca.crt -keyfile ca.key -notext -config openssl.cnf\n</code></pre>\n<p>其中-notext表示不要把证书文件的明文内容输出到文件中去，否则在后面用keytool导入到keystore时会出错。</p>\n<p>4)导入信任的CA根证书到keystore</p>\n<pre><code>keytool -import -v -trustcacerts  -alias my_ca_root -file ca.crt -storepass 123456 -keystore server_keystore\n</code></pre>\n<p>5)把CA签名后的server端证书导入keystore</p>\n<pre><code>keytool -import -v -alias tomcat_server -file tomcat_server.crt -storepass 123456 -keystore server_keystore\n</code></pre>\n<p>6)查看server端证书</p>\n<pre><code>keytool -list -v -keystore server_keystore\n</code></pre>\n<p>可以看到tomcat_server的证书链长度是2</p>\n<ol start=\"4\">\n<li>生成client端证书</li>\n</ol>\n<hr>\n<p>1)生成客户端CSR</p>\n<pre><code>openssl genrsa -des3 -out tomcat_client.key 1024\nopenssl req -new -key tomcat_client.key -out tomcat_client.csr -confi openssl.cnf\n</code></pre>\n<p>2)用CA私钥进行签名，也可以到权威机构申请CA签名</p>\n<pre><code>openssl ca -in tomcat_client.csr -out tomcat_client.crt -cert ca.crt -keyfile ca.key -notext -config openssl.cnf\n</code></pre>\n<p>3)生成PKCS12格式证书</p>\n<pre><code>openssl pkcs12 -export -inkey tomcat_client.key -in tomcat_client.crt -out  tomcat_client.p12\n</code></pre>\n<p>4)使用Keytool列出pkcs12证书的内容</p>\n<pre><code>keytool -rfc -list -keystore tomcat_client.p12 -storetype pkcs12\n</code></pre>\n","excerpt":"<hr>\n<h2 id=\"JAVA-Keytool\"><a href=\"#JAVA-Keytool\" class=\"headerlink\" title=\"JAVA Keytool\"></a>JAVA Keytool</h2><blockquote>\n<p>JDK目录%JAVA_HOME%&#x2F;bin提供了密钥库管理工具Keytool，用于管理密钥、证书和证书链。Keytool也可以用来管理对称加密算法中的密钥。</p>\n</blockquote>\n<p>最简单的命令是生成一个自签名的证书，并把它放到指定的keystore文件中：</p>\n<pre><code>keytool -genkey -alias tomcat -keyalg RSA -keystore c:/mykey\n</code></pre>\n<p>注意，公共名称(cn)应该是服务器的域名。这样keystore中就存在一个别名为tomcat的实体，它包括公钥、私钥和证书。这个证书是自签名的。</p>","more":"<p>下面用Keytool生成CSR（Certificate Signing Request），并用OpenSSL生成CA签名的证书,OpenSSL就不在这介绍了。</p>\n<ol>\n<li>准备</li>\n</ol>\n<hr>\n<pre><code>1) 在bin目录下新建目录 demoCA、demoCA/certs、demoCA/newcerts\n2) 在demoCA建立一个空文件 index.txt\n3) 在demoCA建立一个文本文件 serial, 没有扩展名，内容是一个合法的16进制数字，例如 0000\n4) 配置环境变量PATH，加入%JAVA_HOME%/bin，本文用的JavaSDK1.6\n</code></pre>\n<ol start=\"2\">\n<li>生成CA的自签名证书</li>\n</ol>\n<hr>\n<pre><code>openssl req -new -x509 -keyout ca.key -out ca.crt -config openssl.cnf\n</code></pre>\n<ol start=\"3\">\n<li>生成server端证书</li>\n</ol>\n<hr>\n<p>1)生成KeyPair生成密钥对</p>\n<pre><code>keytool -genkey -alias tomcat_server -validity 365 -keyalg RSA -keysize 1024 -keypass 123456  -storepass 123456 -keystore server_keystore\n</code></pre>\n<p>输入common name时，要和服务器的域名保持一致。</p>\n<p>2)生成证书签名请求</p>\n<pre><code>keytool -certreq -alias tomcat_server -sigalg MD5withRSA -file tomcat_server.csr -keypass 123456 -storepass 123456 -keystore server_keystore\n</code></pre>\n<p>3)用CA私钥进行签名，也可以到权威机构申请CA签名。</p>\n<pre><code>openssl ca -in tomcat_server.csr -out tomcat_server.crt -cert ca.crt -keyfile ca.key -notext -config openssl.cnf\n</code></pre>\n<p>其中-notext表示不要把证书文件的明文内容输出到文件中去，否则在后面用keytool导入到keystore时会出错。</p>\n<p>4)导入信任的CA根证书到keystore</p>\n<pre><code>keytool -import -v -trustcacerts  -alias my_ca_root -file ca.crt -storepass 123456 -keystore server_keystore\n</code></pre>\n<p>5)把CA签名后的server端证书导入keystore</p>\n<pre><code>keytool -import -v -alias tomcat_server -file tomcat_server.crt -storepass 123456 -keystore server_keystore\n</code></pre>\n<p>6)查看server端证书</p>\n<pre><code>keytool -list -v -keystore server_keystore\n</code></pre>\n<p>可以看到tomcat_server的证书链长度是2</p>\n<ol start=\"4\">\n<li>生成client端证书</li>\n</ol>\n<hr>\n<p>1)生成客户端CSR</p>\n<pre><code>openssl genrsa -des3 -out tomcat_client.key 1024\nopenssl req -new -key tomcat_client.key -out tomcat_client.csr -confi openssl.cnf\n</code></pre>\n<p>2)用CA私钥进行签名，也可以到权威机构申请CA签名</p>\n<pre><code>openssl ca -in tomcat_client.csr -out tomcat_client.crt -cert ca.crt -keyfile ca.key -notext -config openssl.cnf\n</code></pre>\n<p>3)生成PKCS12格式证书</p>\n<pre><code>openssl pkcs12 -export -inkey tomcat_client.key -in tomcat_client.crt -out  tomcat_client.p12\n</code></pre>\n<p>4)使用Keytool列出pkcs12证书的内容</p>\n<pre><code>keytool -rfc -list -keystore tomcat_client.p12 -storetype pkcs12\n</code></pre>"},{"title":"如何建立技术型团队的五步法则","date":"2016-01-09T15:38:21.000Z","_content":"\n>在IT项目中，一支强有力的技术型团队是项目成功的关键，那么如何才能建立出这样一支成功的技术型项目团队？看看加拿大魁北克大学管理院教授Prosper Bernard是如何来阐述的。\n\n\n<!--more-->\n\n## 衡量团队竞争力的五级成熟度模型\n\n&emsp;&emsp;这是构建成功项目团队的第一步，也是绝对重要的一步。在构建团队的初始阶段，在客户以及项目组成员中形成团队有能力完成项目的思想观念至关重要。“这种观点的基本构成有我们常说的管理能力，技术能力以及项目领导的方向感。”加拿大魁北克大学管理院Prosper Bernard教授认为，“如果项目领导清楚的知道‘如何运作’才能使他们的项目成功，项目的客户以及组员就会感到信心十足，而这种信任对团队士气有巨大的影响。” \n       \n&emsp;&emsp;在此思想的基础上，卡内基梅隆大学（Carnegie Mellon University）的软件工程协会 （Software Engineering Institute，SEI）做出了团队成熟等级模型，将项目团队分为初始型、重复型、定义型、管理型、优化型等五个等级。\n\n**初始型等级**      \n\n&emsp;&emsp;处在这种等级的团队或组织倾向于采用一种混乱的、特别的、“按照自己的开发方式”的方法构建各种新的制度体系。属于此种类型的团队凝聚力较低，工作效率也比较低。      \n\n**重复型等级**      \n\n&emsp;&emsp;团队或组织使用了计划技能，综合系统方式中的需求，利用软件质量确认技术，以及按照已经形成的路径图进行后续的努力。      \n\n**定义型等级**     \n\n&emsp;&emsp;团队和组织按照已经定义的方法步骤，使用过程提升技术以提高方法路径的有效性，引入规范的培训程序，以一种整合的观点看待整个系统开发过程，同时更多的使用正规信息工程和结构开发技术。\n\n**管理型等级**      \n\n&emsp;&emsp;团队或组织切实的掌握并应用了软件开发标准，从而实现准确预计以及过程分析的目的。同时，一些全面质量管理（Total Quality Management, TQM）的观念也被应用于提高整体开发过程效率。  \n\n**优化型等级**     \n\n&emsp;&emsp;团队或组织使用持续的组织变革管理技术，用来优化自身的运营效率，以强调缺陷预防比缺陷诊治更重要，从而持续发现技术开发机会。当然，这种技术也可以应用到整个公司。 \n\n## 成熟度模型建立项目团队的五步法则\n\n&emsp;&emsp;根据Prosper Bernard教授的成熟度模型，五种等级依次递增，利用这种模型我们可以为自己的团队定位，并依次总结出建立技术型项目团队的五步法则。\n\n**法则一：项目团队经验互补 团队成功的关键**\n\n&emsp;&emsp;团队不仅在技术上是统一的、互补的整合体，同样在经验上也是要互补的。正像Prosper教授说的那样：“即使在成功率很高的组织中，任何情况下，团队成功的关键因素都是项目团队成员的大量经验。”      \n\n&emsp;&emsp;比如回答这样的问题：项目团队是否有商界专家？如果没有，是否能指任的一个或几个成员站在客户的角度有效沟通和讨论商业需求的问题？团队中是否有人能真正理解“商务活动是个巨大的信心构建者”这种观念？只有当团队回答这些问题是肯定的时候，才能使团队中的分析者和设计者向除顾客之外的其他人询问需要问的问题，而不是仅仅关注顾客。从而，团队可以切实的有效利用每个人的时间，并增强了后续软件工作的安全性。另外，这样也可以保证团队的“创造性思维”在合理的边界内。\n\n&emsp;&emsp;说到这里我们很容易想到，技术专家作为技术上的权威，熟悉在既定技术环境中的专业技术以提高团队信心。一位技术专家可以援助其他人，提供建议，开发项目标准，也可以防止开发错误的时间浪费。他们会在关键的时候觉察出项目是不是进入了茫然区，就像是在海上没有航标一样？      \n\n&emsp;&emsp;另外，专家也是树立团队领导楷模的关键。通过为其他人树立工作和经验的先锋楷模，技术专家可以在很短的时间内有效的转移技术知识和经验。同时技术专家也可以避免，新的项目无视标准的“按照自己的开发方式”进行工作。\n\n**法则二：项目控制和协调 保证项目结果吻合**\n\n&emsp;&emsp;“对于在整个开发过程中，需要许多人员参与的巨大且复杂的项目来说，需要制定并使用高水平且详尽的说明，以在个人成果整合成最终产品的时候，提供指导性的帮助。” Prosper 教授认为，“项目成果的分解，必然会使项目中的个人关注于自己那部分的工作。这时项目团队需要清晰界定的标准和规格说明，以保证预期最终结果与实际各部分整合后的结果相吻合。”      \n\n&emsp;&emsp;确实，在许多时候，系统设计可以被认为是一系列规格，且各分任务的各项成果以螺旋的方式交替上升并形成更详尽说明的阶段性成果。在此过程中，能否将所有人的努力统一聚集到一起是整个团队所面对的最终挑战。      \n\n&emsp;&emsp;那么哪些因素影响着这种统一聚集的程度呢？      \n\n&emsp;&emsp;其一是开发出合适的标准。这种标准具有一致性和连贯性，在每个项目阶段，应该开发指导方针已指导项目内容以及阶段成果的形势；\n\n&emsp;&emsp;其二是团队的交叉沟通。一般需求，相似论题，共享数据，以及功能性再利用都应该以开放的形势进行讨论和协调。团队成员应该参加所有较高共享目标的开发，鼓励团队成员间的交互作用，增强团队内部的交叉沟通和决策制定；      \n\n&emsp;&emsp;其三是上级团队领导将团队个人融为一体，即采用一致的交付成果，质量保证，方法和审查标准。这些方面是必须要在团队中采用的，以保证团队成员的平等。\n\n**法则三：团队目标和个体目标 决定项目执行的根本性差异**\n\n&emsp;&emsp;随着时间的推移，项目团队会呈现出自身独特的“个性”。这种个性表现为与团队成员的各自反映。比如当团队热情高涨时，自信和确定性也会广泛传播；当团队失去方向时，团队会用怀疑和混淆的眼光看待周围事物。这样的想象常常在我们的IT项目团队中出现。那么，为什么常常出现同一个项目会在不同的团队执行中有如此大的差异？“领导力毫无疑问的起着重要性的作用，但是团队成员的个人态度是产生差异的根本原因。”Prosper教授提出了两种基本的问题解释了团队努力的热情。      \n \n&emsp;&emsp;第一个问题：是否团队中的每个人都在努力朝向统一的、清晰的目标前进？\n\n&emsp;&emsp;第二个问题：目标是谁的？      \n\n&emsp;&emsp;正如IT经理所看到的，在软件开发项目中会有一些让人意想不到的事情发生：所有人都在忙着工作，忙着做自己认为重要的工作。我们必须承认，这是人类自然的本性行为，也是人类兴趣爱好发展的必要步骤。而我们希望的是每个人的工作应该与其他的团队成果相吻合，否则，个人成果与兴趣永远不能整合到团队层面上。然而，如果团队中的所有人清晰的、正确的明白最终目标，那么我们所希望的状态就会实现。      \n\n&emsp;&emsp;有必须要指出的是，即使团队成员确实被团队目标所驱动，但团队的领导却对实际的目标很模糊，就会发生个人目标和一些突发性目标占据主要地位的情况，接着就会慢慢形成或者触发那些潜在的冲突。在项目经理认识到冲突之前，表面上每个人都在忙于工作，工作的氛围也看似有效率，但是，不久以后就不得不做一次重大的内部协调工作。这势必会是项目经理陷入被动的状态，这是任何项目经理所不希望的。      \n\n&emsp;&emsp;面对上面提到的问题，解决的方法就是确保整体目标和个人目标能被清晰的说明和定义，以及每个人对各项工作活动和任务的分配与执行有统一的理解，这将会使团队有目标共享的意愿，而且团队中的每个人都要对各阶段的输出成果负责。当各成员清楚的认识到各项工作的相关性和每项工作对最终结果贡献的重要性，当他们的个人目标体现在团队目标中时，这些措施会对成员态度产生巨大的激励效果，比如增强个人的自我激励强度，创造了开放式沟通环境等。      \n\n&emsp;&emsp;“更让我们欣慰的是，这些激励的效果最终会体现在产品的质量和工作效率上。” Prosper Bernard教授这样说。\n\n**法则四：系统设计的全新视角 团队中的“幻想家”**\n\n&emsp;&emsp;全新的视角很重要，但如果这只是某一个人的想法，这种视角不会对项目产生任何作用。相反，只有当被团队所吸收和采纳，这种视角的优势才能显现出来。“在团队或组织中的‘幻想家’扮演着重要但常被忽视的角色，而正是他们的想法和意愿塑造了独特视角的优越性。他们往往愿意分享自己的观点和想象以及分享自己对现状的理解，而这些正是团队实现预期的必要条件。”Prosper教授用“幻想家”这个词语代替那些有独特全新视角的成员。\n\n&emsp;&emsp;“同时，这取决于两种因素：‘幻想家’对自己的观点的信心以及他对审查和批评的包容。因为随着项目的每个阶段的结束，‘幻想家’必须要持续的发展并和团队沟通他对系统功能和项目实现路径的观点。”      \n\n&emsp;&emsp;撇开一些个人的因素，一个专业的系统正是孕育“幻想家”的系统。在这样的系统中，团队内需要推广全新视角，这会产生两种重要的结果：第一，为持续的讨论提供了条件。因为在许多的情况下，项目开始时的原有的观点思想就不会坚持很长时间，原因就是在项目进行中会产生好的思想并增加了讨论的次数和增强了讨论的效果。第二，鼓励批评和结构性的思考。新视角新想法的提出笔会引起一系列的思想撞击，势必会带来针对新视角的批评，但这并不是坏事。      \n\n&emsp;&emsp;“许多的项目领导倾向于提供一种需要更多输入的‘审查-提高’模型，而不是‘混乱-创造’模型。”在现代社会中，后者更适应时代的变化。另外，如果“幻想家”可以放弃原有观点，并鼓励和促进新观点成为团队所共有的资产，“混乱-创造”模型的有效性就是被体现出来。我们必须承认：项目经理是初始观点的缔造者，而团队成员和商务客户却是项目最终方向和共享观点发展的决定者。\n\n**法则五：树立项目团队的信心 为信仰而工作**\n\n&emsp;&emsp;另一个重要的团队态度是项目团队的信心。Prosper教授认为“复杂系统的开发为项目团队带来了巨大的挑战。有时，面对这种挑战，团队的工作更像是为了信仰而工作。”      \n\n&emsp;&emsp;项目经理都很了解在整个系统中，大量的细节需要收集、分析、组织以及消化吸收。在许多情形下，团队中只有少数成员可以持有全局的观点，并且这种观点也可能会不同程度的发生变化。最常见的变化是随着时间的推移，这种观点会变得很模糊，而正是这种模糊性测试了团队对项目的信心。比如在不确定的情况下，团队对整个项目成功的确定和信心如何？这会不会影响到团队成员的态度？确定诸如这样地问题，我们可以看出一个团队是不是对未来拥有信心。      \n\n&emsp;&emsp;“我们可以通过逐渐引入解决方案的方式进行系统设计，反复进行的过程中，实现增强团队的信心，使每个团队成员能耐心的面对缓慢变化的模糊性。团队中曾参与过系统设计整个生命周期的人员越多，则越有可能使整个团队意识到所有的工作将在每个重大里程碑时间点上聚集。”这正是为缺乏经验的项目团队成员建立信心的关键。同样，团队如果有越高程度的地信心，那么客户也会对项目的成功有信心，团队也更能正视自己的成功，尽管会面临不确定的环境。\n","source":"_posts/team-building.md","raw":"title: 如何建立技术型团队的五步法则\ndate: 2016-01-09 23:38:21\ncategories: 技术\n---\n\n>在IT项目中，一支强有力的技术型团队是项目成功的关键，那么如何才能建立出这样一支成功的技术型项目团队？看看加拿大魁北克大学管理院教授Prosper Bernard是如何来阐述的。\n\n\n<!--more-->\n\n## 衡量团队竞争力的五级成熟度模型\n\n&emsp;&emsp;这是构建成功项目团队的第一步，也是绝对重要的一步。在构建团队的初始阶段，在客户以及项目组成员中形成团队有能力完成项目的思想观念至关重要。“这种观点的基本构成有我们常说的管理能力，技术能力以及项目领导的方向感。”加拿大魁北克大学管理院Prosper Bernard教授认为，“如果项目领导清楚的知道‘如何运作’才能使他们的项目成功，项目的客户以及组员就会感到信心十足，而这种信任对团队士气有巨大的影响。” \n       \n&emsp;&emsp;在此思想的基础上，卡内基梅隆大学（Carnegie Mellon University）的软件工程协会 （Software Engineering Institute，SEI）做出了团队成熟等级模型，将项目团队分为初始型、重复型、定义型、管理型、优化型等五个等级。\n\n**初始型等级**      \n\n&emsp;&emsp;处在这种等级的团队或组织倾向于采用一种混乱的、特别的、“按照自己的开发方式”的方法构建各种新的制度体系。属于此种类型的团队凝聚力较低，工作效率也比较低。      \n\n**重复型等级**      \n\n&emsp;&emsp;团队或组织使用了计划技能，综合系统方式中的需求，利用软件质量确认技术，以及按照已经形成的路径图进行后续的努力。      \n\n**定义型等级**     \n\n&emsp;&emsp;团队和组织按照已经定义的方法步骤，使用过程提升技术以提高方法路径的有效性，引入规范的培训程序，以一种整合的观点看待整个系统开发过程，同时更多的使用正规信息工程和结构开发技术。\n\n**管理型等级**      \n\n&emsp;&emsp;团队或组织切实的掌握并应用了软件开发标准，从而实现准确预计以及过程分析的目的。同时，一些全面质量管理（Total Quality Management, TQM）的观念也被应用于提高整体开发过程效率。  \n\n**优化型等级**     \n\n&emsp;&emsp;团队或组织使用持续的组织变革管理技术，用来优化自身的运营效率，以强调缺陷预防比缺陷诊治更重要，从而持续发现技术开发机会。当然，这种技术也可以应用到整个公司。 \n\n## 成熟度模型建立项目团队的五步法则\n\n&emsp;&emsp;根据Prosper Bernard教授的成熟度模型，五种等级依次递增，利用这种模型我们可以为自己的团队定位，并依次总结出建立技术型项目团队的五步法则。\n\n**法则一：项目团队经验互补 团队成功的关键**\n\n&emsp;&emsp;团队不仅在技术上是统一的、互补的整合体，同样在经验上也是要互补的。正像Prosper教授说的那样：“即使在成功率很高的组织中，任何情况下，团队成功的关键因素都是项目团队成员的大量经验。”      \n\n&emsp;&emsp;比如回答这样的问题：项目团队是否有商界专家？如果没有，是否能指任的一个或几个成员站在客户的角度有效沟通和讨论商业需求的问题？团队中是否有人能真正理解“商务活动是个巨大的信心构建者”这种观念？只有当团队回答这些问题是肯定的时候，才能使团队中的分析者和设计者向除顾客之外的其他人询问需要问的问题，而不是仅仅关注顾客。从而，团队可以切实的有效利用每个人的时间，并增强了后续软件工作的安全性。另外，这样也可以保证团队的“创造性思维”在合理的边界内。\n\n&emsp;&emsp;说到这里我们很容易想到，技术专家作为技术上的权威，熟悉在既定技术环境中的专业技术以提高团队信心。一位技术专家可以援助其他人，提供建议，开发项目标准，也可以防止开发错误的时间浪费。他们会在关键的时候觉察出项目是不是进入了茫然区，就像是在海上没有航标一样？      \n\n&emsp;&emsp;另外，专家也是树立团队领导楷模的关键。通过为其他人树立工作和经验的先锋楷模，技术专家可以在很短的时间内有效的转移技术知识和经验。同时技术专家也可以避免，新的项目无视标准的“按照自己的开发方式”进行工作。\n\n**法则二：项目控制和协调 保证项目结果吻合**\n\n&emsp;&emsp;“对于在整个开发过程中，需要许多人员参与的巨大且复杂的项目来说，需要制定并使用高水平且详尽的说明，以在个人成果整合成最终产品的时候，提供指导性的帮助。” Prosper 教授认为，“项目成果的分解，必然会使项目中的个人关注于自己那部分的工作。这时项目团队需要清晰界定的标准和规格说明，以保证预期最终结果与实际各部分整合后的结果相吻合。”      \n\n&emsp;&emsp;确实，在许多时候，系统设计可以被认为是一系列规格，且各分任务的各项成果以螺旋的方式交替上升并形成更详尽说明的阶段性成果。在此过程中，能否将所有人的努力统一聚集到一起是整个团队所面对的最终挑战。      \n\n&emsp;&emsp;那么哪些因素影响着这种统一聚集的程度呢？      \n\n&emsp;&emsp;其一是开发出合适的标准。这种标准具有一致性和连贯性，在每个项目阶段，应该开发指导方针已指导项目内容以及阶段成果的形势；\n\n&emsp;&emsp;其二是团队的交叉沟通。一般需求，相似论题，共享数据，以及功能性再利用都应该以开放的形势进行讨论和协调。团队成员应该参加所有较高共享目标的开发，鼓励团队成员间的交互作用，增强团队内部的交叉沟通和决策制定；      \n\n&emsp;&emsp;其三是上级团队领导将团队个人融为一体，即采用一致的交付成果，质量保证，方法和审查标准。这些方面是必须要在团队中采用的，以保证团队成员的平等。\n\n**法则三：团队目标和个体目标 决定项目执行的根本性差异**\n\n&emsp;&emsp;随着时间的推移，项目团队会呈现出自身独特的“个性”。这种个性表现为与团队成员的各自反映。比如当团队热情高涨时，自信和确定性也会广泛传播；当团队失去方向时，团队会用怀疑和混淆的眼光看待周围事物。这样的想象常常在我们的IT项目团队中出现。那么，为什么常常出现同一个项目会在不同的团队执行中有如此大的差异？“领导力毫无疑问的起着重要性的作用，但是团队成员的个人态度是产生差异的根本原因。”Prosper教授提出了两种基本的问题解释了团队努力的热情。      \n \n&emsp;&emsp;第一个问题：是否团队中的每个人都在努力朝向统一的、清晰的目标前进？\n\n&emsp;&emsp;第二个问题：目标是谁的？      \n\n&emsp;&emsp;正如IT经理所看到的，在软件开发项目中会有一些让人意想不到的事情发生：所有人都在忙着工作，忙着做自己认为重要的工作。我们必须承认，这是人类自然的本性行为，也是人类兴趣爱好发展的必要步骤。而我们希望的是每个人的工作应该与其他的团队成果相吻合，否则，个人成果与兴趣永远不能整合到团队层面上。然而，如果团队中的所有人清晰的、正确的明白最终目标，那么我们所希望的状态就会实现。      \n\n&emsp;&emsp;有必须要指出的是，即使团队成员确实被团队目标所驱动，但团队的领导却对实际的目标很模糊，就会发生个人目标和一些突发性目标占据主要地位的情况，接着就会慢慢形成或者触发那些潜在的冲突。在项目经理认识到冲突之前，表面上每个人都在忙于工作，工作的氛围也看似有效率，但是，不久以后就不得不做一次重大的内部协调工作。这势必会是项目经理陷入被动的状态，这是任何项目经理所不希望的。      \n\n&emsp;&emsp;面对上面提到的问题，解决的方法就是确保整体目标和个人目标能被清晰的说明和定义，以及每个人对各项工作活动和任务的分配与执行有统一的理解，这将会使团队有目标共享的意愿，而且团队中的每个人都要对各阶段的输出成果负责。当各成员清楚的认识到各项工作的相关性和每项工作对最终结果贡献的重要性，当他们的个人目标体现在团队目标中时，这些措施会对成员态度产生巨大的激励效果，比如增强个人的自我激励强度，创造了开放式沟通环境等。      \n\n&emsp;&emsp;“更让我们欣慰的是，这些激励的效果最终会体现在产品的质量和工作效率上。” Prosper Bernard教授这样说。\n\n**法则四：系统设计的全新视角 团队中的“幻想家”**\n\n&emsp;&emsp;全新的视角很重要，但如果这只是某一个人的想法，这种视角不会对项目产生任何作用。相反，只有当被团队所吸收和采纳，这种视角的优势才能显现出来。“在团队或组织中的‘幻想家’扮演着重要但常被忽视的角色，而正是他们的想法和意愿塑造了独特视角的优越性。他们往往愿意分享自己的观点和想象以及分享自己对现状的理解，而这些正是团队实现预期的必要条件。”Prosper教授用“幻想家”这个词语代替那些有独特全新视角的成员。\n\n&emsp;&emsp;“同时，这取决于两种因素：‘幻想家’对自己的观点的信心以及他对审查和批评的包容。因为随着项目的每个阶段的结束，‘幻想家’必须要持续的发展并和团队沟通他对系统功能和项目实现路径的观点。”      \n\n&emsp;&emsp;撇开一些个人的因素，一个专业的系统正是孕育“幻想家”的系统。在这样的系统中，团队内需要推广全新视角，这会产生两种重要的结果：第一，为持续的讨论提供了条件。因为在许多的情况下，项目开始时的原有的观点思想就不会坚持很长时间，原因就是在项目进行中会产生好的思想并增加了讨论的次数和增强了讨论的效果。第二，鼓励批评和结构性的思考。新视角新想法的提出笔会引起一系列的思想撞击，势必会带来针对新视角的批评，但这并不是坏事。      \n\n&emsp;&emsp;“许多的项目领导倾向于提供一种需要更多输入的‘审查-提高’模型，而不是‘混乱-创造’模型。”在现代社会中，后者更适应时代的变化。另外，如果“幻想家”可以放弃原有观点，并鼓励和促进新观点成为团队所共有的资产，“混乱-创造”模型的有效性就是被体现出来。我们必须承认：项目经理是初始观点的缔造者，而团队成员和商务客户却是项目最终方向和共享观点发展的决定者。\n\n**法则五：树立项目团队的信心 为信仰而工作**\n\n&emsp;&emsp;另一个重要的团队态度是项目团队的信心。Prosper教授认为“复杂系统的开发为项目团队带来了巨大的挑战。有时，面对这种挑战，团队的工作更像是为了信仰而工作。”      \n\n&emsp;&emsp;项目经理都很了解在整个系统中，大量的细节需要收集、分析、组织以及消化吸收。在许多情形下，团队中只有少数成员可以持有全局的观点，并且这种观点也可能会不同程度的发生变化。最常见的变化是随着时间的推移，这种观点会变得很模糊，而正是这种模糊性测试了团队对项目的信心。比如在不确定的情况下，团队对整个项目成功的确定和信心如何？这会不会影响到团队成员的态度？确定诸如这样地问题，我们可以看出一个团队是不是对未来拥有信心。      \n\n&emsp;&emsp;“我们可以通过逐渐引入解决方案的方式进行系统设计，反复进行的过程中，实现增强团队的信心，使每个团队成员能耐心的面对缓慢变化的模糊性。团队中曾参与过系统设计整个生命周期的人员越多，则越有可能使整个团队意识到所有的工作将在每个重大里程碑时间点上聚集。”这正是为缺乏经验的项目团队成员建立信心的关键。同样，团队如果有越高程度的地信心，那么客户也会对项目的成功有信心，团队也更能正视自己的成功，尽管会面临不确定的环境。\n","slug":"team-building","published":1,"updated":"2024-04-11T13:25:35.644Z","comments":1,"layout":"post","photos":[],"_id":"cluvablv6000mcbih09fhgi2t","content":"<blockquote>\n<p>在IT项目中，一支强有力的技术型团队是项目成功的关键，那么如何才能建立出这样一支成功的技术型项目团队？看看加拿大魁北克大学管理院教授Prosper Bernard是如何来阐述的。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"衡量团队竞争力的五级成熟度模型\"><a href=\"#衡量团队竞争力的五级成熟度模型\" class=\"headerlink\" title=\"衡量团队竞争力的五级成熟度模型\"></a>衡量团队竞争力的五级成熟度模型</h2><p>&emsp;&emsp;这是构建成功项目团队的第一步，也是绝对重要的一步。在构建团队的初始阶段，在客户以及项目组成员中形成团队有能力完成项目的思想观念至关重要。“这种观点的基本构成有我们常说的管理能力，技术能力以及项目领导的方向感。”加拿大魁北克大学管理院Prosper Bernard教授认为，“如果项目领导清楚的知道‘如何运作’才能使他们的项目成功，项目的客户以及组员就会感到信心十足，而这种信任对团队士气有巨大的影响。” </p>\n<p>&emsp;&emsp;在此思想的基础上，卡内基梅隆大学（Carnegie Mellon University）的软件工程协会 （Software Engineering Institute，SEI）做出了团队成熟等级模型，将项目团队分为初始型、重复型、定义型、管理型、优化型等五个等级。</p>\n<p><strong>初始型等级</strong>      </p>\n<p>&emsp;&emsp;处在这种等级的团队或组织倾向于采用一种混乱的、特别的、“按照自己的开发方式”的方法构建各种新的制度体系。属于此种类型的团队凝聚力较低，工作效率也比较低。      </p>\n<p><strong>重复型等级</strong>      </p>\n<p>&emsp;&emsp;团队或组织使用了计划技能，综合系统方式中的需求，利用软件质量确认技术，以及按照已经形成的路径图进行后续的努力。      </p>\n<p><strong>定义型等级</strong>     </p>\n<p>&emsp;&emsp;团队和组织按照已经定义的方法步骤，使用过程提升技术以提高方法路径的有效性，引入规范的培训程序，以一种整合的观点看待整个系统开发过程，同时更多的使用正规信息工程和结构开发技术。</p>\n<p><strong>管理型等级</strong>      </p>\n<p>&emsp;&emsp;团队或组织切实的掌握并应用了软件开发标准，从而实现准确预计以及过程分析的目的。同时，一些全面质量管理（Total Quality Management, TQM）的观念也被应用于提高整体开发过程效率。  </p>\n<p><strong>优化型等级</strong>     </p>\n<p>&emsp;&emsp;团队或组织使用持续的组织变革管理技术，用来优化自身的运营效率，以强调缺陷预防比缺陷诊治更重要，从而持续发现技术开发机会。当然，这种技术也可以应用到整个公司。 </p>\n<h2 id=\"成熟度模型建立项目团队的五步法则\"><a href=\"#成熟度模型建立项目团队的五步法则\" class=\"headerlink\" title=\"成熟度模型建立项目团队的五步法则\"></a>成熟度模型建立项目团队的五步法则</h2><p>&emsp;&emsp;根据Prosper Bernard教授的成熟度模型，五种等级依次递增，利用这种模型我们可以为自己的团队定位，并依次总结出建立技术型项目团队的五步法则。</p>\n<p><strong>法则一：项目团队经验互补 团队成功的关键</strong></p>\n<p>&emsp;&emsp;团队不仅在技术上是统一的、互补的整合体，同样在经验上也是要互补的。正像Prosper教授说的那样：“即使在成功率很高的组织中，任何情况下，团队成功的关键因素都是项目团队成员的大量经验。”      </p>\n<p>&emsp;&emsp;比如回答这样的问题：项目团队是否有商界专家？如果没有，是否能指任的一个或几个成员站在客户的角度有效沟通和讨论商业需求的问题？团队中是否有人能真正理解“商务活动是个巨大的信心构建者”这种观念？只有当团队回答这些问题是肯定的时候，才能使团队中的分析者和设计者向除顾客之外的其他人询问需要问的问题，而不是仅仅关注顾客。从而，团队可以切实的有效利用每个人的时间，并增强了后续软件工作的安全性。另外，这样也可以保证团队的“创造性思维”在合理的边界内。</p>\n<p>&emsp;&emsp;说到这里我们很容易想到，技术专家作为技术上的权威，熟悉在既定技术环境中的专业技术以提高团队信心。一位技术专家可以援助其他人，提供建议，开发项目标准，也可以防止开发错误的时间浪费。他们会在关键的时候觉察出项目是不是进入了茫然区，就像是在海上没有航标一样？      </p>\n<p>&emsp;&emsp;另外，专家也是树立团队领导楷模的关键。通过为其他人树立工作和经验的先锋楷模，技术专家可以在很短的时间内有效的转移技术知识和经验。同时技术专家也可以避免，新的项目无视标准的“按照自己的开发方式”进行工作。</p>\n<p><strong>法则二：项目控制和协调 保证项目结果吻合</strong></p>\n<p>&emsp;&emsp;“对于在整个开发过程中，需要许多人员参与的巨大且复杂的项目来说，需要制定并使用高水平且详尽的说明，以在个人成果整合成最终产品的时候，提供指导性的帮助。” Prosper 教授认为，“项目成果的分解，必然会使项目中的个人关注于自己那部分的工作。这时项目团队需要清晰界定的标准和规格说明，以保证预期最终结果与实际各部分整合后的结果相吻合。”      </p>\n<p>&emsp;&emsp;确实，在许多时候，系统设计可以被认为是一系列规格，且各分任务的各项成果以螺旋的方式交替上升并形成更详尽说明的阶段性成果。在此过程中，能否将所有人的努力统一聚集到一起是整个团队所面对的最终挑战。      </p>\n<p>&emsp;&emsp;那么哪些因素影响着这种统一聚集的程度呢？      </p>\n<p>&emsp;&emsp;其一是开发出合适的标准。这种标准具有一致性和连贯性，在每个项目阶段，应该开发指导方针已指导项目内容以及阶段成果的形势；</p>\n<p>&emsp;&emsp;其二是团队的交叉沟通。一般需求，相似论题，共享数据，以及功能性再利用都应该以开放的形势进行讨论和协调。团队成员应该参加所有较高共享目标的开发，鼓励团队成员间的交互作用，增强团队内部的交叉沟通和决策制定；      </p>\n<p>&emsp;&emsp;其三是上级团队领导将团队个人融为一体，即采用一致的交付成果，质量保证，方法和审查标准。这些方面是必须要在团队中采用的，以保证团队成员的平等。</p>\n<p><strong>法则三：团队目标和个体目标 决定项目执行的根本性差异</strong></p>\n<p>&emsp;&emsp;随着时间的推移，项目团队会呈现出自身独特的“个性”。这种个性表现为与团队成员的各自反映。比如当团队热情高涨时，自信和确定性也会广泛传播；当团队失去方向时，团队会用怀疑和混淆的眼光看待周围事物。这样的想象常常在我们的IT项目团队中出现。那么，为什么常常出现同一个项目会在不同的团队执行中有如此大的差异？“领导力毫无疑问的起着重要性的作用，但是团队成员的个人态度是产生差异的根本原因。”Prosper教授提出了两种基本的问题解释了团队努力的热情。      </p>\n<p>&emsp;&emsp;第一个问题：是否团队中的每个人都在努力朝向统一的、清晰的目标前进？</p>\n<p>&emsp;&emsp;第二个问题：目标是谁的？      </p>\n<p>&emsp;&emsp;正如IT经理所看到的，在软件开发项目中会有一些让人意想不到的事情发生：所有人都在忙着工作，忙着做自己认为重要的工作。我们必须承认，这是人类自然的本性行为，也是人类兴趣爱好发展的必要步骤。而我们希望的是每个人的工作应该与其他的团队成果相吻合，否则，个人成果与兴趣永远不能整合到团队层面上。然而，如果团队中的所有人清晰的、正确的明白最终目标，那么我们所希望的状态就会实现。      </p>\n<p>&emsp;&emsp;有必须要指出的是，即使团队成员确实被团队目标所驱动，但团队的领导却对实际的目标很模糊，就会发生个人目标和一些突发性目标占据主要地位的情况，接着就会慢慢形成或者触发那些潜在的冲突。在项目经理认识到冲突之前，表面上每个人都在忙于工作，工作的氛围也看似有效率，但是，不久以后就不得不做一次重大的内部协调工作。这势必会是项目经理陷入被动的状态，这是任何项目经理所不希望的。      </p>\n<p>&emsp;&emsp;面对上面提到的问题，解决的方法就是确保整体目标和个人目标能被清晰的说明和定义，以及每个人对各项工作活动和任务的分配与执行有统一的理解，这将会使团队有目标共享的意愿，而且团队中的每个人都要对各阶段的输出成果负责。当各成员清楚的认识到各项工作的相关性和每项工作对最终结果贡献的重要性，当他们的个人目标体现在团队目标中时，这些措施会对成员态度产生巨大的激励效果，比如增强个人的自我激励强度，创造了开放式沟通环境等。      </p>\n<p>&emsp;&emsp;“更让我们欣慰的是，这些激励的效果最终会体现在产品的质量和工作效率上。” Prosper Bernard教授这样说。</p>\n<p><strong>法则四：系统设计的全新视角 团队中的“幻想家”</strong></p>\n<p>&emsp;&emsp;全新的视角很重要，但如果这只是某一个人的想法，这种视角不会对项目产生任何作用。相反，只有当被团队所吸收和采纳，这种视角的优势才能显现出来。“在团队或组织中的‘幻想家’扮演着重要但常被忽视的角色，而正是他们的想法和意愿塑造了独特视角的优越性。他们往往愿意分享自己的观点和想象以及分享自己对现状的理解，而这些正是团队实现预期的必要条件。”Prosper教授用“幻想家”这个词语代替那些有独特全新视角的成员。</p>\n<p>&emsp;&emsp;“同时，这取决于两种因素：‘幻想家’对自己的观点的信心以及他对审查和批评的包容。因为随着项目的每个阶段的结束，‘幻想家’必须要持续的发展并和团队沟通他对系统功能和项目实现路径的观点。”      </p>\n<p>&emsp;&emsp;撇开一些个人的因素，一个专业的系统正是孕育“幻想家”的系统。在这样的系统中，团队内需要推广全新视角，这会产生两种重要的结果：第一，为持续的讨论提供了条件。因为在许多的情况下，项目开始时的原有的观点思想就不会坚持很长时间，原因就是在项目进行中会产生好的思想并增加了讨论的次数和增强了讨论的效果。第二，鼓励批评和结构性的思考。新视角新想法的提出笔会引起一系列的思想撞击，势必会带来针对新视角的批评，但这并不是坏事。      </p>\n<p>&emsp;&emsp;“许多的项目领导倾向于提供一种需要更多输入的‘审查-提高’模型，而不是‘混乱-创造’模型。”在现代社会中，后者更适应时代的变化。另外，如果“幻想家”可以放弃原有观点，并鼓励和促进新观点成为团队所共有的资产，“混乱-创造”模型的有效性就是被体现出来。我们必须承认：项目经理是初始观点的缔造者，而团队成员和商务客户却是项目最终方向和共享观点发展的决定者。</p>\n<p><strong>法则五：树立项目团队的信心 为信仰而工作</strong></p>\n<p>&emsp;&emsp;另一个重要的团队态度是项目团队的信心。Prosper教授认为“复杂系统的开发为项目团队带来了巨大的挑战。有时，面对这种挑战，团队的工作更像是为了信仰而工作。”      </p>\n<p>&emsp;&emsp;项目经理都很了解在整个系统中，大量的细节需要收集、分析、组织以及消化吸收。在许多情形下，团队中只有少数成员可以持有全局的观点，并且这种观点也可能会不同程度的发生变化。最常见的变化是随着时间的推移，这种观点会变得很模糊，而正是这种模糊性测试了团队对项目的信心。比如在不确定的情况下，团队对整个项目成功的确定和信心如何？这会不会影响到团队成员的态度？确定诸如这样地问题，我们可以看出一个团队是不是对未来拥有信心。      </p>\n<p>&emsp;&emsp;“我们可以通过逐渐引入解决方案的方式进行系统设计，反复进行的过程中，实现增强团队的信心，使每个团队成员能耐心的面对缓慢变化的模糊性。团队中曾参与过系统设计整个生命周期的人员越多，则越有可能使整个团队意识到所有的工作将在每个重大里程碑时间点上聚集。”这正是为缺乏经验的项目团队成员建立信心的关键。同样，团队如果有越高程度的地信心，那么客户也会对项目的成功有信心，团队也更能正视自己的成功，尽管会面临不确定的环境。</p>\n","excerpt":"<blockquote>\n<p>在IT项目中，一支强有力的技术型团队是项目成功的关键，那么如何才能建立出这样一支成功的技术型项目团队？看看加拿大魁北克大学管理院教授Prosper Bernard是如何来阐述的。</p>\n</blockquote>","more":"<h2 id=\"衡量团队竞争力的五级成熟度模型\"><a href=\"#衡量团队竞争力的五级成熟度模型\" class=\"headerlink\" title=\"衡量团队竞争力的五级成熟度模型\"></a>衡量团队竞争力的五级成熟度模型</h2><p>&emsp;&emsp;这是构建成功项目团队的第一步，也是绝对重要的一步。在构建团队的初始阶段，在客户以及项目组成员中形成团队有能力完成项目的思想观念至关重要。“这种观点的基本构成有我们常说的管理能力，技术能力以及项目领导的方向感。”加拿大魁北克大学管理院Prosper Bernard教授认为，“如果项目领导清楚的知道‘如何运作’才能使他们的项目成功，项目的客户以及组员就会感到信心十足，而这种信任对团队士气有巨大的影响。” </p>\n<p>&emsp;&emsp;在此思想的基础上，卡内基梅隆大学（Carnegie Mellon University）的软件工程协会 （Software Engineering Institute，SEI）做出了团队成熟等级模型，将项目团队分为初始型、重复型、定义型、管理型、优化型等五个等级。</p>\n<p><strong>初始型等级</strong>      </p>\n<p>&emsp;&emsp;处在这种等级的团队或组织倾向于采用一种混乱的、特别的、“按照自己的开发方式”的方法构建各种新的制度体系。属于此种类型的团队凝聚力较低，工作效率也比较低。      </p>\n<p><strong>重复型等级</strong>      </p>\n<p>&emsp;&emsp;团队或组织使用了计划技能，综合系统方式中的需求，利用软件质量确认技术，以及按照已经形成的路径图进行后续的努力。      </p>\n<p><strong>定义型等级</strong>     </p>\n<p>&emsp;&emsp;团队和组织按照已经定义的方法步骤，使用过程提升技术以提高方法路径的有效性，引入规范的培训程序，以一种整合的观点看待整个系统开发过程，同时更多的使用正规信息工程和结构开发技术。</p>\n<p><strong>管理型等级</strong>      </p>\n<p>&emsp;&emsp;团队或组织切实的掌握并应用了软件开发标准，从而实现准确预计以及过程分析的目的。同时，一些全面质量管理（Total Quality Management, TQM）的观念也被应用于提高整体开发过程效率。  </p>\n<p><strong>优化型等级</strong>     </p>\n<p>&emsp;&emsp;团队或组织使用持续的组织变革管理技术，用来优化自身的运营效率，以强调缺陷预防比缺陷诊治更重要，从而持续发现技术开发机会。当然，这种技术也可以应用到整个公司。 </p>\n<h2 id=\"成熟度模型建立项目团队的五步法则\"><a href=\"#成熟度模型建立项目团队的五步法则\" class=\"headerlink\" title=\"成熟度模型建立项目团队的五步法则\"></a>成熟度模型建立项目团队的五步法则</h2><p>&emsp;&emsp;根据Prosper Bernard教授的成熟度模型，五种等级依次递增，利用这种模型我们可以为自己的团队定位，并依次总结出建立技术型项目团队的五步法则。</p>\n<p><strong>法则一：项目团队经验互补 团队成功的关键</strong></p>\n<p>&emsp;&emsp;团队不仅在技术上是统一的、互补的整合体，同样在经验上也是要互补的。正像Prosper教授说的那样：“即使在成功率很高的组织中，任何情况下，团队成功的关键因素都是项目团队成员的大量经验。”      </p>\n<p>&emsp;&emsp;比如回答这样的问题：项目团队是否有商界专家？如果没有，是否能指任的一个或几个成员站在客户的角度有效沟通和讨论商业需求的问题？团队中是否有人能真正理解“商务活动是个巨大的信心构建者”这种观念？只有当团队回答这些问题是肯定的时候，才能使团队中的分析者和设计者向除顾客之外的其他人询问需要问的问题，而不是仅仅关注顾客。从而，团队可以切实的有效利用每个人的时间，并增强了后续软件工作的安全性。另外，这样也可以保证团队的“创造性思维”在合理的边界内。</p>\n<p>&emsp;&emsp;说到这里我们很容易想到，技术专家作为技术上的权威，熟悉在既定技术环境中的专业技术以提高团队信心。一位技术专家可以援助其他人，提供建议，开发项目标准，也可以防止开发错误的时间浪费。他们会在关键的时候觉察出项目是不是进入了茫然区，就像是在海上没有航标一样？      </p>\n<p>&emsp;&emsp;另外，专家也是树立团队领导楷模的关键。通过为其他人树立工作和经验的先锋楷模，技术专家可以在很短的时间内有效的转移技术知识和经验。同时技术专家也可以避免，新的项目无视标准的“按照自己的开发方式”进行工作。</p>\n<p><strong>法则二：项目控制和协调 保证项目结果吻合</strong></p>\n<p>&emsp;&emsp;“对于在整个开发过程中，需要许多人员参与的巨大且复杂的项目来说，需要制定并使用高水平且详尽的说明，以在个人成果整合成最终产品的时候，提供指导性的帮助。” Prosper 教授认为，“项目成果的分解，必然会使项目中的个人关注于自己那部分的工作。这时项目团队需要清晰界定的标准和规格说明，以保证预期最终结果与实际各部分整合后的结果相吻合。”      </p>\n<p>&emsp;&emsp;确实，在许多时候，系统设计可以被认为是一系列规格，且各分任务的各项成果以螺旋的方式交替上升并形成更详尽说明的阶段性成果。在此过程中，能否将所有人的努力统一聚集到一起是整个团队所面对的最终挑战。      </p>\n<p>&emsp;&emsp;那么哪些因素影响着这种统一聚集的程度呢？      </p>\n<p>&emsp;&emsp;其一是开发出合适的标准。这种标准具有一致性和连贯性，在每个项目阶段，应该开发指导方针已指导项目内容以及阶段成果的形势；</p>\n<p>&emsp;&emsp;其二是团队的交叉沟通。一般需求，相似论题，共享数据，以及功能性再利用都应该以开放的形势进行讨论和协调。团队成员应该参加所有较高共享目标的开发，鼓励团队成员间的交互作用，增强团队内部的交叉沟通和决策制定；      </p>\n<p>&emsp;&emsp;其三是上级团队领导将团队个人融为一体，即采用一致的交付成果，质量保证，方法和审查标准。这些方面是必须要在团队中采用的，以保证团队成员的平等。</p>\n<p><strong>法则三：团队目标和个体目标 决定项目执行的根本性差异</strong></p>\n<p>&emsp;&emsp;随着时间的推移，项目团队会呈现出自身独特的“个性”。这种个性表现为与团队成员的各自反映。比如当团队热情高涨时，自信和确定性也会广泛传播；当团队失去方向时，团队会用怀疑和混淆的眼光看待周围事物。这样的想象常常在我们的IT项目团队中出现。那么，为什么常常出现同一个项目会在不同的团队执行中有如此大的差异？“领导力毫无疑问的起着重要性的作用，但是团队成员的个人态度是产生差异的根本原因。”Prosper教授提出了两种基本的问题解释了团队努力的热情。      </p>\n<p>&emsp;&emsp;第一个问题：是否团队中的每个人都在努力朝向统一的、清晰的目标前进？</p>\n<p>&emsp;&emsp;第二个问题：目标是谁的？      </p>\n<p>&emsp;&emsp;正如IT经理所看到的，在软件开发项目中会有一些让人意想不到的事情发生：所有人都在忙着工作，忙着做自己认为重要的工作。我们必须承认，这是人类自然的本性行为，也是人类兴趣爱好发展的必要步骤。而我们希望的是每个人的工作应该与其他的团队成果相吻合，否则，个人成果与兴趣永远不能整合到团队层面上。然而，如果团队中的所有人清晰的、正确的明白最终目标，那么我们所希望的状态就会实现。      </p>\n<p>&emsp;&emsp;有必须要指出的是，即使团队成员确实被团队目标所驱动，但团队的领导却对实际的目标很模糊，就会发生个人目标和一些突发性目标占据主要地位的情况，接着就会慢慢形成或者触发那些潜在的冲突。在项目经理认识到冲突之前，表面上每个人都在忙于工作，工作的氛围也看似有效率，但是，不久以后就不得不做一次重大的内部协调工作。这势必会是项目经理陷入被动的状态，这是任何项目经理所不希望的。      </p>\n<p>&emsp;&emsp;面对上面提到的问题，解决的方法就是确保整体目标和个人目标能被清晰的说明和定义，以及每个人对各项工作活动和任务的分配与执行有统一的理解，这将会使团队有目标共享的意愿，而且团队中的每个人都要对各阶段的输出成果负责。当各成员清楚的认识到各项工作的相关性和每项工作对最终结果贡献的重要性，当他们的个人目标体现在团队目标中时，这些措施会对成员态度产生巨大的激励效果，比如增强个人的自我激励强度，创造了开放式沟通环境等。      </p>\n<p>&emsp;&emsp;“更让我们欣慰的是，这些激励的效果最终会体现在产品的质量和工作效率上。” Prosper Bernard教授这样说。</p>\n<p><strong>法则四：系统设计的全新视角 团队中的“幻想家”</strong></p>\n<p>&emsp;&emsp;全新的视角很重要，但如果这只是某一个人的想法，这种视角不会对项目产生任何作用。相反，只有当被团队所吸收和采纳，这种视角的优势才能显现出来。“在团队或组织中的‘幻想家’扮演着重要但常被忽视的角色，而正是他们的想法和意愿塑造了独特视角的优越性。他们往往愿意分享自己的观点和想象以及分享自己对现状的理解，而这些正是团队实现预期的必要条件。”Prosper教授用“幻想家”这个词语代替那些有独特全新视角的成员。</p>\n<p>&emsp;&emsp;“同时，这取决于两种因素：‘幻想家’对自己的观点的信心以及他对审查和批评的包容。因为随着项目的每个阶段的结束，‘幻想家’必须要持续的发展并和团队沟通他对系统功能和项目实现路径的观点。”      </p>\n<p>&emsp;&emsp;撇开一些个人的因素，一个专业的系统正是孕育“幻想家”的系统。在这样的系统中，团队内需要推广全新视角，这会产生两种重要的结果：第一，为持续的讨论提供了条件。因为在许多的情况下，项目开始时的原有的观点思想就不会坚持很长时间，原因就是在项目进行中会产生好的思想并增加了讨论的次数和增强了讨论的效果。第二，鼓励批评和结构性的思考。新视角新想法的提出笔会引起一系列的思想撞击，势必会带来针对新视角的批评，但这并不是坏事。      </p>\n<p>&emsp;&emsp;“许多的项目领导倾向于提供一种需要更多输入的‘审查-提高’模型，而不是‘混乱-创造’模型。”在现代社会中，后者更适应时代的变化。另外，如果“幻想家”可以放弃原有观点，并鼓励和促进新观点成为团队所共有的资产，“混乱-创造”模型的有效性就是被体现出来。我们必须承认：项目经理是初始观点的缔造者，而团队成员和商务客户却是项目最终方向和共享观点发展的决定者。</p>\n<p><strong>法则五：树立项目团队的信心 为信仰而工作</strong></p>\n<p>&emsp;&emsp;另一个重要的团队态度是项目团队的信心。Prosper教授认为“复杂系统的开发为项目团队带来了巨大的挑战。有时，面对这种挑战，团队的工作更像是为了信仰而工作。”      </p>\n<p>&emsp;&emsp;项目经理都很了解在整个系统中，大量的细节需要收集、分析、组织以及消化吸收。在许多情形下，团队中只有少数成员可以持有全局的观点，并且这种观点也可能会不同程度的发生变化。最常见的变化是随着时间的推移，这种观点会变得很模糊，而正是这种模糊性测试了团队对项目的信心。比如在不确定的情况下，团队对整个项目成功的确定和信心如何？这会不会影响到团队成员的态度？确定诸如这样地问题，我们可以看出一个团队是不是对未来拥有信心。      </p>\n<p>&emsp;&emsp;“我们可以通过逐渐引入解决方案的方式进行系统设计，反复进行的过程中，实现增强团队的信心，使每个团队成员能耐心的面对缓慢变化的模糊性。团队中曾参与过系统设计整个生命周期的人员越多，则越有可能使整个团队意识到所有的工作将在每个重大里程碑时间点上聚集。”这正是为缺乏经验的项目团队成员建立信心的关键。同样，团队如果有越高程度的地信心，那么客户也会对项目的成功有信心，团队也更能正视自己的成功，尽管会面临不确定的环境。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cluvablv10005cbihgqb21kw0","category_id":"cluvablv00002cbih0w700ivl","_id":"cluvablv3000acbih6gw08l2q"},{"post_id":"cluvabluw0000cbih5t6o8sfb","category_id":"cluvablv00002cbih0w700ivl","_id":"cluvablv3000ccbih2n6ygvyf"},{"post_id":"cluvablv10006cbiheli8eln7","category_id":"cluvablv00002cbih0w700ivl","_id":"cluvablv3000dcbih0hlb2qb5"},{"post_id":"cluvablv20008cbih2e1qd3uw","category_id":"cluvablv00002cbih0w700ivl","_id":"cluvablv3000fcbih2xsw2yv6"},{"post_id":"cluvabluz0001cbih654u9fxq","category_id":"cluvablv00002cbih0w700ivl","_id":"cluvablv3000hcbih8f5rfdie"},{"post_id":"cluvablv00003cbihfigxajvy","category_id":"cluvablv00002cbih0w700ivl","_id":"cluvablv3000icbih4nkf60dm"},{"post_id":"cluvablv5000jcbih21nv28b4","category_id":"cluvablv00002cbih0w700ivl","_id":"cluvablv6000ncbih86uueyeo"},{"post_id":"cluvablv5000kcbih9aj6bxfq","category_id":"cluvablv00002cbih0w700ivl","_id":"cluvablv6000ocbihc938bx2g"},{"post_id":"cluvablv5000lcbihbzg92r8e","category_id":"cluvablv00002cbih0w700ivl","_id":"cluvablv6000pcbihgg5b0qjg"},{"post_id":"cluvablv6000mcbih09fhgi2t","category_id":"cluvablv00002cbih0w700ivl","_id":"cluvablv6000qcbih4c2612ok"}],"PostTag":[{"post_id":"cluvabluz0001cbih654u9fxq","tag_id":"cluvablv10004cbih51oabviv","_id":"cluvablv3000ecbihdnetgttb"},{"post_id":"cluvabluz0001cbih654u9fxq","tag_id":"cluvablv20009cbih07l2alcm","_id":"cluvablv3000gcbih8fzbc6th"}],"Tag":[{"name":"nosql","_id":"cluvablv10004cbih51oabviv"},{"name":"mongodb","_id":"cluvablv20009cbih07l2alcm"}]}}